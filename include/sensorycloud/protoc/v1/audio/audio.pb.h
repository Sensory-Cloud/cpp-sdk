// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/audio/audio.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2faudio_2faudio_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_v1_2faudio_2faudio_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sensorycloud/protoc/validate/validate.pb.h"
#include "sensorycloud/protoc/common/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_v1_2faudio_2faudio_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2faudio_2faudio_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v1_2faudio_2faudio_2eproto;
namespace sensory {
namespace api {
namespace v1 {
namespace audio {
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class AudioModel;
struct AudioModelDefaultTypeInternal;
extern AudioModelDefaultTypeInternal _AudioModel_default_instance_;
class AuthenticateConfig;
struct AuthenticateConfigDefaultTypeInternal;
extern AuthenticateConfigDefaultTypeInternal _AuthenticateConfig_default_instance_;
class AuthenticateRequest;
struct AuthenticateRequestDefaultTypeInternal;
extern AuthenticateRequestDefaultTypeInternal _AuthenticateRequest_default_instance_;
class AuthenticateResponse;
struct AuthenticateResponseDefaultTypeInternal;
extern AuthenticateResponseDefaultTypeInternal _AuthenticateResponse_default_instance_;
class CreateEnrollmentConfig;
struct CreateEnrollmentConfigDefaultTypeInternal;
extern CreateEnrollmentConfigDefaultTypeInternal _CreateEnrollmentConfig_default_instance_;
class CreateEnrollmentRequest;
struct CreateEnrollmentRequestDefaultTypeInternal;
extern CreateEnrollmentRequestDefaultTypeInternal _CreateEnrollmentRequest_default_instance_;
class CreateEnrollmentResponse;
struct CreateEnrollmentResponseDefaultTypeInternal;
extern CreateEnrollmentResponseDefaultTypeInternal _CreateEnrollmentResponse_default_instance_;
class GetModelsRequest;
struct GetModelsRequestDefaultTypeInternal;
extern GetModelsRequestDefaultTypeInternal _GetModelsRequest_default_instance_;
class GetModelsResponse;
struct GetModelsResponseDefaultTypeInternal;
extern GetModelsResponseDefaultTypeInternal _GetModelsResponse_default_instance_;
class TranscribeConfig;
struct TranscribeConfigDefaultTypeInternal;
extern TranscribeConfigDefaultTypeInternal _TranscribeConfig_default_instance_;
class TranscribeRequest;
struct TranscribeRequestDefaultTypeInternal;
extern TranscribeRequestDefaultTypeInternal _TranscribeRequest_default_instance_;
class TranscribeResponse;
struct TranscribeResponseDefaultTypeInternal;
extern TranscribeResponseDefaultTypeInternal _TranscribeResponse_default_instance_;
class ValidateEventConfig;
struct ValidateEventConfigDefaultTypeInternal;
extern ValidateEventConfigDefaultTypeInternal _ValidateEventConfig_default_instance_;
class ValidateEventRequest;
struct ValidateEventRequestDefaultTypeInternal;
extern ValidateEventRequestDefaultTypeInternal _ValidateEventRequest_default_instance_;
class ValidateEventResponse;
struct ValidateEventResponseDefaultTypeInternal;
extern ValidateEventResponseDefaultTypeInternal _ValidateEventResponse_default_instance_;
}  // namespace audio
}  // namespace v1
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::v1::audio::AudioConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(Arena*);
template<> ::sensory::api::v1::audio::AudioModel* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AudioModel>(Arena*);
template<> ::sensory::api::v1::audio::AuthenticateConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AuthenticateConfig>(Arena*);
template<> ::sensory::api::v1::audio::AuthenticateRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AuthenticateRequest>(Arena*);
template<> ::sensory::api::v1::audio::AuthenticateResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AuthenticateResponse>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrollmentConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrollmentConfig>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrollmentRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrollmentRequest>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrollmentResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrollmentResponse>(Arena*);
template<> ::sensory::api::v1::audio::GetModelsRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::GetModelsRequest>(Arena*);
template<> ::sensory::api::v1::audio::GetModelsResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::GetModelsResponse>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeConfig>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeRequest>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeResponse>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEventConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEventConfig>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEventRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEventRequest>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEventResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEventResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace v1 {
namespace audio {

enum AuthenticateConfig_ThresholdSecurity : int {
  AuthenticateConfig_ThresholdSecurity_HIGH = 0,
  AuthenticateConfig_ThresholdSecurity_LOW = 1,
  AuthenticateConfig_ThresholdSecurity_AuthenticateConfig_ThresholdSecurity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AuthenticateConfig_ThresholdSecurity_AuthenticateConfig_ThresholdSecurity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AuthenticateConfig_ThresholdSecurity_IsValid(int value);
constexpr AuthenticateConfig_ThresholdSecurity AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MIN = AuthenticateConfig_ThresholdSecurity_HIGH;
constexpr AuthenticateConfig_ThresholdSecurity AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MAX = AuthenticateConfig_ThresholdSecurity_LOW;
constexpr int AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_ARRAYSIZE = AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AuthenticateConfig_ThresholdSecurity_descriptor();
template<typename T>
inline const std::string& AuthenticateConfig_ThresholdSecurity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuthenticateConfig_ThresholdSecurity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuthenticateConfig_ThresholdSecurity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AuthenticateConfig_ThresholdSecurity_descriptor(), enum_t_value);
}
inline bool AuthenticateConfig_ThresholdSecurity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AuthenticateConfig_ThresholdSecurity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AuthenticateConfig_ThresholdSecurity>(
    AuthenticateConfig_ThresholdSecurity_descriptor(), name, value);
}
enum AudioConfig_AudioEncoding : int {
  AudioConfig_AudioEncoding_LINEAR16 = 0,
  AudioConfig_AudioEncoding_FLAC = 1,
  AudioConfig_AudioEncoding_MULAW = 2,
  AudioConfig_AudioEncoding_AudioConfig_AudioEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioConfig_AudioEncoding_AudioConfig_AudioEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioConfig_AudioEncoding_IsValid(int value);
constexpr AudioConfig_AudioEncoding AudioConfig_AudioEncoding_AudioEncoding_MIN = AudioConfig_AudioEncoding_LINEAR16;
constexpr AudioConfig_AudioEncoding AudioConfig_AudioEncoding_AudioEncoding_MAX = AudioConfig_AudioEncoding_MULAW;
constexpr int AudioConfig_AudioEncoding_AudioEncoding_ARRAYSIZE = AudioConfig_AudioEncoding_AudioEncoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioConfig_AudioEncoding_descriptor();
template<typename T>
inline const std::string& AudioConfig_AudioEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioConfig_AudioEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioConfig_AudioEncoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioConfig_AudioEncoding_descriptor(), enum_t_value);
}
inline bool AudioConfig_AudioEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioConfig_AudioEncoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioConfig_AudioEncoding>(
    AudioConfig_AudioEncoding_descriptor(), name, value);
}
enum ThresholdSensitivity : int {
  LOWEST = 0,
  LOW = 1,
  MEDIUM = 2,
  HIGH = 3,
  HIGHEST = 4,
  ThresholdSensitivity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ThresholdSensitivity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ThresholdSensitivity_IsValid(int value);
constexpr ThresholdSensitivity ThresholdSensitivity_MIN = LOWEST;
constexpr ThresholdSensitivity ThresholdSensitivity_MAX = HIGHEST;
constexpr int ThresholdSensitivity_ARRAYSIZE = ThresholdSensitivity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThresholdSensitivity_descriptor();
template<typename T>
inline const std::string& ThresholdSensitivity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThresholdSensitivity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThresholdSensitivity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThresholdSensitivity_descriptor(), enum_t_value);
}
inline bool ThresholdSensitivity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThresholdSensitivity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThresholdSensitivity>(
    ThresholdSensitivity_descriptor(), name, value);
}
// ===================================================================

class GetModelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.GetModelsRequest) */ {
 public:
  inline GetModelsRequest() : GetModelsRequest(nullptr) {}
  ~GetModelsRequest() override;
  explicit constexpr GetModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsRequest(const GetModelsRequest& from);
  GetModelsRequest(GetModelsRequest&& from) noexcept
    : GetModelsRequest() {
    *this = ::std::move(from);
  }

  inline GetModelsRequest& operator=(const GetModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsRequest& operator=(GetModelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsRequest* internal_default_instance() {
    return reinterpret_cast<const GetModelsRequest*>(
               &_GetModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetModelsRequest& a, GetModelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsRequest* New() const final {
    return new GetModelsRequest();
  }

  GetModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModelsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.GetModelsRequest";
  }
  protected:
  explicit GetModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.GetModelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AudioModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AudioModel) */ {
 public:
  inline AudioModel() : AudioModel(nullptr) {}
  ~AudioModel() override;
  explicit constexpr AudioModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioModel(const AudioModel& from);
  AudioModel(AudioModel&& from) noexcept
    : AudioModel() {
    *this = ::std::move(from);
  }

  inline AudioModel& operator=(const AudioModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioModel& operator=(AudioModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioModel* internal_default_instance() {
    return reinterpret_cast<const AudioModel*>(
               &_AudioModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AudioModel& a, AudioModel& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioModel* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioModel* New() const final {
    return new AudioModel();
  }

  AudioModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioModel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AudioModel";
  }
  protected:
  explicit AudioModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 6,
    kNameFieldNumber = 1,
    kFixedPhraseFieldNumber = 4,
    kModelTypeFieldNumber = 3,
    kSampleRateFieldNumber = 5,
    kIsEnrollableFieldNumber = 2,
    kIsLivenessSupportedFieldNumber = 8,
    kTechnologyFieldNumber = 7,
  };
  // repeated string versions = 6;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fixedPhrase = 4;
  void clear_fixedphrase();
  const std::string& fixedphrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fixedphrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fixedphrase();
  PROTOBUF_MUST_USE_RESULT std::string* release_fixedphrase();
  void set_allocated_fixedphrase(std::string* fixedphrase);
  private:
  const std::string& _internal_fixedphrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixedphrase(const std::string& value);
  std::string* _internal_mutable_fixedphrase();
  public:

  // .sensory.api.common.ModelType modelType = 3;
  void clear_modeltype();
  ::sensory::api::common::ModelType modeltype() const;
  void set_modeltype(::sensory::api::common::ModelType value);
  private:
  ::sensory::api::common::ModelType _internal_modeltype() const;
  void _internal_set_modeltype(::sensory::api::common::ModelType value);
  public:

  // int32 sampleRate = 5;
  void clear_samplerate();
  ::PROTOBUF_NAMESPACE_ID::int32 samplerate() const;
  void set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_samplerate() const;
  void _internal_set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isEnrollable = 2;
  void clear_isenrollable();
  bool isenrollable() const;
  void set_isenrollable(bool value);
  private:
  bool _internal_isenrollable() const;
  void _internal_set_isenrollable(bool value);
  public:

  // bool isLivenessSupported = 8;
  void clear_islivenesssupported();
  bool islivenesssupported() const;
  void set_islivenesssupported(bool value);
  private:
  bool _internal_islivenesssupported() const;
  void _internal_set_islivenesssupported(bool value);
  public:

  // .sensory.api.common.TechnologyType technology = 7;
  void clear_technology();
  ::sensory::api::common::TechnologyType technology() const;
  void set_technology(::sensory::api::common::TechnologyType value);
  private:
  ::sensory::api::common::TechnologyType _internal_technology() const;
  void _internal_set_technology(::sensory::api::common::TechnologyType value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AudioModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixedphrase_;
  int modeltype_;
  ::PROTOBUF_NAMESPACE_ID::int32 samplerate_;
  bool isenrollable_;
  bool islivenesssupported_;
  int technology_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class GetModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.GetModelsResponse) */ {
 public:
  inline GetModelsResponse() : GetModelsResponse(nullptr) {}
  ~GetModelsResponse() override;
  explicit constexpr GetModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsResponse(const GetModelsResponse& from);
  GetModelsResponse(GetModelsResponse&& from) noexcept
    : GetModelsResponse() {
    *this = ::std::move(from);
  }

  inline GetModelsResponse& operator=(const GetModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsResponse& operator=(GetModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsResponse* internal_default_instance() {
    return reinterpret_cast<const GetModelsResponse*>(
               &_GetModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetModelsResponse& a, GetModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsResponse* New() const final {
    return new GetModelsResponse();
  }

  GetModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModelsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.GetModelsResponse";
  }
  protected:
  explicit GetModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
  };
  // repeated .sensory.api.v1.audio.AudioModel models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::sensory::api::v1::audio::AudioModel* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >*
      mutable_models();
  private:
  const ::sensory::api::v1::audio::AudioModel& _internal_models(int index) const;
  ::sensory::api::v1::audio::AudioModel* _internal_add_models();
  public:
  const ::sensory::api::v1::audio::AudioModel& models(int index) const;
  ::sensory::api::v1::audio::AudioModel* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >&
      models() const;

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.GetModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel > models_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrollmentRequest) */ {
 public:
  inline CreateEnrollmentRequest() : CreateEnrollmentRequest(nullptr) {}
  ~CreateEnrollmentRequest() override;
  explicit constexpr CreateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentRequest(const CreateEnrollmentRequest& from);
  CreateEnrollmentRequest(CreateEnrollmentRequest&& from) noexcept
    : CreateEnrollmentRequest() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentRequest& operator=(const CreateEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentRequest& operator=(CreateEnrollmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const CreateEnrollmentRequest* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentRequest*>(
               &_CreateEnrollmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateEnrollmentRequest& a, CreateEnrollmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentRequest* New() const final {
    return new CreateEnrollmentRequest();
  }

  CreateEnrollmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrollmentRequest";
  }
  protected:
  explicit CreateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.CreateEnrollmentConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::CreateEnrollmentConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::CreateEnrollmentConfig* release_config();
  ::sensory::api::v1::audio::CreateEnrollmentConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::CreateEnrollmentConfig* config);
  private:
  const ::sensory::api::v1::audio::CreateEnrollmentConfig& _internal_config() const;
  ::sensory::api::v1::audio::CreateEnrollmentConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::CreateEnrollmentConfig* config);
  ::sensory::api::v1::audio::CreateEnrollmentConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrollmentRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::CreateEnrollmentConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AuthenticateRequest) */ {
 public:
  inline AuthenticateRequest() : AuthenticateRequest(nullptr) {}
  ~AuthenticateRequest() override;
  explicit constexpr AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateRequest(const AuthenticateRequest& from);
  AuthenticateRequest(AuthenticateRequest&& from) noexcept
    : AuthenticateRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateRequest& operator=(const AuthenticateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateRequest& operator=(AuthenticateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const AuthenticateRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateRequest*>(
               &_AuthenticateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AuthenticateRequest& a, AuthenticateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateRequest* New() const final {
    return new AuthenticateRequest();
  }

  AuthenticateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AuthenticateRequest";
  }
  protected:
  explicit AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.AuthenticateConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::AuthenticateConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AuthenticateConfig* release_config();
  ::sensory::api::v1::audio::AuthenticateConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::AuthenticateConfig* config);
  private:
  const ::sensory::api::v1::audio::AuthenticateConfig& _internal_config() const;
  ::sensory::api::v1::audio::AuthenticateConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::AuthenticateConfig* config);
  ::sensory::api::v1::audio::AuthenticateConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AuthenticateRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::AuthenticateConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEventRequest) */ {
 public:
  inline ValidateEventRequest() : ValidateEventRequest(nullptr) {}
  ~ValidateEventRequest() override;
  explicit constexpr ValidateEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEventRequest(const ValidateEventRequest& from);
  ValidateEventRequest(ValidateEventRequest&& from) noexcept
    : ValidateEventRequest() {
    *this = ::std::move(from);
  }

  inline ValidateEventRequest& operator=(const ValidateEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEventRequest& operator=(ValidateEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEventRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const ValidateEventRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateEventRequest*>(
               &_ValidateEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValidateEventRequest& a, ValidateEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEventRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEventRequest* New() const final {
    return new ValidateEventRequest();
  }

  ValidateEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEventRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEventRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEventRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEventRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEventRequest";
  }
  protected:
  explicit ValidateEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.ValidateEventConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::ValidateEventConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::ValidateEventConfig* release_config();
  ::sensory::api::v1::audio::ValidateEventConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::ValidateEventConfig* config);
  private:
  const ::sensory::api::v1::audio::ValidateEventConfig& _internal_config() const;
  ::sensory::api::v1::audio::ValidateEventConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::ValidateEventConfig* config);
  ::sensory::api::v1::audio::ValidateEventConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEventRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::ValidateEventConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeRequest) */ {
 public:
  inline TranscribeRequest() : TranscribeRequest(nullptr) {}
  ~TranscribeRequest() override;
  explicit constexpr TranscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeRequest(const TranscribeRequest& from);
  TranscribeRequest(TranscribeRequest&& from) noexcept
    : TranscribeRequest() {
    *this = ::std::move(from);
  }

  inline TranscribeRequest& operator=(const TranscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeRequest& operator=(TranscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const TranscribeRequest* internal_default_instance() {
    return reinterpret_cast<const TranscribeRequest*>(
               &_TranscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TranscribeRequest& a, TranscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeRequest* New() const final {
    return new TranscribeRequest();
  }

  TranscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeRequest";
  }
  protected:
  explicit TranscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.TranscribeConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::TranscribeConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::TranscribeConfig* release_config();
  ::sensory::api::v1::audio::TranscribeConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::TranscribeConfig* config);
  private:
  const ::sensory::api::v1::audio::TranscribeConfig& _internal_config() const;
  ::sensory::api::v1::audio::TranscribeConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::TranscribeConfig* config);
  ::sensory::api::v1::audio::TranscribeConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::TranscribeConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrollmentResponse) */ {
 public:
  inline CreateEnrollmentResponse() : CreateEnrollmentResponse(nullptr) {}
  ~CreateEnrollmentResponse() override;
  explicit constexpr CreateEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentResponse(const CreateEnrollmentResponse& from);
  CreateEnrollmentResponse(CreateEnrollmentResponse&& from) noexcept
    : CreateEnrollmentResponse() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentResponse& operator=(const CreateEnrollmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentResponse& operator=(CreateEnrollmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateEnrollmentResponse* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentResponse*>(
               &_CreateEnrollmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateEnrollmentResponse& a, CreateEnrollmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentResponse* New() const final {
    return new CreateEnrollmentResponse();
  }

  CreateEnrollmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrollmentResponse";
  }
  protected:
  explicit CreateEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdFieldNumber = 3,
    kModelNameFieldNumber = 4,
    kModelVersionFieldNumber = 5,
    kModelPromptFieldNumber = 6,
    kPercentCompleteFieldNumber = 1,
    kPercentSegmentCompleteFieldNumber = 7,
    kAudioEnergyFieldNumber = 2,
  };
  // string enrollmentId = 3;
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string modelName = 4;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string modelVersion = 5;
  void clear_modelversion();
  const std::string& modelversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelversion();
  void set_allocated_modelversion(std::string* modelversion);
  private:
  const std::string& _internal_modelversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelversion(const std::string& value);
  std::string* _internal_mutable_modelversion();
  public:

  // string modelPrompt = 6;
  void clear_modelprompt();
  const std::string& modelprompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelprompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelprompt();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelprompt();
  void set_allocated_modelprompt(std::string* modelprompt);
  private:
  const std::string& _internal_modelprompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelprompt(const std::string& value);
  std::string* _internal_mutable_modelprompt();
  public:

  // int64 percentComplete = 1;
  void clear_percentcomplete();
  ::PROTOBUF_NAMESPACE_ID::int64 percentcomplete() const;
  void set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_percentcomplete() const;
  void _internal_set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 percentSegmentComplete = 7;
  void clear_percentsegmentcomplete();
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete() const;
  void set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_percentsegmentcomplete() const;
  void _internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float audioEnergy = 2;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrollmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelprompt_;
  ::PROTOBUF_NAMESPACE_ID::int64 percentcomplete_;
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete_;
  float audioenergy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AuthenticateResponse) */ {
 public:
  inline AuthenticateResponse() : AuthenticateResponse(nullptr) {}
  ~AuthenticateResponse() override;
  explicit constexpr AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateResponse(const AuthenticateResponse& from);
  AuthenticateResponse(AuthenticateResponse&& from) noexcept
    : AuthenticateResponse() {
    *this = ::std::move(from);
  }

  inline AuthenticateResponse& operator=(const AuthenticateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateResponse& operator=(AuthenticateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateResponse* internal_default_instance() {
    return reinterpret_cast<const AuthenticateResponse*>(
               &_AuthenticateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AuthenticateResponse& a, AuthenticateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateResponse* New() const final {
    return new AuthenticateResponse();
  }

  AuthenticateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AuthenticateResponse";
  }
  protected:
  explicit AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 4,
    kEnrollmentIdFieldNumber = 5,
    kModelPromptFieldNumber = 6,
    kTokenFieldNumber = 3,
    kAudioEnergyFieldNumber = 1,
    kSuccessFieldNumber = 2,
    kPercentSegmentCompleteFieldNumber = 7,
  };
  // string userId = 4;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string enrollmentId = 5;
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string modelPrompt = 6;
  void clear_modelprompt();
  const std::string& modelprompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelprompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelprompt();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelprompt();
  void set_allocated_modelprompt(std::string* modelprompt);
  private:
  const std::string& _internal_modelprompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelprompt(const std::string& value);
  std::string* _internal_mutable_modelprompt();
  public:

  // .sensory.api.common.TokenResponse token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::sensory::api::common::TokenResponse& token() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::TokenResponse* release_token();
  ::sensory::api::common::TokenResponse* mutable_token();
  void set_allocated_token(::sensory::api::common::TokenResponse* token);
  private:
  const ::sensory::api::common::TokenResponse& _internal_token() const;
  ::sensory::api::common::TokenResponse* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::sensory::api::common::TokenResponse* token);
  ::sensory::api::common::TokenResponse* unsafe_arena_release_token();

  // float audioEnergy = 1;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int64 percentSegmentComplete = 7;
  void clear_percentsegmentcomplete();
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete() const;
  void set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_percentsegmentcomplete() const;
  void _internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AuthenticateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelprompt_;
  ::sensory::api::common::TokenResponse* token_;
  float audioenergy_;
  bool success_;
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEventResponse) */ {
 public:
  inline ValidateEventResponse() : ValidateEventResponse(nullptr) {}
  ~ValidateEventResponse() override;
  explicit constexpr ValidateEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEventResponse(const ValidateEventResponse& from);
  ValidateEventResponse(ValidateEventResponse&& from) noexcept
    : ValidateEventResponse() {
    *this = ::std::move(from);
  }

  inline ValidateEventResponse& operator=(const ValidateEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEventResponse& operator=(ValidateEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateEventResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateEventResponse*>(
               &_ValidateEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ValidateEventResponse& a, ValidateEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEventResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEventResponse* New() const final {
    return new ValidateEventResponse();
  }

  ValidateEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEventResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEventResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEventResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEventResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEventResponse";
  }
  protected:
  explicit ValidateEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 3,
    kAudioEnergyFieldNumber = 1,
    kSuccessFieldNumber = 2,
    kScoreFieldNumber = 4,
  };
  // string resultId = 3;
  void clear_resultid();
  const std::string& resultid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resultid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resultid();
  PROTOBUF_MUST_USE_RESULT std::string* release_resultid();
  void set_allocated_resultid(std::string* resultid);
  private:
  const std::string& _internal_resultid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resultid(const std::string& value);
  std::string* _internal_mutable_resultid();
  public:

  // float audioEnergy = 1;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // float score = 4;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resultid_;
  float audioenergy_;
  bool success_;
  float score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeResponse) */ {
 public:
  inline TranscribeResponse() : TranscribeResponse(nullptr) {}
  ~TranscribeResponse() override;
  explicit constexpr TranscribeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeResponse(const TranscribeResponse& from);
  TranscribeResponse(TranscribeResponse&& from) noexcept
    : TranscribeResponse() {
    *this = ::std::move(from);
  }

  inline TranscribeResponse& operator=(const TranscribeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeResponse& operator=(TranscribeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscribeResponse* internal_default_instance() {
    return reinterpret_cast<const TranscribeResponse*>(
               &_TranscribeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TranscribeResponse& a, TranscribeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeResponse* New() const final {
    return new TranscribeResponse();
  }

  TranscribeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeResponse";
  }
  protected:
  explicit TranscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranscriptFieldNumber = 2,
    kAudioEnergyFieldNumber = 1,
    kIsPartialResultFieldNumber = 3,
  };
  // string transcript = 2;
  void clear_transcript();
  const std::string& transcript() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcript(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcript();
  PROTOBUF_MUST_USE_RESULT std::string* release_transcript();
  void set_allocated_transcript(std::string* transcript);
  private:
  const std::string& _internal_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcript(const std::string& value);
  std::string* _internal_mutable_transcript();
  public:

  // float audioEnergy = 1;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // bool isPartialResult = 3;
  void clear_ispartialresult();
  bool ispartialresult() const;
  void set_ispartialresult(bool value);
  private:
  bool _internal_ispartialresult() const;
  void _internal_set_ispartialresult(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcript_;
  float audioenergy_;
  bool ispartialresult_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrollmentConfig) */ {
 public:
  inline CreateEnrollmentConfig() : CreateEnrollmentConfig(nullptr) {}
  ~CreateEnrollmentConfig() override;
  explicit constexpr CreateEnrollmentConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentConfig(const CreateEnrollmentConfig& from);
  CreateEnrollmentConfig(CreateEnrollmentConfig&& from) noexcept
    : CreateEnrollmentConfig() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentConfig& operator=(const CreateEnrollmentConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentConfig& operator=(CreateEnrollmentConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentConfig& default_instance() {
    return *internal_default_instance();
  }
  enum EnrollLengthCase {
    kEnrollmentNumUtterances = 7,
    kEnrollmentDuration = 8,
    ENROLLLENGTH_NOT_SET = 0,
  };

  static inline const CreateEnrollmentConfig* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentConfig*>(
               &_CreateEnrollmentConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateEnrollmentConfig& a, CreateEnrollmentConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentConfig* New() const final {
    return new CreateEnrollmentConfig();
  }

  CreateEnrollmentConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrollmentConfig";
  }
  protected:
  explicit CreateEnrollmentConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kModelNameFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kAudioFieldNumber = 1,
    kIsLivenessEnabledFieldNumber = 6,
    kEnrollmentNumUtterancesFieldNumber = 7,
    kEnrollmentDurationFieldNumber = 8,
  };
  // string userId = 2 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceId = 3 [(.validate.rules) = {
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_MUST_USE_RESULT std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string modelName = 4 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string description = 5 [(.validate.rules) = {
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // bool isLivenessEnabled = 6;
  void clear_islivenessenabled();
  bool islivenessenabled() const;
  void set_islivenessenabled(bool value);
  private:
  bool _internal_islivenessenabled() const;
  void _internal_set_islivenessenabled(bool value);
  public:

  // uint32 enrollmentNumUtterances = 7 [(.validate.rules) = {
  bool has_enrollmentnumutterances() const;
  private:
  bool _internal_has_enrollmentnumutterances() const;
  public:
  void clear_enrollmentnumutterances();
  ::PROTOBUF_NAMESPACE_ID::uint32 enrollmentnumutterances() const;
  void set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_enrollmentnumutterances() const;
  void _internal_set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float enrollmentDuration = 8 [(.validate.rules) = {
  bool has_enrollmentduration() const;
  private:
  bool _internal_has_enrollmentduration() const;
  public:
  void clear_enrollmentduration();
  float enrollmentduration() const;
  void set_enrollmentduration(float value);
  private:
  float _internal_enrollmentduration() const;
  void _internal_set_enrollmentduration(float value);
  public:

  void clear_enrollLength();
  EnrollLengthCase enrollLength_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrollmentConfig)
 private:
  class _Internal;
  void set_has_enrollmentnumutterances();
  void set_has_enrollmentduration();

  inline bool has_enrollLength() const;
  inline void clear_has_enrollLength();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  bool islivenessenabled_;
  union EnrollLengthUnion {
    constexpr EnrollLengthUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 enrollmentnumutterances_;
    float enrollmentduration_;
  } enrollLength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AuthenticateConfig) */ {
 public:
  inline AuthenticateConfig() : AuthenticateConfig(nullptr) {}
  ~AuthenticateConfig() override;
  explicit constexpr AuthenticateConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateConfig(const AuthenticateConfig& from);
  AuthenticateConfig(AuthenticateConfig&& from) noexcept
    : AuthenticateConfig() {
    *this = ::std::move(from);
  }

  inline AuthenticateConfig& operator=(const AuthenticateConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateConfig& operator=(AuthenticateConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateConfig& default_instance() {
    return *internal_default_instance();
  }
  enum AuthIdCase {
    kEnrollmentId = 2,
    kEnrollmentGroupId = 3,
    AUTHID_NOT_SET = 0,
  };

  static inline const AuthenticateConfig* internal_default_instance() {
    return reinterpret_cast<const AuthenticateConfig*>(
               &_AuthenticateConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AuthenticateConfig& a, AuthenticateConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateConfig* New() const final {
    return new AuthenticateConfig();
  }

  AuthenticateConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AuthenticateConfig";
  }
  protected:
  explicit AuthenticateConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AuthenticateConfig_ThresholdSecurity ThresholdSecurity;
  static constexpr ThresholdSecurity HIGH =
    AuthenticateConfig_ThresholdSecurity_HIGH;
  static constexpr ThresholdSecurity LOW =
    AuthenticateConfig_ThresholdSecurity_LOW;
  static inline bool ThresholdSecurity_IsValid(int value) {
    return AuthenticateConfig_ThresholdSecurity_IsValid(value);
  }
  static constexpr ThresholdSecurity ThresholdSecurity_MIN =
    AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MIN;
  static constexpr ThresholdSecurity ThresholdSecurity_MAX =
    AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MAX;
  static constexpr int ThresholdSecurity_ARRAYSIZE =
    AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ThresholdSecurity_descriptor() {
    return AuthenticateConfig_ThresholdSecurity_descriptor();
  }
  template<typename T>
  static inline const std::string& ThresholdSecurity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ThresholdSecurity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ThresholdSecurity_Name.");
    return AuthenticateConfig_ThresholdSecurity_Name(enum_t_value);
  }
  static inline bool ThresholdSecurity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ThresholdSecurity* value) {
    return AuthenticateConfig_ThresholdSecurity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFieldNumber = 1,
    kSensitivityFieldNumber = 5,
    kDoIncludeTokenFieldNumber = 4,
    kIsLivenessEnabledFieldNumber = 7,
    kSecurityFieldNumber = 6,
    kEnrollmentIdFieldNumber = 2,
    kEnrollmentGroupIdFieldNumber = 3,
  };
  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 5 [(.validate.rules) = {
  void clear_sensitivity();
  ::sensory::api::v1::audio::ThresholdSensitivity sensitivity() const;
  void set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  private:
  ::sensory::api::v1::audio::ThresholdSensitivity _internal_sensitivity() const;
  void _internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  public:

  // bool doIncludeToken = 4;
  void clear_doincludetoken();
  bool doincludetoken() const;
  void set_doincludetoken(bool value);
  private:
  bool _internal_doincludetoken() const;
  void _internal_set_doincludetoken(bool value);
  public:

  // bool isLivenessEnabled = 7;
  void clear_islivenessenabled();
  bool islivenessenabled() const;
  void set_islivenessenabled(bool value);
  private:
  bool _internal_islivenessenabled() const;
  void _internal_set_islivenessenabled(bool value);
  public:

  // .sensory.api.v1.audio.AuthenticateConfig.ThresholdSecurity security = 6 [(.validate.rules) = {
  void clear_security();
  ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity security() const;
  void set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value);
  private:
  ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity _internal_security() const;
  void _internal_set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value);
  public:

  // string enrollmentId = 2 [(.validate.rules) = {
  bool has_enrollmentid() const;
  private:
  bool _internal_has_enrollmentid() const;
  public:
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string enrollmentGroupId = 3;
  bool has_enrollmentgroupid() const;
  private:
  bool _internal_has_enrollmentgroupid() const;
  public:
  void clear_enrollmentgroupid();
  const std::string& enrollmentgroupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentgroupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentgroupid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentgroupid();
  void set_allocated_enrollmentgroupid(std::string* enrollmentgroupid);
  private:
  const std::string& _internal_enrollmentgroupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentgroupid(const std::string& value);
  std::string* _internal_mutable_enrollmentgroupid();
  public:

  void clear_authId();
  AuthIdCase authId_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AuthenticateConfig)
 private:
  class _Internal;
  void set_has_enrollmentid();
  void set_has_enrollmentgroupid();

  inline bool has_authId() const;
  inline void clear_has_authId();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  int sensitivity_;
  bool doincludetoken_;
  bool islivenessenabled_;
  int security_;
  union AuthIdUnion {
    constexpr AuthIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentgroupid_;
  } authId_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEventConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEventConfig) */ {
 public:
  inline ValidateEventConfig() : ValidateEventConfig(nullptr) {}
  ~ValidateEventConfig() override;
  explicit constexpr ValidateEventConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEventConfig(const ValidateEventConfig& from);
  ValidateEventConfig(ValidateEventConfig&& from) noexcept
    : ValidateEventConfig() {
    *this = ::std::move(from);
  }

  inline ValidateEventConfig& operator=(const ValidateEventConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEventConfig& operator=(ValidateEventConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEventConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateEventConfig* internal_default_instance() {
    return reinterpret_cast<const ValidateEventConfig*>(
               &_ValidateEventConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ValidateEventConfig& a, ValidateEventConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEventConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEventConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEventConfig* New() const final {
    return new ValidateEventConfig();
  }

  ValidateEventConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEventConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEventConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEventConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEventConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEventConfig";
  }
  protected:
  explicit ValidateEventConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kAudioFieldNumber = 1,
    kSensitivityFieldNumber = 4,
  };
  // string modelName = 2 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string userId = 3 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 4 [(.validate.rules) = {
  void clear_sensitivity();
  ::sensory::api::v1::audio::ThresholdSensitivity sensitivity() const;
  void set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  private:
  ::sensory::api::v1::audio::ThresholdSensitivity _internal_sensitivity() const;
  void _internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEventConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  int sensitivity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeConfig) */ {
 public:
  inline TranscribeConfig() : TranscribeConfig(nullptr) {}
  ~TranscribeConfig() override;
  explicit constexpr TranscribeConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeConfig(const TranscribeConfig& from);
  TranscribeConfig(TranscribeConfig&& from) noexcept
    : TranscribeConfig() {
    *this = ::std::move(from);
  }

  inline TranscribeConfig& operator=(const TranscribeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeConfig& operator=(TranscribeConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscribeConfig* internal_default_instance() {
    return reinterpret_cast<const TranscribeConfig*>(
               &_TranscribeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TranscribeConfig& a, TranscribeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeConfig* New() const final {
    return new TranscribeConfig();
  }

  TranscribeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeConfig";
  }
  protected:
  explicit TranscribeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kAudioFieldNumber = 1,
  };
  // string modelName = 2 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string userId = 3 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  explicit constexpr AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioConfig* New() const final {
    return new AudioConfig();
  }

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AudioConfig_AudioEncoding AudioEncoding;
  static constexpr AudioEncoding LINEAR16 =
    AudioConfig_AudioEncoding_LINEAR16;
  static constexpr AudioEncoding FLAC =
    AudioConfig_AudioEncoding_FLAC;
  static constexpr AudioEncoding MULAW =
    AudioConfig_AudioEncoding_MULAW;
  static inline bool AudioEncoding_IsValid(int value) {
    return AudioConfig_AudioEncoding_IsValid(value);
  }
  static constexpr AudioEncoding AudioEncoding_MIN =
    AudioConfig_AudioEncoding_AudioEncoding_MIN;
  static constexpr AudioEncoding AudioEncoding_MAX =
    AudioConfig_AudioEncoding_AudioEncoding_MAX;
  static constexpr int AudioEncoding_ARRAYSIZE =
    AudioConfig_AudioEncoding_AudioEncoding_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AudioEncoding_descriptor() {
    return AudioConfig_AudioEncoding_descriptor();
  }
  template<typename T>
  static inline const std::string& AudioEncoding_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AudioEncoding>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AudioEncoding_Name.");
    return AudioConfig_AudioEncoding_Name(enum_t_value);
  }
  static inline bool AudioEncoding_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AudioEncoding* value) {
    return AudioConfig_AudioEncoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageCodeFieldNumber = 4,
    kEncodingFieldNumber = 1,
    kSampleRateHertzFieldNumber = 2,
    kAudioChannelCountFieldNumber = 3,
  };
  // string languageCode = 4;
  void clear_languagecode();
  const std::string& languagecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_languagecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_languagecode();
  PROTOBUF_MUST_USE_RESULT std::string* release_languagecode();
  void set_allocated_languagecode(std::string* languagecode);
  private:
  const std::string& _internal_languagecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_languagecode(const std::string& value);
  std::string* _internal_mutable_languagecode();
  public:

  // .sensory.api.v1.audio.AudioConfig.AudioEncoding encoding = 1 [(.validate.rules) = {
  void clear_encoding();
  ::sensory::api::v1::audio::AudioConfig_AudioEncoding encoding() const;
  void set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value);
  private:
  ::sensory::api::v1::audio::AudioConfig_AudioEncoding _internal_encoding() const;
  void _internal_set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value);
  public:

  // int32 sampleRateHertz = 2 [(.validate.rules) = {
  void clear_sampleratehertz();
  ::PROTOBUF_NAMESPACE_ID::int32 sampleratehertz() const;
  void set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sampleratehertz() const;
  void _internal_set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 audioChannelCount = 3 [(.validate.rules) = {
  void clear_audiochannelcount();
  ::PROTOBUF_NAMESPACE_ID::int32 audiochannelcount() const;
  void set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_audiochannelcount() const;
  void _internal_set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr languagecode_;
  int encoding_;
  ::PROTOBUF_NAMESPACE_ID::int32 sampleratehertz_;
  ::PROTOBUF_NAMESPACE_ID::int32 audiochannelcount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetModelsRequest

// -------------------------------------------------------------------

// AudioModel

// string name = 1;
inline void AudioModel::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AudioModel::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioModel::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.name)
}
inline std::string* AudioModel::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioModel.name)
  return _s;
}
inline const std::string& AudioModel::_internal_name() const {
  return name_.Get();
}
inline void AudioModel::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioModel::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioModel::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioModel.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioModel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioModel.name)
}

// bool isEnrollable = 2;
inline void AudioModel::clear_isenrollable() {
  isenrollable_ = false;
}
inline bool AudioModel::_internal_isenrollable() const {
  return isenrollable_;
}
inline bool AudioModel::isenrollable() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.isEnrollable)
  return _internal_isenrollable();
}
inline void AudioModel::_internal_set_isenrollable(bool value) {
  
  isenrollable_ = value;
}
inline void AudioModel::set_isenrollable(bool value) {
  _internal_set_isenrollable(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.isEnrollable)
}

// .sensory.api.common.ModelType modelType = 3;
inline void AudioModel::clear_modeltype() {
  modeltype_ = 0;
}
inline ::sensory::api::common::ModelType AudioModel::_internal_modeltype() const {
  return static_cast< ::sensory::api::common::ModelType >(modeltype_);
}
inline ::sensory::api::common::ModelType AudioModel::modeltype() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.modelType)
  return _internal_modeltype();
}
inline void AudioModel::_internal_set_modeltype(::sensory::api::common::ModelType value) {
  
  modeltype_ = value;
}
inline void AudioModel::set_modeltype(::sensory::api::common::ModelType value) {
  _internal_set_modeltype(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.modelType)
}

// string fixedPhrase = 4;
inline void AudioModel::clear_fixedphrase() {
  fixedphrase_.ClearToEmpty();
}
inline const std::string& AudioModel::fixedphrase() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.fixedPhrase)
  return _internal_fixedphrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioModel::set_fixedphrase(ArgT0&& arg0, ArgT... args) {
 
 fixedphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.fixedPhrase)
}
inline std::string* AudioModel::mutable_fixedphrase() {
  std::string* _s = _internal_mutable_fixedphrase();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioModel.fixedPhrase)
  return _s;
}
inline const std::string& AudioModel::_internal_fixedphrase() const {
  return fixedphrase_.Get();
}
inline void AudioModel::_internal_set_fixedphrase(const std::string& value) {
  
  fixedphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioModel::_internal_mutable_fixedphrase() {
  
  return fixedphrase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioModel::release_fixedphrase() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioModel.fixedPhrase)
  return fixedphrase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioModel::set_allocated_fixedphrase(std::string* fixedphrase) {
  if (fixedphrase != nullptr) {
    
  } else {
    
  }
  fixedphrase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fixedphrase,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioModel.fixedPhrase)
}

// int32 sampleRate = 5;
inline void AudioModel::clear_samplerate() {
  samplerate_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioModel::_internal_samplerate() const {
  return samplerate_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioModel::samplerate() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.sampleRate)
  return _internal_samplerate();
}
inline void AudioModel::_internal_set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  samplerate_ = value;
}
inline void AudioModel::set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_samplerate(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.sampleRate)
}

// repeated string versions = 6;
inline int AudioModel::_internal_versions_size() const {
  return versions_.size();
}
inline int AudioModel::versions_size() const {
  return _internal_versions_size();
}
inline void AudioModel::clear_versions() {
  versions_.Clear();
}
inline std::string* AudioModel::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:sensory.api.v1.audio.AudioModel.versions)
  return _s;
}
inline const std::string& AudioModel::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const std::string& AudioModel::versions(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.versions)
  return _internal_versions(index);
}
inline std::string* AudioModel::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioModel.versions)
  return versions_.Mutable(index);
}
inline void AudioModel::set_versions(int index, const std::string& value) {
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::set_versions(int index, std::string&& value) {
  versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::set_versions(int index, const char* value, size_t size) {
  versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensory.api.v1.audio.AudioModel.versions)
}
inline std::string* AudioModel::_internal_add_versions() {
  return versions_.Add();
}
inline void AudioModel::add_versions(const std::string& value) {
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::add_versions(std::string&& value) {
  versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::add_versions(const char* value, size_t size) {
  versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensory.api.v1.audio.AudioModel.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AudioModel::versions() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.audio.AudioModel.versions)
  return versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AudioModel::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.audio.AudioModel.versions)
  return &versions_;
}

// .sensory.api.common.TechnologyType technology = 7;
inline void AudioModel::clear_technology() {
  technology_ = 0;
}
inline ::sensory::api::common::TechnologyType AudioModel::_internal_technology() const {
  return static_cast< ::sensory::api::common::TechnologyType >(technology_);
}
inline ::sensory::api::common::TechnologyType AudioModel::technology() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.technology)
  return _internal_technology();
}
inline void AudioModel::_internal_set_technology(::sensory::api::common::TechnologyType value) {
  
  technology_ = value;
}
inline void AudioModel::set_technology(::sensory::api::common::TechnologyType value) {
  _internal_set_technology(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.technology)
}

// bool isLivenessSupported = 8;
inline void AudioModel::clear_islivenesssupported() {
  islivenesssupported_ = false;
}
inline bool AudioModel::_internal_islivenesssupported() const {
  return islivenesssupported_;
}
inline bool AudioModel::islivenesssupported() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.isLivenessSupported)
  return _internal_islivenesssupported();
}
inline void AudioModel::_internal_set_islivenesssupported(bool value) {
  
  islivenesssupported_ = value;
}
inline void AudioModel::set_islivenesssupported(bool value) {
  _internal_set_islivenesssupported(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.isLivenessSupported)
}

// -------------------------------------------------------------------

// GetModelsResponse

// repeated .sensory.api.v1.audio.AudioModel models = 1;
inline int GetModelsResponse::_internal_models_size() const {
  return models_.size();
}
inline int GetModelsResponse::models_size() const {
  return _internal_models_size();
}
inline void GetModelsResponse::clear_models() {
  models_.Clear();
}
inline ::sensory::api::v1::audio::AudioModel* GetModelsResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.GetModelsResponse.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >*
GetModelsResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.audio.GetModelsResponse.models)
  return &models_;
}
inline const ::sensory::api::v1::audio::AudioModel& GetModelsResponse::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::sensory::api::v1::audio::AudioModel& GetModelsResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.GetModelsResponse.models)
  return _internal_models(index);
}
inline ::sensory::api::v1::audio::AudioModel* GetModelsResponse::_internal_add_models() {
  return models_.Add();
}
inline ::sensory::api::v1::audio::AudioModel* GetModelsResponse::add_models() {
  ::sensory::api::v1::audio::AudioModel* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:sensory.api.v1.audio.GetModelsResponse.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >&
GetModelsResponse::models() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.audio.GetModelsResponse.models)
  return models_;
}

// -------------------------------------------------------------------

// CreateEnrollmentRequest

// .sensory.api.v1.audio.CreateEnrollmentConfig config = 1;
inline bool CreateEnrollmentRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool CreateEnrollmentRequest::has_config() const {
  return _internal_has_config();
}
inline void CreateEnrollmentRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void CreateEnrollmentRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::CreateEnrollmentConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::CreateEnrollmentConfig& CreateEnrollmentRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::CreateEnrollmentConfig&>(::sensory::api::v1::audio::_CreateEnrollmentConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::CreateEnrollmentConfig& CreateEnrollmentRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::CreateEnrollmentConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateEnrollmentRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::CreateEnrollmentConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.CreateEnrollmentRequest.config)
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::CreateEnrollmentConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::mutable_config() {
  ::sensory::api::v1::audio::CreateEnrollmentConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool CreateEnrollmentRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool CreateEnrollmentRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void CreateEnrollmentRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void CreateEnrollmentRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& CreateEnrollmentRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void CreateEnrollmentRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
}
inline std::string* CreateEnrollmentRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
  return _s;
}
inline const std::string& CreateEnrollmentRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateEnrollmentRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void CreateEnrollmentRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
}

inline bool CreateEnrollmentRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void CreateEnrollmentRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline CreateEnrollmentRequest::StreamingRequestCase CreateEnrollmentRequest::streamingRequest_case() const {
  return CreateEnrollmentRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateRequest

// .sensory.api.v1.audio.AuthenticateConfig config = 1;
inline bool AuthenticateRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool AuthenticateRequest::has_config() const {
  return _internal_has_config();
}
inline void AuthenticateRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void AuthenticateRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::AuthenticateConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::AuthenticateConfig& AuthenticateRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::AuthenticateConfig&>(::sensory::api::v1::audio::_AuthenticateConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AuthenticateConfig& AuthenticateRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.AuthenticateRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::AuthenticateConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthenticateRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::AuthenticateConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.AuthenticateRequest.config)
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::AuthenticateConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::mutable_config() {
  ::sensory::api::v1::audio::AuthenticateConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool AuthenticateRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool AuthenticateRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void AuthenticateRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void AuthenticateRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& AuthenticateRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateRequest.audioContent)
}
inline std::string* AuthenticateRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateRequest.audioContent)
  return _s;
}
inline const std::string& AuthenticateRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void AuthenticateRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateRequest.audioContent)
}

inline bool AuthenticateRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void AuthenticateRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline AuthenticateRequest::StreamingRequestCase AuthenticateRequest::streamingRequest_case() const {
  return AuthenticateRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidateEventRequest

// .sensory.api.v1.audio.ValidateEventConfig config = 1;
inline bool ValidateEventRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool ValidateEventRequest::has_config() const {
  return _internal_has_config();
}
inline void ValidateEventRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void ValidateEventRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::ValidateEventConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::ValidateEventConfig& ValidateEventRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::ValidateEventConfig&>(::sensory::api::v1::audio::_ValidateEventConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::ValidateEventConfig& ValidateEventRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.ValidateEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::ValidateEventConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValidateEventRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::ValidateEventConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEventRequest.config)
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::ValidateEventConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::mutable_config() {
  ::sensory::api::v1::audio::ValidateEventConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool ValidateEventRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool ValidateEventRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void ValidateEventRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void ValidateEventRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& ValidateEventRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void ValidateEventRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventRequest.audioContent)
}
inline std::string* ValidateEventRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventRequest.audioContent)
  return _s;
}
inline const std::string& ValidateEventRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValidateEventRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ValidateEventRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventRequest.audioContent)
}

inline bool ValidateEventRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void ValidateEventRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline ValidateEventRequest::StreamingRequestCase ValidateEventRequest::streamingRequest_case() const {
  return ValidateEventRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TranscribeRequest

// .sensory.api.v1.audio.TranscribeConfig config = 1;
inline bool TranscribeRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool TranscribeRequest::has_config() const {
  return _internal_has_config();
}
inline void TranscribeRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void TranscribeRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::TranscribeConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::TranscribeConfig& TranscribeRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::TranscribeConfig&>(::sensory::api::v1::audio::_TranscribeConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::TranscribeConfig& TranscribeRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.TranscribeRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::TranscribeConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TranscribeRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::TranscribeConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.TranscribeRequest.config)
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::TranscribeConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::mutable_config() {
  ::sensory::api::v1::audio::TranscribeConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool TranscribeRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool TranscribeRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void TranscribeRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void TranscribeRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& TranscribeRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void TranscribeRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeRequest.audioContent)
}
inline std::string* TranscribeRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeRequest.audioContent)
  return _s;
}
inline const std::string& TranscribeRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TranscribeRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TranscribeRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeRequest.audioContent)
}

inline bool TranscribeRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void TranscribeRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline TranscribeRequest::StreamingRequestCase TranscribeRequest::streamingRequest_case() const {
  return TranscribeRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateEnrollmentResponse

// int64 percentComplete = 1;
inline void CreateEnrollmentResponse::clear_percentcomplete() {
  percentcomplete_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::_internal_percentcomplete() const {
  return percentcomplete_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::percentcomplete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.percentComplete)
  return _internal_percentcomplete();
}
inline void CreateEnrollmentResponse::_internal_set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  percentcomplete_ = value;
}
inline void CreateEnrollmentResponse::set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_percentcomplete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.percentComplete)
}

// float audioEnergy = 2;
inline void CreateEnrollmentResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float CreateEnrollmentResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float CreateEnrollmentResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void CreateEnrollmentResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void CreateEnrollmentResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.audioEnergy)
}

// string enrollmentId = 3;
inline void CreateEnrollmentResponse::clear_enrollmentid() {
  enrollmentid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
 
 enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
}
inline std::string* CreateEnrollmentResponse::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_enrollmentid() const {
  return enrollmentid_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_enrollmentid(const std::string& value) {
  
  enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_enrollmentid() {
  
  return enrollmentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
  return enrollmentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (enrollmentid != nullptr) {
    
  } else {
    
  }
  enrollmentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
}

// string modelName = 4;
inline void CreateEnrollmentResponse::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
}
inline std::string* CreateEnrollmentResponse::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
}

// string modelVersion = 5;
inline void CreateEnrollmentResponse::clear_modelversion() {
  modelversion_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelversion() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
  return _internal_modelversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelversion(ArgT0&& arg0, ArgT... args) {
 
 modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
}
inline std::string* CreateEnrollmentResponse::mutable_modelversion() {
  std::string* _s = _internal_mutable_modelversion();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelversion() const {
  return modelversion_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelversion(const std::string& value) {
  
  modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelversion() {
  
  return modelversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelversion() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
  return modelversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelversion(std::string* modelversion) {
  if (modelversion != nullptr) {
    
  } else {
    
  }
  modelversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
}

// string modelPrompt = 6;
inline void CreateEnrollmentResponse::clear_modelprompt() {
  modelprompt_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelprompt() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
  return _internal_modelprompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelprompt(ArgT0&& arg0, ArgT... args) {
 
 modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
}
inline std::string* CreateEnrollmentResponse::mutable_modelprompt() {
  std::string* _s = _internal_mutable_modelprompt();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelprompt() const {
  return modelprompt_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelprompt(const std::string& value) {
  
  modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelprompt() {
  
  return modelprompt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelprompt() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
  return modelprompt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelprompt(std::string* modelprompt) {
  if (modelprompt != nullptr) {
    
  } else {
    
  }
  modelprompt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelprompt,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
}

// int64 percentSegmentComplete = 7;
inline void CreateEnrollmentResponse::clear_percentsegmentcomplete() {
  percentsegmentcomplete_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::_internal_percentsegmentcomplete() const {
  return percentsegmentcomplete_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::percentsegmentcomplete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.percentSegmentComplete)
  return _internal_percentsegmentcomplete();
}
inline void CreateEnrollmentResponse::_internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  percentsegmentcomplete_ = value;
}
inline void CreateEnrollmentResponse::set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_percentsegmentcomplete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.percentSegmentComplete)
}

// -------------------------------------------------------------------

// AuthenticateResponse

// float audioEnergy = 1;
inline void AuthenticateResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float AuthenticateResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float AuthenticateResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void AuthenticateResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void AuthenticateResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.audioEnergy)
}

// bool success = 2;
inline void AuthenticateResponse::clear_success() {
  success_ = false;
}
inline bool AuthenticateResponse::_internal_success() const {
  return success_;
}
inline bool AuthenticateResponse::success() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.success)
  return _internal_success();
}
inline void AuthenticateResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AuthenticateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.success)
}

// .sensory.api.common.TokenResponse token = 3;
inline bool AuthenticateResponse::_internal_has_token() const {
  return this != internal_default_instance() && token_ != nullptr;
}
inline bool AuthenticateResponse::has_token() const {
  return _internal_has_token();
}
inline const ::sensory::api::common::TokenResponse& AuthenticateResponse::_internal_token() const {
  const ::sensory::api::common::TokenResponse* p = token_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::TokenResponse&>(
      ::sensory::api::common::_TokenResponse_default_instance_);
}
inline const ::sensory::api::common::TokenResponse& AuthenticateResponse::token() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.token)
  return _internal_token();
}
inline void AuthenticateResponse::unsafe_arena_set_allocated_token(
    ::sensory::api::common::TokenResponse* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  token_ = token;
  if (token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.AuthenticateResponse.token)
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::release_token() {
  
  ::sensory::api::common::TokenResponse* temp = token_;
  token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.token)
  
  ::sensory::api::common::TokenResponse* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::_internal_mutable_token() {
  
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::TokenResponse>(GetArenaForAllocation());
    token_ = p;
  }
  return token_;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::mutable_token() {
  ::sensory::api::common::TokenResponse* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.token)
  return _msg;
}
inline void AuthenticateResponse::set_allocated_token(::sensory::api::common::TokenResponse* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token));
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.token)
}

// string userId = 4;
inline void AuthenticateResponse::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& AuthenticateResponse::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.userId)
}
inline std::string* AuthenticateResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.userId)
  return _s;
}
inline const std::string& AuthenticateResponse::_internal_userid() const {
  return userid_.Get();
}
inline void AuthenticateResponse::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.userId)
}

// string enrollmentId = 5;
inline void AuthenticateResponse::clear_enrollmentid() {
  enrollmentid_.ClearToEmpty();
}
inline const std::string& AuthenticateResponse::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateResponse::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
 
 enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
}
inline std::string* AuthenticateResponse::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
  return _s;
}
inline const std::string& AuthenticateResponse::_internal_enrollmentid() const {
  return enrollmentid_.Get();
}
inline void AuthenticateResponse::_internal_set_enrollmentid(const std::string& value) {
  
  enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::_internal_mutable_enrollmentid() {
  
  return enrollmentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
  return enrollmentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateResponse::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (enrollmentid != nullptr) {
    
  } else {
    
  }
  enrollmentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
}

// string modelPrompt = 6;
inline void AuthenticateResponse::clear_modelprompt() {
  modelprompt_.ClearToEmpty();
}
inline const std::string& AuthenticateResponse::modelprompt() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
  return _internal_modelprompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateResponse::set_modelprompt(ArgT0&& arg0, ArgT... args) {
 
 modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
}
inline std::string* AuthenticateResponse::mutable_modelprompt() {
  std::string* _s = _internal_mutable_modelprompt();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
  return _s;
}
inline const std::string& AuthenticateResponse::_internal_modelprompt() const {
  return modelprompt_.Get();
}
inline void AuthenticateResponse::_internal_set_modelprompt(const std::string& value) {
  
  modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::_internal_mutable_modelprompt() {
  
  return modelprompt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::release_modelprompt() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
  return modelprompt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateResponse::set_allocated_modelprompt(std::string* modelprompt) {
  if (modelprompt != nullptr) {
    
  } else {
    
  }
  modelprompt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelprompt,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
}

// int64 percentSegmentComplete = 7;
inline void AuthenticateResponse::clear_percentsegmentcomplete() {
  percentsegmentcomplete_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuthenticateResponse::_internal_percentsegmentcomplete() const {
  return percentsegmentcomplete_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuthenticateResponse::percentsegmentcomplete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.percentSegmentComplete)
  return _internal_percentsegmentcomplete();
}
inline void AuthenticateResponse::_internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  percentsegmentcomplete_ = value;
}
inline void AuthenticateResponse::set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_percentsegmentcomplete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.percentSegmentComplete)
}

// -------------------------------------------------------------------

// ValidateEventResponse

// float audioEnergy = 1;
inline void ValidateEventResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float ValidateEventResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float ValidateEventResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void ValidateEventResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void ValidateEventResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.audioEnergy)
}

// bool success = 2;
inline void ValidateEventResponse::clear_success() {
  success_ = false;
}
inline bool ValidateEventResponse::_internal_success() const {
  return success_;
}
inline bool ValidateEventResponse::success() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.success)
  return _internal_success();
}
inline void ValidateEventResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ValidateEventResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.success)
}

// string resultId = 3;
inline void ValidateEventResponse::clear_resultid() {
  resultid_.ClearToEmpty();
}
inline const std::string& ValidateEventResponse::resultid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.resultId)
  return _internal_resultid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEventResponse::set_resultid(ArgT0&& arg0, ArgT... args) {
 
 resultid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.resultId)
}
inline std::string* ValidateEventResponse::mutable_resultid() {
  std::string* _s = _internal_mutable_resultid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventResponse.resultId)
  return _s;
}
inline const std::string& ValidateEventResponse::_internal_resultid() const {
  return resultid_.Get();
}
inline void ValidateEventResponse::_internal_set_resultid(const std::string& value) {
  
  resultid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventResponse::_internal_mutable_resultid() {
  
  return resultid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventResponse::release_resultid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventResponse.resultId)
  return resultid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEventResponse::set_allocated_resultid(std::string* resultid) {
  if (resultid != nullptr) {
    
  } else {
    
  }
  resultid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resultid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventResponse.resultId)
}

// float score = 4;
inline void ValidateEventResponse::clear_score() {
  score_ = 0;
}
inline float ValidateEventResponse::_internal_score() const {
  return score_;
}
inline float ValidateEventResponse::score() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.score)
  return _internal_score();
}
inline void ValidateEventResponse::_internal_set_score(float value) {
  
  score_ = value;
}
inline void ValidateEventResponse::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.score)
}

// -------------------------------------------------------------------

// TranscribeResponse

// float audioEnergy = 1;
inline void TranscribeResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float TranscribeResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float TranscribeResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void TranscribeResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void TranscribeResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeResponse.audioEnergy)
}

// string transcript = 2;
inline void TranscribeResponse::clear_transcript() {
  transcript_.ClearToEmpty();
}
inline const std::string& TranscribeResponse::transcript() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.transcript)
  return _internal_transcript();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscribeResponse::set_transcript(ArgT0&& arg0, ArgT... args) {
 
 transcript_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeResponse.transcript)
}
inline std::string* TranscribeResponse::mutable_transcript() {
  std::string* _s = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeResponse.transcript)
  return _s;
}
inline const std::string& TranscribeResponse::_internal_transcript() const {
  return transcript_.Get();
}
inline void TranscribeResponse::_internal_set_transcript(const std::string& value) {
  
  transcript_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeResponse::_internal_mutable_transcript() {
  
  return transcript_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeResponse::release_transcript() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeResponse.transcript)
  return transcript_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranscribeResponse::set_allocated_transcript(std::string* transcript) {
  if (transcript != nullptr) {
    
  } else {
    
  }
  transcript_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transcript,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeResponse.transcript)
}

// bool isPartialResult = 3;
inline void TranscribeResponse::clear_ispartialresult() {
  ispartialresult_ = false;
}
inline bool TranscribeResponse::_internal_ispartialresult() const {
  return ispartialresult_;
}
inline bool TranscribeResponse::ispartialresult() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.isPartialResult)
  return _internal_ispartialresult();
}
inline void TranscribeResponse::_internal_set_ispartialresult(bool value) {
  
  ispartialresult_ = value;
}
inline void TranscribeResponse::set_ispartialresult(bool value) {
  _internal_set_ispartialresult(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeResponse.isPartialResult)
}

// -------------------------------------------------------------------

// CreateEnrollmentConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool CreateEnrollmentConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool CreateEnrollmentConfig::has_audio() const {
  return _internal_has_audio();
}
inline void CreateEnrollmentConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& CreateEnrollmentConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& CreateEnrollmentConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
  return _internal_audio();
}
inline void CreateEnrollmentConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
  return _msg;
}
inline void CreateEnrollmentConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
}

// string userId = 2 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
}
inline std::string* CreateEnrollmentConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_userid() const {
  return userid_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
}

// string deviceId = 3 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::deviceid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
}
inline std::string* CreateEnrollmentConfig::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_deviceid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
}

// string modelName = 4 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
}
inline std::string* CreateEnrollmentConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
}

// string description = 5 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.description)
}
inline std::string* CreateEnrollmentConfig::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.description)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_description() const {
  return description_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.description)
}

// bool isLivenessEnabled = 6;
inline void CreateEnrollmentConfig::clear_islivenessenabled() {
  islivenessenabled_ = false;
}
inline bool CreateEnrollmentConfig::_internal_islivenessenabled() const {
  return islivenessenabled_;
}
inline bool CreateEnrollmentConfig::islivenessenabled() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.isLivenessEnabled)
  return _internal_islivenessenabled();
}
inline void CreateEnrollmentConfig::_internal_set_islivenessenabled(bool value) {
  
  islivenessenabled_ = value;
}
inline void CreateEnrollmentConfig::set_islivenessenabled(bool value) {
  _internal_set_islivenessenabled(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.isLivenessEnabled)
}

// uint32 enrollmentNumUtterances = 7 [(.validate.rules) = {
inline bool CreateEnrollmentConfig::_internal_has_enrollmentnumutterances() const {
  return enrollLength_case() == kEnrollmentNumUtterances;
}
inline bool CreateEnrollmentConfig::has_enrollmentnumutterances() const {
  return _internal_has_enrollmentnumutterances();
}
inline void CreateEnrollmentConfig::set_has_enrollmentnumutterances() {
  _oneof_case_[0] = kEnrollmentNumUtterances;
}
inline void CreateEnrollmentConfig::clear_enrollmentnumutterances() {
  if (_internal_has_enrollmentnumutterances()) {
    enrollLength_.enrollmentnumutterances_ = 0u;
    clear_has_enrollLength();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateEnrollmentConfig::_internal_enrollmentnumutterances() const {
  if (_internal_has_enrollmentnumutterances()) {
    return enrollLength_.enrollmentnumutterances_;
  }
  return 0u;
}
inline void CreateEnrollmentConfig::_internal_set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_enrollmentnumutterances()) {
    clear_enrollLength();
    set_has_enrollmentnumutterances();
  }
  enrollLength_.enrollmentnumutterances_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateEnrollmentConfig::enrollmentnumutterances() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentNumUtterances)
  return _internal_enrollmentnumutterances();
}
inline void CreateEnrollmentConfig::set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_enrollmentnumutterances(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentNumUtterances)
}

// float enrollmentDuration = 8 [(.validate.rules) = {
inline bool CreateEnrollmentConfig::_internal_has_enrollmentduration() const {
  return enrollLength_case() == kEnrollmentDuration;
}
inline bool CreateEnrollmentConfig::has_enrollmentduration() const {
  return _internal_has_enrollmentduration();
}
inline void CreateEnrollmentConfig::set_has_enrollmentduration() {
  _oneof_case_[0] = kEnrollmentDuration;
}
inline void CreateEnrollmentConfig::clear_enrollmentduration() {
  if (_internal_has_enrollmentduration()) {
    enrollLength_.enrollmentduration_ = 0;
    clear_has_enrollLength();
  }
}
inline float CreateEnrollmentConfig::_internal_enrollmentduration() const {
  if (_internal_has_enrollmentduration()) {
    return enrollLength_.enrollmentduration_;
  }
  return 0;
}
inline void CreateEnrollmentConfig::_internal_set_enrollmentduration(float value) {
  if (!_internal_has_enrollmentduration()) {
    clear_enrollLength();
    set_has_enrollmentduration();
  }
  enrollLength_.enrollmentduration_ = value;
}
inline float CreateEnrollmentConfig::enrollmentduration() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentDuration)
  return _internal_enrollmentduration();
}
inline void CreateEnrollmentConfig::set_enrollmentduration(float value) {
  _internal_set_enrollmentduration(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentDuration)
}

inline bool CreateEnrollmentConfig::has_enrollLength() const {
  return enrollLength_case() != ENROLLLENGTH_NOT_SET;
}
inline void CreateEnrollmentConfig::clear_has_enrollLength() {
  _oneof_case_[0] = ENROLLLENGTH_NOT_SET;
}
inline CreateEnrollmentConfig::EnrollLengthCase CreateEnrollmentConfig::enrollLength_case() const {
  return CreateEnrollmentConfig::EnrollLengthCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool AuthenticateConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool AuthenticateConfig::has_audio() const {
  return _internal_has_audio();
}
inline void AuthenticateConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& AuthenticateConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& AuthenticateConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.audio)
  return _internal_audio();
}
inline void AuthenticateConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.AuthenticateConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateConfig.audio)
  return _msg;
}
inline void AuthenticateConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateConfig.audio)
}

// string enrollmentId = 2 [(.validate.rules) = {
inline bool AuthenticateConfig::_internal_has_enrollmentid() const {
  return authId_case() == kEnrollmentId;
}
inline bool AuthenticateConfig::has_enrollmentid() const {
  return _internal_has_enrollmentid();
}
inline void AuthenticateConfig::set_has_enrollmentid() {
  _oneof_case_[0] = kEnrollmentId;
}
inline void AuthenticateConfig::clear_enrollmentid() {
  if (_internal_has_enrollmentid()) {
    authId_.enrollmentid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_authId();
  }
}
inline const std::string& AuthenticateConfig::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateConfig::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
}
inline std::string* AuthenticateConfig::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
  return _s;
}
inline const std::string& AuthenticateConfig::_internal_enrollmentid() const {
  if (_internal_has_enrollmentid()) {
    return authId_.enrollmentid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateConfig::_internal_set_enrollmentid(const std::string& value) {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::_internal_mutable_enrollmentid() {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return authId_.enrollmentid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
  if (_internal_has_enrollmentid()) {
    clear_has_authId();
    return authId_.enrollmentid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void AuthenticateConfig::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (has_authId()) {
    clear_authId();
  }
  if (enrollmentid != nullptr) {
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(enrollmentid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(enrollmentid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
}

// string enrollmentGroupId = 3;
inline bool AuthenticateConfig::_internal_has_enrollmentgroupid() const {
  return authId_case() == kEnrollmentGroupId;
}
inline bool AuthenticateConfig::has_enrollmentgroupid() const {
  return _internal_has_enrollmentgroupid();
}
inline void AuthenticateConfig::set_has_enrollmentgroupid() {
  _oneof_case_[0] = kEnrollmentGroupId;
}
inline void AuthenticateConfig::clear_enrollmentgroupid() {
  if (_internal_has_enrollmentgroupid()) {
    authId_.enrollmentgroupid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_authId();
  }
}
inline const std::string& AuthenticateConfig::enrollmentgroupid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
  return _internal_enrollmentgroupid();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateConfig::set_enrollmentgroupid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentgroupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
}
inline std::string* AuthenticateConfig::mutable_enrollmentgroupid() {
  std::string* _s = _internal_mutable_enrollmentgroupid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
  return _s;
}
inline const std::string& AuthenticateConfig::_internal_enrollmentgroupid() const {
  if (_internal_has_enrollmentgroupid()) {
    return authId_.enrollmentgroupid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateConfig::_internal_set_enrollmentgroupid(const std::string& value) {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentgroupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::_internal_mutable_enrollmentgroupid() {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return authId_.enrollmentgroupid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::release_enrollmentgroupid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
  if (_internal_has_enrollmentgroupid()) {
    clear_has_authId();
    return authId_.enrollmentgroupid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void AuthenticateConfig::set_allocated_enrollmentgroupid(std::string* enrollmentgroupid) {
  if (has_authId()) {
    clear_authId();
  }
  if (enrollmentgroupid != nullptr) {
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(enrollmentgroupid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(enrollmentgroupid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
}

// bool doIncludeToken = 4;
inline void AuthenticateConfig::clear_doincludetoken() {
  doincludetoken_ = false;
}
inline bool AuthenticateConfig::_internal_doincludetoken() const {
  return doincludetoken_;
}
inline bool AuthenticateConfig::doincludetoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.doIncludeToken)
  return _internal_doincludetoken();
}
inline void AuthenticateConfig::_internal_set_doincludetoken(bool value) {
  
  doincludetoken_ = value;
}
inline void AuthenticateConfig::set_doincludetoken(bool value) {
  _internal_set_doincludetoken(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.doIncludeToken)
}

// .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 5 [(.validate.rules) = {
inline void AuthenticateConfig::clear_sensitivity() {
  sensitivity_ = 0;
}
inline ::sensory::api::v1::audio::ThresholdSensitivity AuthenticateConfig::_internal_sensitivity() const {
  return static_cast< ::sensory::api::v1::audio::ThresholdSensitivity >(sensitivity_);
}
inline ::sensory::api::v1::audio::ThresholdSensitivity AuthenticateConfig::sensitivity() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.sensitivity)
  return _internal_sensitivity();
}
inline void AuthenticateConfig::_internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  
  sensitivity_ = value;
}
inline void AuthenticateConfig::set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  _internal_set_sensitivity(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.sensitivity)
}

// .sensory.api.v1.audio.AuthenticateConfig.ThresholdSecurity security = 6 [(.validate.rules) = {
inline void AuthenticateConfig::clear_security() {
  security_ = 0;
}
inline ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity AuthenticateConfig::_internal_security() const {
  return static_cast< ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity >(security_);
}
inline ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity AuthenticateConfig::security() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.security)
  return _internal_security();
}
inline void AuthenticateConfig::_internal_set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value) {
  
  security_ = value;
}
inline void AuthenticateConfig::set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value) {
  _internal_set_security(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.security)
}

// bool isLivenessEnabled = 7;
inline void AuthenticateConfig::clear_islivenessenabled() {
  islivenessenabled_ = false;
}
inline bool AuthenticateConfig::_internal_islivenessenabled() const {
  return islivenessenabled_;
}
inline bool AuthenticateConfig::islivenessenabled() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.isLivenessEnabled)
  return _internal_islivenessenabled();
}
inline void AuthenticateConfig::_internal_set_islivenessenabled(bool value) {
  
  islivenessenabled_ = value;
}
inline void AuthenticateConfig::set_islivenessenabled(bool value) {
  _internal_set_islivenessenabled(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.isLivenessEnabled)
}

inline bool AuthenticateConfig::has_authId() const {
  return authId_case() != AUTHID_NOT_SET;
}
inline void AuthenticateConfig::clear_has_authId() {
  _oneof_case_[0] = AUTHID_NOT_SET;
}
inline AuthenticateConfig::AuthIdCase AuthenticateConfig::authId_case() const {
  return AuthenticateConfig::AuthIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidateEventConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool ValidateEventConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool ValidateEventConfig::has_audio() const {
  return _internal_has_audio();
}
inline void ValidateEventConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& ValidateEventConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& ValidateEventConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.audio)
  return _internal_audio();
}
inline void ValidateEventConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEventConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventConfig.audio)
  return _msg;
}
inline void ValidateEventConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventConfig.audio)
}

// string modelName = 2 [(.validate.rules) = {
inline void ValidateEventConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& ValidateEventConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEventConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventConfig.modelName)
}
inline std::string* ValidateEventConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventConfig.modelName)
  return _s;
}
inline const std::string& ValidateEventConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void ValidateEventConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEventConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventConfig.modelName)
}

// string userId = 3 [(.validate.rules) = {
inline void ValidateEventConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& ValidateEventConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEventConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventConfig.userId)
}
inline std::string* ValidateEventConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventConfig.userId)
  return _s;
}
inline const std::string& ValidateEventConfig::_internal_userid() const {
  return userid_.Get();
}
inline void ValidateEventConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEventConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventConfig.userId)
}

// .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 4 [(.validate.rules) = {
inline void ValidateEventConfig::clear_sensitivity() {
  sensitivity_ = 0;
}
inline ::sensory::api::v1::audio::ThresholdSensitivity ValidateEventConfig::_internal_sensitivity() const {
  return static_cast< ::sensory::api::v1::audio::ThresholdSensitivity >(sensitivity_);
}
inline ::sensory::api::v1::audio::ThresholdSensitivity ValidateEventConfig::sensitivity() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.sensitivity)
  return _internal_sensitivity();
}
inline void ValidateEventConfig::_internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  
  sensitivity_ = value;
}
inline void ValidateEventConfig::set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  _internal_set_sensitivity(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventConfig.sensitivity)
}

// -------------------------------------------------------------------

// TranscribeConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool TranscribeConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool TranscribeConfig::has_audio() const {
  return _internal_has_audio();
}
inline void TranscribeConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& TranscribeConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& TranscribeConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeConfig.audio)
  return _internal_audio();
}
inline void TranscribeConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.TranscribeConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeConfig.audio)
  return _msg;
}
inline void TranscribeConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeConfig.audio)
}

// string modelName = 2 [(.validate.rules) = {
inline void TranscribeConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& TranscribeConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscribeConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeConfig.modelName)
}
inline std::string* TranscribeConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeConfig.modelName)
  return _s;
}
inline const std::string& TranscribeConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void TranscribeConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranscribeConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeConfig.modelName)
}

// string userId = 3 [(.validate.rules) = {
inline void TranscribeConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& TranscribeConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscribeConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeConfig.userId)
}
inline std::string* TranscribeConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeConfig.userId)
  return _s;
}
inline const std::string& TranscribeConfig::_internal_userid() const {
  return userid_.Get();
}
inline void TranscribeConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranscribeConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeConfig.userId)
}

// -------------------------------------------------------------------

// AudioConfig

// .sensory.api.v1.audio.AudioConfig.AudioEncoding encoding = 1 [(.validate.rules) = {
inline void AudioConfig::clear_encoding() {
  encoding_ = 0;
}
inline ::sensory::api::v1::audio::AudioConfig_AudioEncoding AudioConfig::_internal_encoding() const {
  return static_cast< ::sensory::api::v1::audio::AudioConfig_AudioEncoding >(encoding_);
}
inline ::sensory::api::v1::audio::AudioConfig_AudioEncoding AudioConfig::encoding() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.encoding)
  return _internal_encoding();
}
inline void AudioConfig::_internal_set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value) {
  
  encoding_ = value;
}
inline void AudioConfig::set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.encoding)
}

// int32 sampleRateHertz = 2 [(.validate.rules) = {
inline void AudioConfig::clear_sampleratehertz() {
  sampleratehertz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::_internal_sampleratehertz() const {
  return sampleratehertz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::sampleratehertz() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.sampleRateHertz)
  return _internal_sampleratehertz();
}
inline void AudioConfig::_internal_set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sampleratehertz_ = value;
}
inline void AudioConfig::set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sampleratehertz(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.sampleRateHertz)
}

// int32 audioChannelCount = 3 [(.validate.rules) = {
inline void AudioConfig::clear_audiochannelcount() {
  audiochannelcount_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::_internal_audiochannelcount() const {
  return audiochannelcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::audiochannelcount() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.audioChannelCount)
  return _internal_audiochannelcount();
}
inline void AudioConfig::_internal_set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  audiochannelcount_ = value;
}
inline void AudioConfig::set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_audiochannelcount(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.audioChannelCount)
}

// string languageCode = 4;
inline void AudioConfig::clear_languagecode() {
  languagecode_.ClearToEmpty();
}
inline const std::string& AudioConfig::languagecode() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.languageCode)
  return _internal_languagecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioConfig::set_languagecode(ArgT0&& arg0, ArgT... args) {
 
 languagecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.languageCode)
}
inline std::string* AudioConfig::mutable_languagecode() {
  std::string* _s = _internal_mutable_languagecode();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioConfig.languageCode)
  return _s;
}
inline const std::string& AudioConfig::_internal_languagecode() const {
  return languagecode_.Get();
}
inline void AudioConfig::_internal_set_languagecode(const std::string& value) {
  
  languagecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioConfig::_internal_mutable_languagecode() {
  
  return languagecode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioConfig::release_languagecode() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioConfig.languageCode)
  return languagecode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioConfig::set_allocated_languagecode(std::string* languagecode) {
  if (languagecode != nullptr) {
    
  } else {
    
  }
  languagecode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), languagecode,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioConfig.languageCode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace audio
}  // namespace v1
}  // namespace api
}  // namespace sensory

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity>() {
  return ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::v1::audio::AudioConfig_AudioEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::AudioConfig_AudioEncoding>() {
  return ::sensory::api::v1::audio::AudioConfig_AudioEncoding_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::v1::audio::ThresholdSensitivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::ThresholdSensitivity>() {
  return ::sensory::api::v1::audio::ThresholdSensitivity_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_v1_2faudio_2faudio_2eproto
