// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/video/video.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2fvideo_2fvideo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_v1_2fvideo_2fvideo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sensorycloud/protoc/validate/validate.pb.h"
#include "sensorycloud/protoc/common/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_v1_2fvideo_2fvideo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2fvideo_2fvideo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v1_2fvideo_2fvideo_2eproto;
namespace sensory {
namespace api {
namespace v1 {
namespace video {
class AuthenticateConfig;
struct AuthenticateConfigDefaultTypeInternal;
extern AuthenticateConfigDefaultTypeInternal _AuthenticateConfig_default_instance_;
class AuthenticateRequest;
struct AuthenticateRequestDefaultTypeInternal;
extern AuthenticateRequestDefaultTypeInternal _AuthenticateRequest_default_instance_;
class AuthenticateResponse;
struct AuthenticateResponseDefaultTypeInternal;
extern AuthenticateResponseDefaultTypeInternal _AuthenticateResponse_default_instance_;
class CreateEnrollmentConfig;
struct CreateEnrollmentConfigDefaultTypeInternal;
extern CreateEnrollmentConfigDefaultTypeInternal _CreateEnrollmentConfig_default_instance_;
class CreateEnrollmentRequest;
struct CreateEnrollmentRequestDefaultTypeInternal;
extern CreateEnrollmentRequestDefaultTypeInternal _CreateEnrollmentRequest_default_instance_;
class CreateEnrollmentResponse;
struct CreateEnrollmentResponseDefaultTypeInternal;
extern CreateEnrollmentResponseDefaultTypeInternal _CreateEnrollmentResponse_default_instance_;
class GetModelsRequest;
struct GetModelsRequestDefaultTypeInternal;
extern GetModelsRequestDefaultTypeInternal _GetModelsRequest_default_instance_;
class GetModelsResponse;
struct GetModelsResponseDefaultTypeInternal;
extern GetModelsResponseDefaultTypeInternal _GetModelsResponse_default_instance_;
class LivenessRecognitionResponse;
struct LivenessRecognitionResponseDefaultTypeInternal;
extern LivenessRecognitionResponseDefaultTypeInternal _LivenessRecognitionResponse_default_instance_;
class ValidateRecognitionConfig;
struct ValidateRecognitionConfigDefaultTypeInternal;
extern ValidateRecognitionConfigDefaultTypeInternal _ValidateRecognitionConfig_default_instance_;
class ValidateRecognitionRequest;
struct ValidateRecognitionRequestDefaultTypeInternal;
extern ValidateRecognitionRequestDefaultTypeInternal _ValidateRecognitionRequest_default_instance_;
class VideoModel;
struct VideoModelDefaultTypeInternal;
extern VideoModelDefaultTypeInternal _VideoModel_default_instance_;
}  // namespace video
}  // namespace v1
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::v1::video::AuthenticateConfig* Arena::CreateMaybeMessage<::sensory::api::v1::video::AuthenticateConfig>(Arena*);
template<> ::sensory::api::v1::video::AuthenticateRequest* Arena::CreateMaybeMessage<::sensory::api::v1::video::AuthenticateRequest>(Arena*);
template<> ::sensory::api::v1::video::AuthenticateResponse* Arena::CreateMaybeMessage<::sensory::api::v1::video::AuthenticateResponse>(Arena*);
template<> ::sensory::api::v1::video::CreateEnrollmentConfig* Arena::CreateMaybeMessage<::sensory::api::v1::video::CreateEnrollmentConfig>(Arena*);
template<> ::sensory::api::v1::video::CreateEnrollmentRequest* Arena::CreateMaybeMessage<::sensory::api::v1::video::CreateEnrollmentRequest>(Arena*);
template<> ::sensory::api::v1::video::CreateEnrollmentResponse* Arena::CreateMaybeMessage<::sensory::api::v1::video::CreateEnrollmentResponse>(Arena*);
template<> ::sensory::api::v1::video::GetModelsRequest* Arena::CreateMaybeMessage<::sensory::api::v1::video::GetModelsRequest>(Arena*);
template<> ::sensory::api::v1::video::GetModelsResponse* Arena::CreateMaybeMessage<::sensory::api::v1::video::GetModelsResponse>(Arena*);
template<> ::sensory::api::v1::video::LivenessRecognitionResponse* Arena::CreateMaybeMessage<::sensory::api::v1::video::LivenessRecognitionResponse>(Arena*);
template<> ::sensory::api::v1::video::ValidateRecognitionConfig* Arena::CreateMaybeMessage<::sensory::api::v1::video::ValidateRecognitionConfig>(Arena*);
template<> ::sensory::api::v1::video::ValidateRecognitionRequest* Arena::CreateMaybeMessage<::sensory::api::v1::video::ValidateRecognitionRequest>(Arena*);
template<> ::sensory::api::v1::video::VideoModel* Arena::CreateMaybeMessage<::sensory::api::v1::video::VideoModel>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace v1 {
namespace video {

enum RecognitionThreshold : int {
  LOW = 0,
  MEDIUM = 1,
  HIGH = 2,
  HIGHEST = 3,
  RecognitionThreshold_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RecognitionThreshold_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RecognitionThreshold_IsValid(int value);
constexpr RecognitionThreshold RecognitionThreshold_MIN = LOW;
constexpr RecognitionThreshold RecognitionThreshold_MAX = HIGHEST;
constexpr int RecognitionThreshold_ARRAYSIZE = RecognitionThreshold_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecognitionThreshold_descriptor();
template<typename T>
inline const std::string& RecognitionThreshold_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecognitionThreshold>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecognitionThreshold_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecognitionThreshold_descriptor(), enum_t_value);
}
inline bool RecognitionThreshold_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecognitionThreshold* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecognitionThreshold>(
    RecognitionThreshold_descriptor(), name, value);
}
// ===================================================================

class VideoModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.VideoModel) */ {
 public:
  inline VideoModel() : VideoModel(nullptr) {}
  ~VideoModel() override;
  explicit constexpr VideoModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoModel(const VideoModel& from);
  VideoModel(VideoModel&& from) noexcept
    : VideoModel() {
    *this = ::std::move(from);
  }

  inline VideoModel& operator=(const VideoModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoModel& operator=(VideoModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoModel* internal_default_instance() {
    return reinterpret_cast<const VideoModel*>(
               &_VideoModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VideoModel& a, VideoModel& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoModel* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoModel* New() const final {
    return new VideoModel();
  }

  VideoModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VideoModel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.VideoModel";
  }
  protected:
  explicit VideoModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 5,
    kNameFieldNumber = 1,
    kFixedObjectFieldNumber = 4,
    kModelTypeFieldNumber = 3,
    kIsEnrollableFieldNumber = 2,
    kIsLivenessSupportedFieldNumber = 7,
    kTechnologyFieldNumber = 6,
  };
  // repeated string versions = 5;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fixedObject = 4;
  void clear_fixedobject();
  const std::string& fixedobject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fixedobject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fixedobject();
  PROTOBUF_MUST_USE_RESULT std::string* release_fixedobject();
  void set_allocated_fixedobject(std::string* fixedobject);
  private:
  const std::string& _internal_fixedobject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixedobject(const std::string& value);
  std::string* _internal_mutable_fixedobject();
  public:

  // .sensory.api.common.ModelType modelType = 3;
  void clear_modeltype();
  ::sensory::api::common::ModelType modeltype() const;
  void set_modeltype(::sensory::api::common::ModelType value);
  private:
  ::sensory::api::common::ModelType _internal_modeltype() const;
  void _internal_set_modeltype(::sensory::api::common::ModelType value);
  public:

  // bool isEnrollable = 2;
  void clear_isenrollable();
  bool isenrollable() const;
  void set_isenrollable(bool value);
  private:
  bool _internal_isenrollable() const;
  void _internal_set_isenrollable(bool value);
  public:

  // bool isLivenessSupported = 7;
  void clear_islivenesssupported();
  bool islivenesssupported() const;
  void set_islivenesssupported(bool value);
  private:
  bool _internal_islivenesssupported() const;
  void _internal_set_islivenesssupported(bool value);
  public:

  // .sensory.api.common.TechnologyType technology = 6;
  void clear_technology();
  ::sensory::api::common::TechnologyType technology() const;
  void set_technology(::sensory::api::common::TechnologyType value);
  private:
  ::sensory::api::common::TechnologyType _internal_technology() const;
  void _internal_set_technology(::sensory::api::common::TechnologyType value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.VideoModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixedobject_;
  int modeltype_;
  bool isenrollable_;
  bool islivenesssupported_;
  int technology_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class GetModelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.GetModelsRequest) */ {
 public:
  inline GetModelsRequest() : GetModelsRequest(nullptr) {}
  ~GetModelsRequest() override;
  explicit constexpr GetModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsRequest(const GetModelsRequest& from);
  GetModelsRequest(GetModelsRequest&& from) noexcept
    : GetModelsRequest() {
    *this = ::std::move(from);
  }

  inline GetModelsRequest& operator=(const GetModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsRequest& operator=(GetModelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsRequest* internal_default_instance() {
    return reinterpret_cast<const GetModelsRequest*>(
               &_GetModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetModelsRequest& a, GetModelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsRequest* New() const final {
    return new GetModelsRequest();
  }

  GetModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModelsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.GetModelsRequest";
  }
  protected:
  explicit GetModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.GetModelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class GetModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.GetModelsResponse) */ {
 public:
  inline GetModelsResponse() : GetModelsResponse(nullptr) {}
  ~GetModelsResponse() override;
  explicit constexpr GetModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsResponse(const GetModelsResponse& from);
  GetModelsResponse(GetModelsResponse&& from) noexcept
    : GetModelsResponse() {
    *this = ::std::move(from);
  }

  inline GetModelsResponse& operator=(const GetModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsResponse& operator=(GetModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsResponse* internal_default_instance() {
    return reinterpret_cast<const GetModelsResponse*>(
               &_GetModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetModelsResponse& a, GetModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsResponse* New() const final {
    return new GetModelsResponse();
  }

  GetModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModelsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.GetModelsResponse";
  }
  protected:
  explicit GetModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
  };
  // repeated .sensory.api.v1.video.VideoModel models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::sensory::api::v1::video::VideoModel* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::video::VideoModel >*
      mutable_models();
  private:
  const ::sensory::api::v1::video::VideoModel& _internal_models(int index) const;
  ::sensory::api::v1::video::VideoModel* _internal_add_models();
  public:
  const ::sensory::api::v1::video::VideoModel& models(int index) const;
  ::sensory::api::v1::video::VideoModel* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::video::VideoModel >&
      models() const;

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.GetModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::video::VideoModel > models_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.CreateEnrollmentRequest) */ {
 public:
  inline CreateEnrollmentRequest() : CreateEnrollmentRequest(nullptr) {}
  ~CreateEnrollmentRequest() override;
  explicit constexpr CreateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentRequest(const CreateEnrollmentRequest& from);
  CreateEnrollmentRequest(CreateEnrollmentRequest&& from) noexcept
    : CreateEnrollmentRequest() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentRequest& operator=(const CreateEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentRequest& operator=(CreateEnrollmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kImageContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const CreateEnrollmentRequest* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentRequest*>(
               &_CreateEnrollmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateEnrollmentRequest& a, CreateEnrollmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentRequest* New() const final {
    return new CreateEnrollmentRequest();
  }

  CreateEnrollmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.CreateEnrollmentRequest";
  }
  protected:
  explicit CreateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kImageContentFieldNumber = 2,
  };
  // .sensory.api.v1.video.CreateEnrollmentConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::video::CreateEnrollmentConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::video::CreateEnrollmentConfig* release_config();
  ::sensory::api::v1::video::CreateEnrollmentConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::video::CreateEnrollmentConfig* config);
  private:
  const ::sensory::api::v1::video::CreateEnrollmentConfig& _internal_config() const;
  ::sensory::api::v1::video::CreateEnrollmentConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::video::CreateEnrollmentConfig* config);
  ::sensory::api::v1::video::CreateEnrollmentConfig* unsafe_arena_release_config();

  // bytes imageContent = 2;
  bool has_imagecontent() const;
  private:
  bool _internal_has_imagecontent() const;
  public:
  void clear_imagecontent();
  const std::string& imagecontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imagecontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imagecontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_imagecontent();
  void set_allocated_imagecontent(std::string* imagecontent);
  private:
  const std::string& _internal_imagecontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imagecontent(const std::string& value);
  std::string* _internal_mutable_imagecontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.CreateEnrollmentRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_imagecontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::video::CreateEnrollmentConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagecontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.AuthenticateRequest) */ {
 public:
  inline AuthenticateRequest() : AuthenticateRequest(nullptr) {}
  ~AuthenticateRequest() override;
  explicit constexpr AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateRequest(const AuthenticateRequest& from);
  AuthenticateRequest(AuthenticateRequest&& from) noexcept
    : AuthenticateRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateRequest& operator=(const AuthenticateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateRequest& operator=(AuthenticateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kImageContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const AuthenticateRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateRequest*>(
               &_AuthenticateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AuthenticateRequest& a, AuthenticateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateRequest* New() const final {
    return new AuthenticateRequest();
  }

  AuthenticateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.AuthenticateRequest";
  }
  protected:
  explicit AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kImageContentFieldNumber = 2,
  };
  // .sensory.api.v1.video.AuthenticateConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::video::AuthenticateConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::video::AuthenticateConfig* release_config();
  ::sensory::api::v1::video::AuthenticateConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::video::AuthenticateConfig* config);
  private:
  const ::sensory::api::v1::video::AuthenticateConfig& _internal_config() const;
  ::sensory::api::v1::video::AuthenticateConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::video::AuthenticateConfig* config);
  ::sensory::api::v1::video::AuthenticateConfig* unsafe_arena_release_config();

  // bytes imageContent = 2;
  bool has_imagecontent() const;
  private:
  bool _internal_has_imagecontent() const;
  public:
  void clear_imagecontent();
  const std::string& imagecontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imagecontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imagecontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_imagecontent();
  void set_allocated_imagecontent(std::string* imagecontent);
  private:
  const std::string& _internal_imagecontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imagecontent(const std::string& value);
  std::string* _internal_mutable_imagecontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.AuthenticateRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_imagecontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::video::AuthenticateConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagecontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class ValidateRecognitionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.ValidateRecognitionRequest) */ {
 public:
  inline ValidateRecognitionRequest() : ValidateRecognitionRequest(nullptr) {}
  ~ValidateRecognitionRequest() override;
  explicit constexpr ValidateRecognitionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateRecognitionRequest(const ValidateRecognitionRequest& from);
  ValidateRecognitionRequest(ValidateRecognitionRequest&& from) noexcept
    : ValidateRecognitionRequest() {
    *this = ::std::move(from);
  }

  inline ValidateRecognitionRequest& operator=(const ValidateRecognitionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateRecognitionRequest& operator=(ValidateRecognitionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateRecognitionRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kImageContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const ValidateRecognitionRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateRecognitionRequest*>(
               &_ValidateRecognitionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValidateRecognitionRequest& a, ValidateRecognitionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateRecognitionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateRecognitionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateRecognitionRequest* New() const final {
    return new ValidateRecognitionRequest();
  }

  ValidateRecognitionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateRecognitionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateRecognitionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateRecognitionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateRecognitionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.ValidateRecognitionRequest";
  }
  protected:
  explicit ValidateRecognitionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kImageContentFieldNumber = 2,
  };
  // .sensory.api.v1.video.ValidateRecognitionConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::video::ValidateRecognitionConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::video::ValidateRecognitionConfig* release_config();
  ::sensory::api::v1::video::ValidateRecognitionConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::video::ValidateRecognitionConfig* config);
  private:
  const ::sensory::api::v1::video::ValidateRecognitionConfig& _internal_config() const;
  ::sensory::api::v1::video::ValidateRecognitionConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::video::ValidateRecognitionConfig* config);
  ::sensory::api::v1::video::ValidateRecognitionConfig* unsafe_arena_release_config();

  // bytes imageContent = 2;
  bool has_imagecontent() const;
  private:
  bool _internal_has_imagecontent() const;
  public:
  void clear_imagecontent();
  const std::string& imagecontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imagecontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imagecontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_imagecontent();
  void set_allocated_imagecontent(std::string* imagecontent);
  private:
  const std::string& _internal_imagecontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imagecontent(const std::string& value);
  std::string* _internal_mutable_imagecontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.ValidateRecognitionRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_imagecontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::video::ValidateRecognitionConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagecontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.CreateEnrollmentResponse) */ {
 public:
  inline CreateEnrollmentResponse() : CreateEnrollmentResponse(nullptr) {}
  ~CreateEnrollmentResponse() override;
  explicit constexpr CreateEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentResponse(const CreateEnrollmentResponse& from);
  CreateEnrollmentResponse(CreateEnrollmentResponse&& from) noexcept
    : CreateEnrollmentResponse() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentResponse& operator=(const CreateEnrollmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentResponse& operator=(CreateEnrollmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateEnrollmentResponse* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentResponse*>(
               &_CreateEnrollmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateEnrollmentResponse& a, CreateEnrollmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentResponse* New() const final {
    return new CreateEnrollmentResponse();
  }

  CreateEnrollmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.CreateEnrollmentResponse";
  }
  protected:
  explicit CreateEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdFieldNumber = 3,
    kModelNameFieldNumber = 4,
    kModelVersionFieldNumber = 5,
    kPercentCompleteFieldNumber = 1,
    kIsAliveFieldNumber = 2,
  };
  // string enrollmentId = 3;
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string modelName = 4;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string modelVersion = 5;
  void clear_modelversion();
  const std::string& modelversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelversion();
  void set_allocated_modelversion(std::string* modelversion);
  private:
  const std::string& _internal_modelversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelversion(const std::string& value);
  std::string* _internal_mutable_modelversion();
  public:

  // int64 percentComplete = 1;
  void clear_percentcomplete();
  ::PROTOBUF_NAMESPACE_ID::int64 percentcomplete() const;
  void set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_percentcomplete() const;
  void _internal_set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool isAlive = 2;
  void clear_isalive();
  bool isalive() const;
  void set_isalive(bool value);
  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.CreateEnrollmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelversion_;
  ::PROTOBUF_NAMESPACE_ID::int64 percentcomplete_;
  bool isalive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.AuthenticateResponse) */ {
 public:
  inline AuthenticateResponse() : AuthenticateResponse(nullptr) {}
  ~AuthenticateResponse() override;
  explicit constexpr AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateResponse(const AuthenticateResponse& from);
  AuthenticateResponse(AuthenticateResponse&& from) noexcept
    : AuthenticateResponse() {
    *this = ::std::move(from);
  }

  inline AuthenticateResponse& operator=(const AuthenticateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateResponse& operator=(AuthenticateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateResponse* internal_default_instance() {
    return reinterpret_cast<const AuthenticateResponse*>(
               &_AuthenticateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AuthenticateResponse& a, AuthenticateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateResponse* New() const final {
    return new AuthenticateResponse();
  }

  AuthenticateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.AuthenticateResponse";
  }
  protected:
  explicit AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 4,
    kScoreFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kIsAliveFieldNumber = 3,
  };
  // .sensory.api.common.TokenResponse token = 4;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::sensory::api::common::TokenResponse& token() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::TokenResponse* release_token();
  ::sensory::api::common::TokenResponse* mutable_token();
  void set_allocated_token(::sensory::api::common::TokenResponse* token);
  private:
  const ::sensory::api::common::TokenResponse& _internal_token() const;
  ::sensory::api::common::TokenResponse* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::sensory::api::common::TokenResponse* token);
  ::sensory::api::common::TokenResponse* unsafe_arena_release_token();

  // float score = 2;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool isAlive = 3;
  void clear_isalive();
  bool isalive() const;
  void set_isalive(bool value);
  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.AuthenticateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensory::api::common::TokenResponse* token_;
  float score_;
  bool success_;
  bool isalive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class LivenessRecognitionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.LivenessRecognitionResponse) */ {
 public:
  inline LivenessRecognitionResponse() : LivenessRecognitionResponse(nullptr) {}
  ~LivenessRecognitionResponse() override;
  explicit constexpr LivenessRecognitionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LivenessRecognitionResponse(const LivenessRecognitionResponse& from);
  LivenessRecognitionResponse(LivenessRecognitionResponse&& from) noexcept
    : LivenessRecognitionResponse() {
    *this = ::std::move(from);
  }

  inline LivenessRecognitionResponse& operator=(const LivenessRecognitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LivenessRecognitionResponse& operator=(LivenessRecognitionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LivenessRecognitionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LivenessRecognitionResponse* internal_default_instance() {
    return reinterpret_cast<const LivenessRecognitionResponse*>(
               &_LivenessRecognitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LivenessRecognitionResponse& a, LivenessRecognitionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LivenessRecognitionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LivenessRecognitionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LivenessRecognitionResponse* New() const final {
    return new LivenessRecognitionResponse();
  }

  LivenessRecognitionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LivenessRecognitionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LivenessRecognitionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LivenessRecognitionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LivenessRecognitionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.LivenessRecognitionResponse";
  }
  protected:
  explicit LivenessRecognitionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsAliveFieldNumber = 1,
    kScoreFieldNumber = 2,
  };
  // bool isAlive = 1;
  void clear_isalive();
  bool isalive() const;
  void set_isalive(bool value);
  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);
  public:

  // float score = 2;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.LivenessRecognitionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool isalive_;
  float score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.CreateEnrollmentConfig) */ {
 public:
  inline CreateEnrollmentConfig() : CreateEnrollmentConfig(nullptr) {}
  ~CreateEnrollmentConfig() override;
  explicit constexpr CreateEnrollmentConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentConfig(const CreateEnrollmentConfig& from);
  CreateEnrollmentConfig(CreateEnrollmentConfig&& from) noexcept
    : CreateEnrollmentConfig() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentConfig& operator=(const CreateEnrollmentConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentConfig& operator=(CreateEnrollmentConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateEnrollmentConfig* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentConfig*>(
               &_CreateEnrollmentConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateEnrollmentConfig& a, CreateEnrollmentConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentConfig* New() const final {
    return new CreateEnrollmentConfig();
  }

  CreateEnrollmentConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.CreateEnrollmentConfig";
  }
  protected:
  explicit CreateEnrollmentConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kModelNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCompressionFieldNumber = 7,
    kIsLivenessEnabledFieldNumber = 5,
    kLivenessThresholdFieldNumber = 6,
  };
  // string userId = 1 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceId = 2 [(.validate.rules) = {
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_MUST_USE_RESULT std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string modelName = 3 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string description = 4 [(.validate.rules) = {
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .sensory.api.common.CompressionConfiguration compression = 7;
  bool has_compression() const;
  private:
  bool _internal_has_compression() const;
  public:
  void clear_compression();
  const ::sensory::api::common::CompressionConfiguration& compression() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::CompressionConfiguration* release_compression();
  ::sensory::api::common::CompressionConfiguration* mutable_compression();
  void set_allocated_compression(::sensory::api::common::CompressionConfiguration* compression);
  private:
  const ::sensory::api::common::CompressionConfiguration& _internal_compression() const;
  ::sensory::api::common::CompressionConfiguration* _internal_mutable_compression();
  public:
  void unsafe_arena_set_allocated_compression(
      ::sensory::api::common::CompressionConfiguration* compression);
  ::sensory::api::common::CompressionConfiguration* unsafe_arena_release_compression();

  // bool isLivenessEnabled = 5;
  void clear_islivenessenabled();
  bool islivenessenabled() const;
  void set_islivenessenabled(bool value);
  private:
  bool _internal_islivenessenabled() const;
  void _internal_set_islivenessenabled(bool value);
  public:

  // .sensory.api.v1.video.RecognitionThreshold livenessThreshold = 6 [(.validate.rules) = {
  void clear_livenessthreshold();
  ::sensory::api::v1::video::RecognitionThreshold livenessthreshold() const;
  void set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value);
  private:
  ::sensory::api::v1::video::RecognitionThreshold _internal_livenessthreshold() const;
  void _internal_set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.CreateEnrollmentConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::sensory::api::common::CompressionConfiguration* compression_;
  bool islivenessenabled_;
  int livenessthreshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.AuthenticateConfig) */ {
 public:
  inline AuthenticateConfig() : AuthenticateConfig(nullptr) {}
  ~AuthenticateConfig() override;
  explicit constexpr AuthenticateConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateConfig(const AuthenticateConfig& from);
  AuthenticateConfig(AuthenticateConfig&& from) noexcept
    : AuthenticateConfig() {
    *this = ::std::move(from);
  }

  inline AuthenticateConfig& operator=(const AuthenticateConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateConfig& operator=(AuthenticateConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateConfig* internal_default_instance() {
    return reinterpret_cast<const AuthenticateConfig*>(
               &_AuthenticateConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AuthenticateConfig& a, AuthenticateConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateConfig* New() const final {
    return new AuthenticateConfig();
  }

  AuthenticateConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.AuthenticateConfig";
  }
  protected:
  explicit AuthenticateConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdFieldNumber = 1,
    kCompressionFieldNumber = 4,
    kLivenessThresholdFieldNumber = 3,
    kIsLivenessEnabledFieldNumber = 2,
    kDoIncludeTokenFieldNumber = 5,
  };
  // string enrollmentId = 1 [(.validate.rules) = {
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // .sensory.api.common.CompressionConfiguration compression = 4;
  bool has_compression() const;
  private:
  bool _internal_has_compression() const;
  public:
  void clear_compression();
  const ::sensory::api::common::CompressionConfiguration& compression() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::CompressionConfiguration* release_compression();
  ::sensory::api::common::CompressionConfiguration* mutable_compression();
  void set_allocated_compression(::sensory::api::common::CompressionConfiguration* compression);
  private:
  const ::sensory::api::common::CompressionConfiguration& _internal_compression() const;
  ::sensory::api::common::CompressionConfiguration* _internal_mutable_compression();
  public:
  void unsafe_arena_set_allocated_compression(
      ::sensory::api::common::CompressionConfiguration* compression);
  ::sensory::api::common::CompressionConfiguration* unsafe_arena_release_compression();

  // .sensory.api.v1.video.RecognitionThreshold livenessThreshold = 3 [(.validate.rules) = {
  void clear_livenessthreshold();
  ::sensory::api::v1::video::RecognitionThreshold livenessthreshold() const;
  void set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value);
  private:
  ::sensory::api::v1::video::RecognitionThreshold _internal_livenessthreshold() const;
  void _internal_set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value);
  public:

  // bool isLivenessEnabled = 2;
  void clear_islivenessenabled();
  bool islivenessenabled() const;
  void set_islivenessenabled(bool value);
  private:
  bool _internal_islivenessenabled() const;
  void _internal_set_islivenessenabled(bool value);
  public:

  // bool doIncludeToken = 5;
  void clear_doincludetoken();
  bool doincludetoken() const;
  void set_doincludetoken(bool value);
  private:
  bool _internal_doincludetoken() const;
  void _internal_set_doincludetoken(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.AuthenticateConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
  ::sensory::api::common::CompressionConfiguration* compression_;
  int livenessthreshold_;
  bool islivenessenabled_;
  bool doincludetoken_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// -------------------------------------------------------------------

class ValidateRecognitionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.video.ValidateRecognitionConfig) */ {
 public:
  inline ValidateRecognitionConfig() : ValidateRecognitionConfig(nullptr) {}
  ~ValidateRecognitionConfig() override;
  explicit constexpr ValidateRecognitionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateRecognitionConfig(const ValidateRecognitionConfig& from);
  ValidateRecognitionConfig(ValidateRecognitionConfig&& from) noexcept
    : ValidateRecognitionConfig() {
    *this = ::std::move(from);
  }

  inline ValidateRecognitionConfig& operator=(const ValidateRecognitionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateRecognitionConfig& operator=(ValidateRecognitionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateRecognitionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateRecognitionConfig* internal_default_instance() {
    return reinterpret_cast<const ValidateRecognitionConfig*>(
               &_ValidateRecognitionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ValidateRecognitionConfig& a, ValidateRecognitionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateRecognitionConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateRecognitionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateRecognitionConfig* New() const final {
    return new ValidateRecognitionConfig();
  }

  ValidateRecognitionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateRecognitionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateRecognitionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateRecognitionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateRecognitionConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.video.ValidateRecognitionConfig";
  }
  protected:
  explicit ValidateRecognitionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kThresholdFieldNumber = 3,
  };
  // string modelName = 1 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string userId = 2 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sensory.api.v1.video.RecognitionThreshold threshold = 3 [(.validate.rules) = {
  void clear_threshold();
  ::sensory::api::v1::video::RecognitionThreshold threshold() const;
  void set_threshold(::sensory::api::v1::video::RecognitionThreshold value);
  private:
  ::sensory::api::v1::video::RecognitionThreshold _internal_threshold() const;
  void _internal_set_threshold(::sensory::api::v1::video::RecognitionThreshold value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.video.ValidateRecognitionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  int threshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fvideo_2fvideo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VideoModel

// string name = 1;
inline void VideoModel::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& VideoModel::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.VideoModel.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoModel::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.name)
}
inline std::string* VideoModel::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.VideoModel.name)
  return _s;
}
inline const std::string& VideoModel::_internal_name() const {
  return name_.Get();
}
inline void VideoModel::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoModel::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoModel::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.VideoModel.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoModel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.VideoModel.name)
}

// bool isEnrollable = 2;
inline void VideoModel::clear_isenrollable() {
  isenrollable_ = false;
}
inline bool VideoModel::_internal_isenrollable() const {
  return isenrollable_;
}
inline bool VideoModel::isenrollable() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.VideoModel.isEnrollable)
  return _internal_isenrollable();
}
inline void VideoModel::_internal_set_isenrollable(bool value) {
  
  isenrollable_ = value;
}
inline void VideoModel::set_isenrollable(bool value) {
  _internal_set_isenrollable(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.isEnrollable)
}

// .sensory.api.common.ModelType modelType = 3;
inline void VideoModel::clear_modeltype() {
  modeltype_ = 0;
}
inline ::sensory::api::common::ModelType VideoModel::_internal_modeltype() const {
  return static_cast< ::sensory::api::common::ModelType >(modeltype_);
}
inline ::sensory::api::common::ModelType VideoModel::modeltype() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.VideoModel.modelType)
  return _internal_modeltype();
}
inline void VideoModel::_internal_set_modeltype(::sensory::api::common::ModelType value) {
  
  modeltype_ = value;
}
inline void VideoModel::set_modeltype(::sensory::api::common::ModelType value) {
  _internal_set_modeltype(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.modelType)
}

// string fixedObject = 4;
inline void VideoModel::clear_fixedobject() {
  fixedobject_.ClearToEmpty();
}
inline const std::string& VideoModel::fixedobject() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.VideoModel.fixedObject)
  return _internal_fixedobject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoModel::set_fixedobject(ArgT0&& arg0, ArgT... args) {
 
 fixedobject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.fixedObject)
}
inline std::string* VideoModel::mutable_fixedobject() {
  std::string* _s = _internal_mutable_fixedobject();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.VideoModel.fixedObject)
  return _s;
}
inline const std::string& VideoModel::_internal_fixedobject() const {
  return fixedobject_.Get();
}
inline void VideoModel::_internal_set_fixedobject(const std::string& value) {
  
  fixedobject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VideoModel::_internal_mutable_fixedobject() {
  
  return fixedobject_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VideoModel::release_fixedobject() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.VideoModel.fixedObject)
  return fixedobject_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VideoModel::set_allocated_fixedobject(std::string* fixedobject) {
  if (fixedobject != nullptr) {
    
  } else {
    
  }
  fixedobject_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fixedobject,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.VideoModel.fixedObject)
}

// repeated string versions = 5;
inline int VideoModel::_internal_versions_size() const {
  return versions_.size();
}
inline int VideoModel::versions_size() const {
  return _internal_versions_size();
}
inline void VideoModel::clear_versions() {
  versions_.Clear();
}
inline std::string* VideoModel::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:sensory.api.v1.video.VideoModel.versions)
  return _s;
}
inline const std::string& VideoModel::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const std::string& VideoModel::versions(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.VideoModel.versions)
  return _internal_versions(index);
}
inline std::string* VideoModel::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.VideoModel.versions)
  return versions_.Mutable(index);
}
inline void VideoModel::set_versions(int index, const std::string& value) {
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.versions)
}
inline void VideoModel::set_versions(int index, std::string&& value) {
  versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.versions)
}
inline void VideoModel::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensory.api.v1.video.VideoModel.versions)
}
inline void VideoModel::set_versions(int index, const char* value, size_t size) {
  versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensory.api.v1.video.VideoModel.versions)
}
inline std::string* VideoModel::_internal_add_versions() {
  return versions_.Add();
}
inline void VideoModel::add_versions(const std::string& value) {
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensory.api.v1.video.VideoModel.versions)
}
inline void VideoModel::add_versions(std::string&& value) {
  versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensory.api.v1.video.VideoModel.versions)
}
inline void VideoModel::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensory.api.v1.video.VideoModel.versions)
}
inline void VideoModel::add_versions(const char* value, size_t size) {
  versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensory.api.v1.video.VideoModel.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VideoModel::versions() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.video.VideoModel.versions)
  return versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VideoModel::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.video.VideoModel.versions)
  return &versions_;
}

// .sensory.api.common.TechnologyType technology = 6;
inline void VideoModel::clear_technology() {
  technology_ = 0;
}
inline ::sensory::api::common::TechnologyType VideoModel::_internal_technology() const {
  return static_cast< ::sensory::api::common::TechnologyType >(technology_);
}
inline ::sensory::api::common::TechnologyType VideoModel::technology() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.VideoModel.technology)
  return _internal_technology();
}
inline void VideoModel::_internal_set_technology(::sensory::api::common::TechnologyType value) {
  
  technology_ = value;
}
inline void VideoModel::set_technology(::sensory::api::common::TechnologyType value) {
  _internal_set_technology(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.technology)
}

// bool isLivenessSupported = 7;
inline void VideoModel::clear_islivenesssupported() {
  islivenesssupported_ = false;
}
inline bool VideoModel::_internal_islivenesssupported() const {
  return islivenesssupported_;
}
inline bool VideoModel::islivenesssupported() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.VideoModel.isLivenessSupported)
  return _internal_islivenesssupported();
}
inline void VideoModel::_internal_set_islivenesssupported(bool value) {
  
  islivenesssupported_ = value;
}
inline void VideoModel::set_islivenesssupported(bool value) {
  _internal_set_islivenesssupported(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.VideoModel.isLivenessSupported)
}

// -------------------------------------------------------------------

// GetModelsRequest

// -------------------------------------------------------------------

// GetModelsResponse

// repeated .sensory.api.v1.video.VideoModel models = 1;
inline int GetModelsResponse::_internal_models_size() const {
  return models_.size();
}
inline int GetModelsResponse::models_size() const {
  return _internal_models_size();
}
inline void GetModelsResponse::clear_models() {
  models_.Clear();
}
inline ::sensory::api::v1::video::VideoModel* GetModelsResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.GetModelsResponse.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::video::VideoModel >*
GetModelsResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.video.GetModelsResponse.models)
  return &models_;
}
inline const ::sensory::api::v1::video::VideoModel& GetModelsResponse::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::sensory::api::v1::video::VideoModel& GetModelsResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.GetModelsResponse.models)
  return _internal_models(index);
}
inline ::sensory::api::v1::video::VideoModel* GetModelsResponse::_internal_add_models() {
  return models_.Add();
}
inline ::sensory::api::v1::video::VideoModel* GetModelsResponse::add_models() {
  ::sensory::api::v1::video::VideoModel* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:sensory.api.v1.video.GetModelsResponse.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::video::VideoModel >&
GetModelsResponse::models() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.video.GetModelsResponse.models)
  return models_;
}

// -------------------------------------------------------------------

// CreateEnrollmentRequest

// .sensory.api.v1.video.CreateEnrollmentConfig config = 1;
inline bool CreateEnrollmentRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool CreateEnrollmentRequest::has_config() const {
  return _internal_has_config();
}
inline void CreateEnrollmentRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void CreateEnrollmentRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::video::CreateEnrollmentConfig* CreateEnrollmentRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::video::CreateEnrollmentConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::video::CreateEnrollmentConfig& CreateEnrollmentRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::video::CreateEnrollmentConfig&>(::sensory::api::v1::video::_CreateEnrollmentConfig_default_instance_);
}
inline const ::sensory::api::v1::video::CreateEnrollmentConfig& CreateEnrollmentRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::video::CreateEnrollmentConfig* CreateEnrollmentRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.video.CreateEnrollmentRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::video::CreateEnrollmentConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateEnrollmentRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::video::CreateEnrollmentConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.video.CreateEnrollmentRequest.config)
}
inline ::sensory::api::v1::video::CreateEnrollmentConfig* CreateEnrollmentRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::video::CreateEnrollmentConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::video::CreateEnrollmentConfig* CreateEnrollmentRequest::mutable_config() {
  ::sensory::api::v1::video::CreateEnrollmentConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentRequest.config)
  return _msg;
}

// bytes imageContent = 2;
inline bool CreateEnrollmentRequest::_internal_has_imagecontent() const {
  return streamingRequest_case() == kImageContent;
}
inline bool CreateEnrollmentRequest::has_imagecontent() const {
  return _internal_has_imagecontent();
}
inline void CreateEnrollmentRequest::set_has_imagecontent() {
  _oneof_case_[0] = kImageContent;
}
inline void CreateEnrollmentRequest::clear_imagecontent() {
  if (_internal_has_imagecontent()) {
    streamingRequest_.imagecontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& CreateEnrollmentRequest::imagecontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentRequest.imageContent)
  return _internal_imagecontent();
}
template <typename ArgT0, typename... ArgT>
inline void CreateEnrollmentRequest::set_imagecontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.imagecontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentRequest.imageContent)
}
inline std::string* CreateEnrollmentRequest::mutable_imagecontent() {
  std::string* _s = _internal_mutable_imagecontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentRequest.imageContent)
  return _s;
}
inline const std::string& CreateEnrollmentRequest::_internal_imagecontent() const {
  if (_internal_has_imagecontent()) {
    return streamingRequest_.imagecontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateEnrollmentRequest::_internal_set_imagecontent(const std::string& value) {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.imagecontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentRequest::_internal_mutable_imagecontent() {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.imagecontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentRequest::release_imagecontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentRequest.imageContent)
  if (_internal_has_imagecontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.imagecontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void CreateEnrollmentRequest::set_allocated_imagecontent(std::string* imagecontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (imagecontent != nullptr) {
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(imagecontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(imagecontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentRequest.imageContent)
}

inline bool CreateEnrollmentRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void CreateEnrollmentRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline CreateEnrollmentRequest::StreamingRequestCase CreateEnrollmentRequest::streamingRequest_case() const {
  return CreateEnrollmentRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateRequest

// .sensory.api.v1.video.AuthenticateConfig config = 1;
inline bool AuthenticateRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool AuthenticateRequest::has_config() const {
  return _internal_has_config();
}
inline void AuthenticateRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void AuthenticateRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::video::AuthenticateConfig* AuthenticateRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.AuthenticateRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::video::AuthenticateConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::video::AuthenticateConfig& AuthenticateRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::video::AuthenticateConfig&>(::sensory::api::v1::video::_AuthenticateConfig_default_instance_);
}
inline const ::sensory::api::v1::video::AuthenticateConfig& AuthenticateRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::video::AuthenticateConfig* AuthenticateRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.video.AuthenticateRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::video::AuthenticateConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthenticateRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::video::AuthenticateConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.video.AuthenticateRequest.config)
}
inline ::sensory::api::v1::video::AuthenticateConfig* AuthenticateRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::video::AuthenticateConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::video::AuthenticateConfig* AuthenticateRequest::mutable_config() {
  ::sensory::api::v1::video::AuthenticateConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.AuthenticateRequest.config)
  return _msg;
}

// bytes imageContent = 2;
inline bool AuthenticateRequest::_internal_has_imagecontent() const {
  return streamingRequest_case() == kImageContent;
}
inline bool AuthenticateRequest::has_imagecontent() const {
  return _internal_has_imagecontent();
}
inline void AuthenticateRequest::set_has_imagecontent() {
  _oneof_case_[0] = kImageContent;
}
inline void AuthenticateRequest::clear_imagecontent() {
  if (_internal_has_imagecontent()) {
    streamingRequest_.imagecontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& AuthenticateRequest::imagecontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateRequest.imageContent)
  return _internal_imagecontent();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateRequest::set_imagecontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.imagecontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateRequest.imageContent)
}
inline std::string* AuthenticateRequest::mutable_imagecontent() {
  std::string* _s = _internal_mutable_imagecontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.AuthenticateRequest.imageContent)
  return _s;
}
inline const std::string& AuthenticateRequest::_internal_imagecontent() const {
  if (_internal_has_imagecontent()) {
    return streamingRequest_.imagecontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::_internal_set_imagecontent(const std::string& value) {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.imagecontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::_internal_mutable_imagecontent() {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.imagecontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::release_imagecontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.AuthenticateRequest.imageContent)
  if (_internal_has_imagecontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.imagecontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void AuthenticateRequest::set_allocated_imagecontent(std::string* imagecontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (imagecontent != nullptr) {
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(imagecontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(imagecontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.AuthenticateRequest.imageContent)
}

inline bool AuthenticateRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void AuthenticateRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline AuthenticateRequest::StreamingRequestCase AuthenticateRequest::streamingRequest_case() const {
  return AuthenticateRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidateRecognitionRequest

// .sensory.api.v1.video.ValidateRecognitionConfig config = 1;
inline bool ValidateRecognitionRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool ValidateRecognitionRequest::has_config() const {
  return _internal_has_config();
}
inline void ValidateRecognitionRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void ValidateRecognitionRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::video::ValidateRecognitionConfig* ValidateRecognitionRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.ValidateRecognitionRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::video::ValidateRecognitionConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::video::ValidateRecognitionConfig& ValidateRecognitionRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::video::ValidateRecognitionConfig&>(::sensory::api::v1::video::_ValidateRecognitionConfig_default_instance_);
}
inline const ::sensory::api::v1::video::ValidateRecognitionConfig& ValidateRecognitionRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.ValidateRecognitionRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::video::ValidateRecognitionConfig* ValidateRecognitionRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.video.ValidateRecognitionRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::video::ValidateRecognitionConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValidateRecognitionRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::video::ValidateRecognitionConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.video.ValidateRecognitionRequest.config)
}
inline ::sensory::api::v1::video::ValidateRecognitionConfig* ValidateRecognitionRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::video::ValidateRecognitionConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::video::ValidateRecognitionConfig* ValidateRecognitionRequest::mutable_config() {
  ::sensory::api::v1::video::ValidateRecognitionConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.ValidateRecognitionRequest.config)
  return _msg;
}

// bytes imageContent = 2;
inline bool ValidateRecognitionRequest::_internal_has_imagecontent() const {
  return streamingRequest_case() == kImageContent;
}
inline bool ValidateRecognitionRequest::has_imagecontent() const {
  return _internal_has_imagecontent();
}
inline void ValidateRecognitionRequest::set_has_imagecontent() {
  _oneof_case_[0] = kImageContent;
}
inline void ValidateRecognitionRequest::clear_imagecontent() {
  if (_internal_has_imagecontent()) {
    streamingRequest_.imagecontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& ValidateRecognitionRequest::imagecontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.ValidateRecognitionRequest.imageContent)
  return _internal_imagecontent();
}
template <typename ArgT0, typename... ArgT>
inline void ValidateRecognitionRequest::set_imagecontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.imagecontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.ValidateRecognitionRequest.imageContent)
}
inline std::string* ValidateRecognitionRequest::mutable_imagecontent() {
  std::string* _s = _internal_mutable_imagecontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.ValidateRecognitionRequest.imageContent)
  return _s;
}
inline const std::string& ValidateRecognitionRequest::_internal_imagecontent() const {
  if (_internal_has_imagecontent()) {
    return streamingRequest_.imagecontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValidateRecognitionRequest::_internal_set_imagecontent(const std::string& value) {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.imagecontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateRecognitionRequest::_internal_mutable_imagecontent() {
  if (!_internal_has_imagecontent()) {
    clear_streamingRequest();
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.imagecontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateRecognitionRequest::release_imagecontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.ValidateRecognitionRequest.imageContent)
  if (_internal_has_imagecontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.imagecontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ValidateRecognitionRequest::set_allocated_imagecontent(std::string* imagecontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (imagecontent != nullptr) {
    set_has_imagecontent();
    streamingRequest_.imagecontent_.UnsafeSetDefault(imagecontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(imagecontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.ValidateRecognitionRequest.imageContent)
}

inline bool ValidateRecognitionRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void ValidateRecognitionRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline ValidateRecognitionRequest::StreamingRequestCase ValidateRecognitionRequest::streamingRequest_case() const {
  return ValidateRecognitionRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateEnrollmentResponse

// int64 percentComplete = 1;
inline void CreateEnrollmentResponse::clear_percentcomplete() {
  percentcomplete_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::_internal_percentcomplete() const {
  return percentcomplete_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::percentcomplete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentResponse.percentComplete)
  return _internal_percentcomplete();
}
inline void CreateEnrollmentResponse::_internal_set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  percentcomplete_ = value;
}
inline void CreateEnrollmentResponse::set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_percentcomplete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentResponse.percentComplete)
}

// bool isAlive = 2;
inline void CreateEnrollmentResponse::clear_isalive() {
  isalive_ = false;
}
inline bool CreateEnrollmentResponse::_internal_isalive() const {
  return isalive_;
}
inline bool CreateEnrollmentResponse::isalive() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentResponse.isAlive)
  return _internal_isalive();
}
inline void CreateEnrollmentResponse::_internal_set_isalive(bool value) {
  
  isalive_ = value;
}
inline void CreateEnrollmentResponse::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentResponse.isAlive)
}

// string enrollmentId = 3;
inline void CreateEnrollmentResponse::clear_enrollmentid() {
  enrollmentid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentResponse.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
 
 enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentResponse.enrollmentId)
}
inline std::string* CreateEnrollmentResponse::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentResponse.enrollmentId)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_enrollmentid() const {
  return enrollmentid_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_enrollmentid(const std::string& value) {
  
  enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_enrollmentid() {
  
  return enrollmentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentResponse.enrollmentId)
  return enrollmentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (enrollmentid != nullptr) {
    
  } else {
    
  }
  enrollmentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentResponse.enrollmentId)
}

// string modelName = 4;
inline void CreateEnrollmentResponse::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentResponse.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentResponse.modelName)
}
inline std::string* CreateEnrollmentResponse::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentResponse.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentResponse.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentResponse.modelName)
}

// string modelVersion = 5;
inline void CreateEnrollmentResponse::clear_modelversion() {
  modelversion_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelversion() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentResponse.modelVersion)
  return _internal_modelversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelversion(ArgT0&& arg0, ArgT... args) {
 
 modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentResponse.modelVersion)
}
inline std::string* CreateEnrollmentResponse::mutable_modelversion() {
  std::string* _s = _internal_mutable_modelversion();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentResponse.modelVersion)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelversion() const {
  return modelversion_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelversion(const std::string& value) {
  
  modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelversion() {
  
  return modelversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelversion() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentResponse.modelVersion)
  return modelversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelversion(std::string* modelversion) {
  if (modelversion != nullptr) {
    
  } else {
    
  }
  modelversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentResponse.modelVersion)
}

// -------------------------------------------------------------------

// AuthenticateResponse

// bool success = 1;
inline void AuthenticateResponse::clear_success() {
  success_ = false;
}
inline bool AuthenticateResponse::_internal_success() const {
  return success_;
}
inline bool AuthenticateResponse::success() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateResponse.success)
  return _internal_success();
}
inline void AuthenticateResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AuthenticateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateResponse.success)
}

// float score = 2;
inline void AuthenticateResponse::clear_score() {
  score_ = 0;
}
inline float AuthenticateResponse::_internal_score() const {
  return score_;
}
inline float AuthenticateResponse::score() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateResponse.score)
  return _internal_score();
}
inline void AuthenticateResponse::_internal_set_score(float value) {
  
  score_ = value;
}
inline void AuthenticateResponse::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateResponse.score)
}

// bool isAlive = 3;
inline void AuthenticateResponse::clear_isalive() {
  isalive_ = false;
}
inline bool AuthenticateResponse::_internal_isalive() const {
  return isalive_;
}
inline bool AuthenticateResponse::isalive() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateResponse.isAlive)
  return _internal_isalive();
}
inline void AuthenticateResponse::_internal_set_isalive(bool value) {
  
  isalive_ = value;
}
inline void AuthenticateResponse::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateResponse.isAlive)
}

// .sensory.api.common.TokenResponse token = 4;
inline bool AuthenticateResponse::_internal_has_token() const {
  return this != internal_default_instance() && token_ != nullptr;
}
inline bool AuthenticateResponse::has_token() const {
  return _internal_has_token();
}
inline const ::sensory::api::common::TokenResponse& AuthenticateResponse::_internal_token() const {
  const ::sensory::api::common::TokenResponse* p = token_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::TokenResponse&>(
      ::sensory::api::common::_TokenResponse_default_instance_);
}
inline const ::sensory::api::common::TokenResponse& AuthenticateResponse::token() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateResponse.token)
  return _internal_token();
}
inline void AuthenticateResponse::unsafe_arena_set_allocated_token(
    ::sensory::api::common::TokenResponse* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  token_ = token;
  if (token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.video.AuthenticateResponse.token)
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::release_token() {
  
  ::sensory::api::common::TokenResponse* temp = token_;
  token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.AuthenticateResponse.token)
  
  ::sensory::api::common::TokenResponse* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::_internal_mutable_token() {
  
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::TokenResponse>(GetArenaForAllocation());
    token_ = p;
  }
  return token_;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::mutable_token() {
  ::sensory::api::common::TokenResponse* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.AuthenticateResponse.token)
  return _msg;
}
inline void AuthenticateResponse::set_allocated_token(::sensory::api::common::TokenResponse* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token));
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.AuthenticateResponse.token)
}

// -------------------------------------------------------------------

// LivenessRecognitionResponse

// bool isAlive = 1;
inline void LivenessRecognitionResponse::clear_isalive() {
  isalive_ = false;
}
inline bool LivenessRecognitionResponse::_internal_isalive() const {
  return isalive_;
}
inline bool LivenessRecognitionResponse::isalive() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.LivenessRecognitionResponse.isAlive)
  return _internal_isalive();
}
inline void LivenessRecognitionResponse::_internal_set_isalive(bool value) {
  
  isalive_ = value;
}
inline void LivenessRecognitionResponse::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.LivenessRecognitionResponse.isAlive)
}

// float score = 2;
inline void LivenessRecognitionResponse::clear_score() {
  score_ = 0;
}
inline float LivenessRecognitionResponse::_internal_score() const {
  return score_;
}
inline float LivenessRecognitionResponse::score() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.LivenessRecognitionResponse.score)
  return _internal_score();
}
inline void LivenessRecognitionResponse::_internal_set_score(float value) {
  
  score_ = value;
}
inline void LivenessRecognitionResponse::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.LivenessRecognitionResponse.score)
}

// -------------------------------------------------------------------

// CreateEnrollmentConfig

// string userId = 1 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentConfig.userId)
}
inline std::string* CreateEnrollmentConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentConfig.userId)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_userid() const {
  return userid_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentConfig.userId)
}

// string deviceId = 2 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::deviceid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentConfig.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentConfig.deviceId)
}
inline std::string* CreateEnrollmentConfig::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentConfig.deviceId)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_deviceid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentConfig.deviceId)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentConfig.deviceId)
}

// string modelName = 3 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentConfig.modelName)
}
inline std::string* CreateEnrollmentConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentConfig.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentConfig.modelName)
}

// string description = 4 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentConfig.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentConfig.description)
}
inline std::string* CreateEnrollmentConfig::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentConfig.description)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_description() const {
  return description_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentConfig.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentConfig.description)
}

// bool isLivenessEnabled = 5;
inline void CreateEnrollmentConfig::clear_islivenessenabled() {
  islivenessenabled_ = false;
}
inline bool CreateEnrollmentConfig::_internal_islivenessenabled() const {
  return islivenessenabled_;
}
inline bool CreateEnrollmentConfig::islivenessenabled() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentConfig.isLivenessEnabled)
  return _internal_islivenessenabled();
}
inline void CreateEnrollmentConfig::_internal_set_islivenessenabled(bool value) {
  
  islivenessenabled_ = value;
}
inline void CreateEnrollmentConfig::set_islivenessenabled(bool value) {
  _internal_set_islivenessenabled(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentConfig.isLivenessEnabled)
}

// .sensory.api.v1.video.RecognitionThreshold livenessThreshold = 6 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_livenessthreshold() {
  livenessthreshold_ = 0;
}
inline ::sensory::api::v1::video::RecognitionThreshold CreateEnrollmentConfig::_internal_livenessthreshold() const {
  return static_cast< ::sensory::api::v1::video::RecognitionThreshold >(livenessthreshold_);
}
inline ::sensory::api::v1::video::RecognitionThreshold CreateEnrollmentConfig::livenessthreshold() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentConfig.livenessThreshold)
  return _internal_livenessthreshold();
}
inline void CreateEnrollmentConfig::_internal_set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value) {
  
  livenessthreshold_ = value;
}
inline void CreateEnrollmentConfig::set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value) {
  _internal_set_livenessthreshold(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.CreateEnrollmentConfig.livenessThreshold)
}

// .sensory.api.common.CompressionConfiguration compression = 7;
inline bool CreateEnrollmentConfig::_internal_has_compression() const {
  return this != internal_default_instance() && compression_ != nullptr;
}
inline bool CreateEnrollmentConfig::has_compression() const {
  return _internal_has_compression();
}
inline const ::sensory::api::common::CompressionConfiguration& CreateEnrollmentConfig::_internal_compression() const {
  const ::sensory::api::common::CompressionConfiguration* p = compression_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::CompressionConfiguration&>(
      ::sensory::api::common::_CompressionConfiguration_default_instance_);
}
inline const ::sensory::api::common::CompressionConfiguration& CreateEnrollmentConfig::compression() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.CreateEnrollmentConfig.compression)
  return _internal_compression();
}
inline void CreateEnrollmentConfig::unsafe_arena_set_allocated_compression(
    ::sensory::api::common::CompressionConfiguration* compression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression_);
  }
  compression_ = compression;
  if (compression) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.video.CreateEnrollmentConfig.compression)
}
inline ::sensory::api::common::CompressionConfiguration* CreateEnrollmentConfig::release_compression() {
  
  ::sensory::api::common::CompressionConfiguration* temp = compression_;
  compression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::CompressionConfiguration* CreateEnrollmentConfig::unsafe_arena_release_compression() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.CreateEnrollmentConfig.compression)
  
  ::sensory::api::common::CompressionConfiguration* temp = compression_;
  compression_ = nullptr;
  return temp;
}
inline ::sensory::api::common::CompressionConfiguration* CreateEnrollmentConfig::_internal_mutable_compression() {
  
  if (compression_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::CompressionConfiguration>(GetArenaForAllocation());
    compression_ = p;
  }
  return compression_;
}
inline ::sensory::api::common::CompressionConfiguration* CreateEnrollmentConfig::mutable_compression() {
  ::sensory::api::common::CompressionConfiguration* _msg = _internal_mutable_compression();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.CreateEnrollmentConfig.compression)
  return _msg;
}
inline void CreateEnrollmentConfig::set_allocated_compression(::sensory::api::common::CompressionConfiguration* compression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression_);
  }
  if (compression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression));
    if (message_arena != submessage_arena) {
      compression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compression, submessage_arena);
    }
    
  } else {
    
  }
  compression_ = compression;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.CreateEnrollmentConfig.compression)
}

// -------------------------------------------------------------------

// AuthenticateConfig

// string enrollmentId = 1 [(.validate.rules) = {
inline void AuthenticateConfig::clear_enrollmentid() {
  enrollmentid_.ClearToEmpty();
}
inline const std::string& AuthenticateConfig::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateConfig.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateConfig::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
 
 enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateConfig.enrollmentId)
}
inline std::string* AuthenticateConfig::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.AuthenticateConfig.enrollmentId)
  return _s;
}
inline const std::string& AuthenticateConfig::_internal_enrollmentid() const {
  return enrollmentid_.Get();
}
inline void AuthenticateConfig::_internal_set_enrollmentid(const std::string& value) {
  
  enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::_internal_mutable_enrollmentid() {
  
  return enrollmentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.AuthenticateConfig.enrollmentId)
  return enrollmentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateConfig::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (enrollmentid != nullptr) {
    
  } else {
    
  }
  enrollmentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.AuthenticateConfig.enrollmentId)
}

// bool isLivenessEnabled = 2;
inline void AuthenticateConfig::clear_islivenessenabled() {
  islivenessenabled_ = false;
}
inline bool AuthenticateConfig::_internal_islivenessenabled() const {
  return islivenessenabled_;
}
inline bool AuthenticateConfig::islivenessenabled() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateConfig.isLivenessEnabled)
  return _internal_islivenessenabled();
}
inline void AuthenticateConfig::_internal_set_islivenessenabled(bool value) {
  
  islivenessenabled_ = value;
}
inline void AuthenticateConfig::set_islivenessenabled(bool value) {
  _internal_set_islivenessenabled(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateConfig.isLivenessEnabled)
}

// .sensory.api.v1.video.RecognitionThreshold livenessThreshold = 3 [(.validate.rules) = {
inline void AuthenticateConfig::clear_livenessthreshold() {
  livenessthreshold_ = 0;
}
inline ::sensory::api::v1::video::RecognitionThreshold AuthenticateConfig::_internal_livenessthreshold() const {
  return static_cast< ::sensory::api::v1::video::RecognitionThreshold >(livenessthreshold_);
}
inline ::sensory::api::v1::video::RecognitionThreshold AuthenticateConfig::livenessthreshold() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateConfig.livenessThreshold)
  return _internal_livenessthreshold();
}
inline void AuthenticateConfig::_internal_set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value) {
  
  livenessthreshold_ = value;
}
inline void AuthenticateConfig::set_livenessthreshold(::sensory::api::v1::video::RecognitionThreshold value) {
  _internal_set_livenessthreshold(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateConfig.livenessThreshold)
}

// .sensory.api.common.CompressionConfiguration compression = 4;
inline bool AuthenticateConfig::_internal_has_compression() const {
  return this != internal_default_instance() && compression_ != nullptr;
}
inline bool AuthenticateConfig::has_compression() const {
  return _internal_has_compression();
}
inline const ::sensory::api::common::CompressionConfiguration& AuthenticateConfig::_internal_compression() const {
  const ::sensory::api::common::CompressionConfiguration* p = compression_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::CompressionConfiguration&>(
      ::sensory::api::common::_CompressionConfiguration_default_instance_);
}
inline const ::sensory::api::common::CompressionConfiguration& AuthenticateConfig::compression() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateConfig.compression)
  return _internal_compression();
}
inline void AuthenticateConfig::unsafe_arena_set_allocated_compression(
    ::sensory::api::common::CompressionConfiguration* compression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression_);
  }
  compression_ = compression;
  if (compression) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.video.AuthenticateConfig.compression)
}
inline ::sensory::api::common::CompressionConfiguration* AuthenticateConfig::release_compression() {
  
  ::sensory::api::common::CompressionConfiguration* temp = compression_;
  compression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::CompressionConfiguration* AuthenticateConfig::unsafe_arena_release_compression() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.AuthenticateConfig.compression)
  
  ::sensory::api::common::CompressionConfiguration* temp = compression_;
  compression_ = nullptr;
  return temp;
}
inline ::sensory::api::common::CompressionConfiguration* AuthenticateConfig::_internal_mutable_compression() {
  
  if (compression_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::CompressionConfiguration>(GetArenaForAllocation());
    compression_ = p;
  }
  return compression_;
}
inline ::sensory::api::common::CompressionConfiguration* AuthenticateConfig::mutable_compression() {
  ::sensory::api::common::CompressionConfiguration* _msg = _internal_mutable_compression();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.AuthenticateConfig.compression)
  return _msg;
}
inline void AuthenticateConfig::set_allocated_compression(::sensory::api::common::CompressionConfiguration* compression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression_);
  }
  if (compression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression));
    if (message_arena != submessage_arena) {
      compression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compression, submessage_arena);
    }
    
  } else {
    
  }
  compression_ = compression;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.AuthenticateConfig.compression)
}

// bool doIncludeToken = 5;
inline void AuthenticateConfig::clear_doincludetoken() {
  doincludetoken_ = false;
}
inline bool AuthenticateConfig::_internal_doincludetoken() const {
  return doincludetoken_;
}
inline bool AuthenticateConfig::doincludetoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.AuthenticateConfig.doIncludeToken)
  return _internal_doincludetoken();
}
inline void AuthenticateConfig::_internal_set_doincludetoken(bool value) {
  
  doincludetoken_ = value;
}
inline void AuthenticateConfig::set_doincludetoken(bool value) {
  _internal_set_doincludetoken(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.AuthenticateConfig.doIncludeToken)
}

// -------------------------------------------------------------------

// ValidateRecognitionConfig

// string modelName = 1 [(.validate.rules) = {
inline void ValidateRecognitionConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& ValidateRecognitionConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.ValidateRecognitionConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateRecognitionConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.ValidateRecognitionConfig.modelName)
}
inline std::string* ValidateRecognitionConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.ValidateRecognitionConfig.modelName)
  return _s;
}
inline const std::string& ValidateRecognitionConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void ValidateRecognitionConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateRecognitionConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateRecognitionConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.ValidateRecognitionConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateRecognitionConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.ValidateRecognitionConfig.modelName)
}

// string userId = 2 [(.validate.rules) = {
inline void ValidateRecognitionConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& ValidateRecognitionConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.ValidateRecognitionConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateRecognitionConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.ValidateRecognitionConfig.userId)
}
inline std::string* ValidateRecognitionConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.video.ValidateRecognitionConfig.userId)
  return _s;
}
inline const std::string& ValidateRecognitionConfig::_internal_userid() const {
  return userid_.Get();
}
inline void ValidateRecognitionConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateRecognitionConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateRecognitionConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.video.ValidateRecognitionConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateRecognitionConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.video.ValidateRecognitionConfig.userId)
}

// .sensory.api.v1.video.RecognitionThreshold threshold = 3 [(.validate.rules) = {
inline void ValidateRecognitionConfig::clear_threshold() {
  threshold_ = 0;
}
inline ::sensory::api::v1::video::RecognitionThreshold ValidateRecognitionConfig::_internal_threshold() const {
  return static_cast< ::sensory::api::v1::video::RecognitionThreshold >(threshold_);
}
inline ::sensory::api::v1::video::RecognitionThreshold ValidateRecognitionConfig::threshold() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.video.ValidateRecognitionConfig.threshold)
  return _internal_threshold();
}
inline void ValidateRecognitionConfig::_internal_set_threshold(::sensory::api::v1::video::RecognitionThreshold value) {
  
  threshold_ = value;
}
inline void ValidateRecognitionConfig::set_threshold(::sensory::api::v1::video::RecognitionThreshold value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.video.ValidateRecognitionConfig.threshold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace video
}  // namespace v1
}  // namespace api
}  // namespace sensory

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensory::api::v1::video::RecognitionThreshold> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::video::RecognitionThreshold>() {
  return ::sensory::api::v1::video::RecognitionThreshold_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_v1_2fvideo_2fvideo_2eproto
