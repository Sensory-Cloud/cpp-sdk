// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sensorycloud/protoc/validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2fcommon_2eproto;
namespace sensory {
namespace api {
namespace common {
class CompressionConfiguration;
struct CompressionConfigurationDefaultTypeInternal;
extern CompressionConfigurationDefaultTypeInternal _CompressionConfiguration_default_instance_;
class CpuSummary;
struct CpuSummaryDefaultTypeInternal;
extern CpuSummaryDefaultTypeInternal _CpuSummary_default_instance_;
class MemorySummary;
struct MemorySummaryDefaultTypeInternal;
extern MemorySummaryDefaultTypeInternal _MemorySummary_default_instance_;
class ServerHealthResponse;
struct ServerHealthResponseDefaultTypeInternal;
extern ServerHealthResponseDefaultTypeInternal _ServerHealthResponse_default_instance_;
class ServiceHealth;
struct ServiceHealthDefaultTypeInternal;
extern ServiceHealthDefaultTypeInternal _ServiceHealth_default_instance_;
class SystemSummary;
struct SystemSummaryDefaultTypeInternal;
extern SystemSummaryDefaultTypeInternal _SystemSummary_default_instance_;
class TokenResponse;
struct TokenResponseDefaultTypeInternal;
extern TokenResponseDefaultTypeInternal _TokenResponse_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::common::CompressionConfiguration* Arena::CreateMaybeMessage<::sensory::api::common::CompressionConfiguration>(Arena*);
template<> ::sensory::api::common::CpuSummary* Arena::CreateMaybeMessage<::sensory::api::common::CpuSummary>(Arena*);
template<> ::sensory::api::common::MemorySummary* Arena::CreateMaybeMessage<::sensory::api::common::MemorySummary>(Arena*);
template<> ::sensory::api::common::ServerHealthResponse* Arena::CreateMaybeMessage<::sensory::api::common::ServerHealthResponse>(Arena*);
template<> ::sensory::api::common::ServiceHealth* Arena::CreateMaybeMessage<::sensory::api::common::ServiceHealth>(Arena*);
template<> ::sensory::api::common::SystemSummary* Arena::CreateMaybeMessage<::sensory::api::common::SystemSummary>(Arena*);
template<> ::sensory::api::common::TokenResponse* Arena::CreateMaybeMessage<::sensory::api::common::TokenResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace common {

enum KeyType : int {
  PUBLIC_KEY = 0,
  PUBLIC_KEY_ED25519 = 1,
  SHARED_SECRET = 3,
  KeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KeyType_IsValid(int value);
constexpr KeyType KeyType_MIN = PUBLIC_KEY;
constexpr KeyType KeyType_MAX = SHARED_SECRET;
constexpr int KeyType_ARRAYSIZE = KeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyType_descriptor();
template<typename T>
inline const std::string& KeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyType_descriptor(), enum_t_value);
}
inline bool KeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyType>(
    KeyType_descriptor(), name, value);
}
enum ModelType : int {
  VOICE_BIOMETRIC_TEXT_DEPENDENT = 0,
  VOICE_BIOMETRIC_TEXT_INDEPENDENT = 1,
  VOICE_BIOMETRIC_WAKEWORD = 2,
  VOICE_EVENT_WAKEWORD = 3,
  VOICE_TRANSCRIBE_GRAMMAR = 4,
  VOICE_TRANSCRIBE_COMMAND_AND_SEARCH = 5,
  VOICE_RECOGNITION_ACTIVITY_DETECTION = 6,
  VOICE_FEATURE_EXTRACTOR = 7,
  VOICE_BIOMETRIC_LIVENESS_DIGIT = 8,
  SOUND_EVENT_ENROLLABLE = 100,
  SOUND_EVENT_REVALIDATION = 101,
  SOUND_EVENT_FIXED = 102,
  SOUND_SCENE_FIXED = 103,
  FACE_BIOMETRIC = 201,
  FACE_RECOGNITION = 202,
  OBJECT_RECOGNITION = 203,
  IMAGE_TRANSFORM = 204,
  UNKNOWN = 1000,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = VOICE_BIOMETRIC_TEXT_DEPENDENT;
constexpr ModelType ModelType_MAX = UNKNOWN;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelType_descriptor();
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelType_descriptor(), enum_t_value);
}
inline bool ModelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelType>(
    ModelType_descriptor(), name, value);
}
enum TechnologyType : int {
  NOT_SET = 0,
  TSSV = 1,
  TS = 2,
  TNL = 3,
  TechnologyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TechnologyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TechnologyType_IsValid(int value);
constexpr TechnologyType TechnologyType_MIN = NOT_SET;
constexpr TechnologyType TechnologyType_MAX = TNL;
constexpr int TechnologyType_ARRAYSIZE = TechnologyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TechnologyType_descriptor();
template<typename T>
inline const std::string& TechnologyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TechnologyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TechnologyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TechnologyType_descriptor(), enum_t_value);
}
inline bool TechnologyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TechnologyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TechnologyType>(
    TechnologyType_descriptor(), name, value);
}
enum CompressionType : int {
  IMAGE_GRAYSCALE = 0,
  CompressionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CompressionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = IMAGE_GRAYSCALE;
constexpr CompressionType CompressionType_MAX = IMAGE_GRAYSCALE;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionType_descriptor();
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompressionType_descriptor(), enum_t_value);
}
inline bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressionType>(
    CompressionType_descriptor(), name, value);
}
enum ClientType : int {
  ROOT = 0,
  DEVICE = 1,
  CLUSTER = 2,
  USER = 3,
  ClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = ROOT;
constexpr ClientType ClientType_MAX = USER;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientType_descriptor();
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientType_descriptor(), enum_t_value);
}
inline bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum UsageEventType : int {
  AUTHENTICATION = 0,
  RECOGNITION = 1,
  ENROLLMENT = 2,
  UsageEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UsageEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UsageEventType_IsValid(int value);
constexpr UsageEventType UsageEventType_MIN = AUTHENTICATION;
constexpr UsageEventType UsageEventType_MAX = ENROLLMENT;
constexpr int UsageEventType_ARRAYSIZE = UsageEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsageEventType_descriptor();
template<typename T>
inline const std::string& UsageEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsageEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsageEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsageEventType_descriptor(), enum_t_value);
}
inline bool UsageEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UsageEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsageEventType>(
    UsageEventType_descriptor(), name, value);
}
// ===================================================================

class CompressionConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.CompressionConfiguration) */ {
 public:
  inline CompressionConfiguration() : CompressionConfiguration(nullptr) {}
  ~CompressionConfiguration() override;
  explicit constexpr CompressionConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressionConfiguration(const CompressionConfiguration& from);
  CompressionConfiguration(CompressionConfiguration&& from) noexcept
    : CompressionConfiguration() {
    *this = ::std::move(from);
  }

  inline CompressionConfiguration& operator=(const CompressionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressionConfiguration& operator=(CompressionConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressionConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressionConfiguration* internal_default_instance() {
    return reinterpret_cast<const CompressionConfiguration*>(
               &_CompressionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CompressionConfiguration& a, CompressionConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressionConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressionConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompressionConfiguration* New() const final {
    return new CompressionConfiguration();
  }

  CompressionConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompressionConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressionConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompressionConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressionConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.CompressionConfiguration";
  }
  protected:
  explicit CompressionConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressionsFieldNumber = 1,
  };
  // repeated .sensory.api.common.CompressionType compressions = 1;
  int compressions_size() const;
  private:
  int _internal_compressions_size() const;
  public:
  void clear_compressions();
  private:
  ::sensory::api::common::CompressionType _internal_compressions(int index) const;
  void _internal_add_compressions(::sensory::api::common::CompressionType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_compressions();
  public:
  ::sensory::api::common::CompressionType compressions(int index) const;
  void set_compressions(int index, ::sensory::api::common::CompressionType value);
  void add_compressions(::sensory::api::common::CompressionType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& compressions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_compressions();

  // @@protoc_insertion_point(class_scope:sensory.api.common.CompressionConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> compressions_;
  mutable std::atomic<int> _compressions_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.TokenResponse) */ {
 public:
  inline TokenResponse() : TokenResponse(nullptr) {}
  ~TokenResponse() override;
  explicit constexpr TokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenResponse(const TokenResponse& from);
  TokenResponse(TokenResponse&& from) noexcept
    : TokenResponse() {
    *this = ::std::move(from);
  }

  inline TokenResponse& operator=(const TokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenResponse& operator=(TokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenResponse* internal_default_instance() {
    return reinterpret_cast<const TokenResponse*>(
               &_TokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TokenResponse& a, TokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TokenResponse* New() const final {
    return new TokenResponse();
  }

  TokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TokenResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.TokenResponse";
  }
  protected:
  explicit TokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 1,
    kKeyIdFieldNumber = 3,
    kTokenTypeFieldNumber = 4,
    kExpiresInFieldNumber = 2,
  };
  // string accessToken = 1;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_MUST_USE_RESULT std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // string keyId = 3;
  void clear_keyid();
  const std::string& keyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyid();
  PROTOBUF_MUST_USE_RESULT std::string* release_keyid();
  void set_allocated_keyid(std::string* keyid);
  private:
  const std::string& _internal_keyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyid(const std::string& value);
  std::string* _internal_mutable_keyid();
  public:

  // string tokenType = 4;
  void clear_tokentype();
  const std::string& tokentype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokentype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokentype();
  PROTOBUF_MUST_USE_RESULT std::string* release_tokentype();
  void set_allocated_tokentype(std::string* tokentype);
  private:
  const std::string& _internal_tokentype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokentype(const std::string& value);
  std::string* _internal_mutable_tokentype();
  public:

  // int32 expiresIn = 2;
  void clear_expiresin();
  ::PROTOBUF_NAMESPACE_ID::int32 expiresin() const;
  void set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_expiresin() const;
  void _internal_set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.TokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokentype_;
  ::PROTOBUF_NAMESPACE_ID::int32 expiresin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ServiceHealth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.ServiceHealth) */ {
 public:
  inline ServiceHealth() : ServiceHealth(nullptr) {}
  ~ServiceHealth() override;
  explicit constexpr ServiceHealth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceHealth(const ServiceHealth& from);
  ServiceHealth(ServiceHealth&& from) noexcept
    : ServiceHealth() {
    *this = ::std::move(from);
  }

  inline ServiceHealth& operator=(const ServiceHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceHealth& operator=(ServiceHealth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceHealth* internal_default_instance() {
    return reinterpret_cast<const ServiceHealth*>(
               &_ServiceHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServiceHealth& a, ServiceHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceHealth* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServiceHealth* New() const final {
    return new ServiceHealth();
  }

  ServiceHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServiceHealth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceHealth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceHealth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceHealth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.ServiceHealth";
  }
  protected:
  explicit ServiceHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kIsHealthyFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool isHealthy = 1;
  void clear_ishealthy();
  bool ishealthy() const;
  void set_ishealthy(bool value);
  private:
  bool _internal_ishealthy() const;
  void _internal_set_ishealthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.ServiceHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool ishealthy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ServerHealthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.ServerHealthResponse) */ {
 public:
  inline ServerHealthResponse() : ServerHealthResponse(nullptr) {}
  ~ServerHealthResponse() override;
  explicit constexpr ServerHealthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerHealthResponse(const ServerHealthResponse& from);
  ServerHealthResponse(ServerHealthResponse&& from) noexcept
    : ServerHealthResponse() {
    *this = ::std::move(from);
  }

  inline ServerHealthResponse& operator=(const ServerHealthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerHealthResponse& operator=(ServerHealthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerHealthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerHealthResponse* internal_default_instance() {
    return reinterpret_cast<const ServerHealthResponse*>(
               &_ServerHealthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServerHealthResponse& a, ServerHealthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerHealthResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerHealthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerHealthResponse* New() const final {
    return new ServerHealthResponse();
  }

  ServerHealthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerHealthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerHealthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerHealthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerHealthResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.ServerHealthResponse";
  }
  protected:
  explicit ServerHealthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 4,
    kServerVersionFieldNumber = 2,
    kIdFieldNumber = 3,
    kIsHealthyFieldNumber = 1,
  };
  // repeated .sensory.api.common.ServiceHealth services = 4;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::sensory::api::common::ServiceHealth* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >*
      mutable_services();
  private:
  const ::sensory::api::common::ServiceHealth& _internal_services(int index) const;
  ::sensory::api::common::ServiceHealth* _internal_add_services();
  public:
  const ::sensory::api::common::ServiceHealth& services(int index) const;
  ::sensory::api::common::ServiceHealth* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >&
      services() const;

  // string serverVersion = 2;
  void clear_serverversion();
  const std::string& serverversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_serverversion();
  void set_allocated_serverversion(std::string* serverversion);
  private:
  const std::string& _internal_serverversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverversion(const std::string& value);
  std::string* _internal_mutable_serverversion();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool isHealthy = 1;
  void clear_ishealthy();
  bool ishealthy() const;
  void set_ishealthy(bool value);
  private:
  bool _internal_ishealthy() const;
  void _internal_set_ishealthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.ServerHealthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth > services_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool ishealthy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SystemSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.SystemSummary) */ {
 public:
  inline SystemSummary() : SystemSummary(nullptr) {}
  ~SystemSummary() override;
  explicit constexpr SystemSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSummary(const SystemSummary& from);
  SystemSummary(SystemSummary&& from) noexcept
    : SystemSummary() {
    *this = ::std::move(from);
  }

  inline SystemSummary& operator=(const SystemSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSummary& operator=(SystemSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSummary* internal_default_instance() {
    return reinterpret_cast<const SystemSummary*>(
               &_SystemSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SystemSummary& a, SystemSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSummary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemSummary* New() const final {
    return new SystemSummary();
  }

  SystemSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SystemSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.SystemSummary";
  }
  protected:
  explicit SystemSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpuFieldNumber = 1,
    kMemoryFieldNumber = 2,
  };
  // .sensory.api.common.CpuSummary cpu = 1 [(.validate.rules) = {
  bool has_cpu() const;
  private:
  bool _internal_has_cpu() const;
  public:
  void clear_cpu();
  const ::sensory::api::common::CpuSummary& cpu() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::CpuSummary* release_cpu();
  ::sensory::api::common::CpuSummary* mutable_cpu();
  void set_allocated_cpu(::sensory::api::common::CpuSummary* cpu);
  private:
  const ::sensory::api::common::CpuSummary& _internal_cpu() const;
  ::sensory::api::common::CpuSummary* _internal_mutable_cpu();
  public:
  void unsafe_arena_set_allocated_cpu(
      ::sensory::api::common::CpuSummary* cpu);
  ::sensory::api::common::CpuSummary* unsafe_arena_release_cpu();

  // .sensory.api.common.MemorySummary memory = 2 [(.validate.rules) = {
  bool has_memory() const;
  private:
  bool _internal_has_memory() const;
  public:
  void clear_memory();
  const ::sensory::api::common::MemorySummary& memory() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::MemorySummary* release_memory();
  ::sensory::api::common::MemorySummary* mutable_memory();
  void set_allocated_memory(::sensory::api::common::MemorySummary* memory);
  private:
  const ::sensory::api::common::MemorySummary& _internal_memory() const;
  ::sensory::api::common::MemorySummary* _internal_mutable_memory();
  public:
  void unsafe_arena_set_allocated_memory(
      ::sensory::api::common::MemorySummary* memory);
  ::sensory::api::common::MemorySummary* unsafe_arena_release_memory();

  // @@protoc_insertion_point(class_scope:sensory.api.common.SystemSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensory::api::common::CpuSummary* cpu_;
  ::sensory::api::common::MemorySummary* memory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class CpuSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.CpuSummary) */ {
 public:
  inline CpuSummary() : CpuSummary(nullptr) {}
  ~CpuSummary() override;
  explicit constexpr CpuSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CpuSummary(const CpuSummary& from);
  CpuSummary(CpuSummary&& from) noexcept
    : CpuSummary() {
    *this = ::std::move(from);
  }

  inline CpuSummary& operator=(const CpuSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuSummary& operator=(CpuSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpuSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuSummary* internal_default_instance() {
    return reinterpret_cast<const CpuSummary*>(
               &_CpuSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CpuSummary& a, CpuSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuSummary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CpuSummary* New() const final {
    return new CpuSummary();
  }

  CpuSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CpuSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CpuSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CpuSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CpuSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.CpuSummary";
  }
  protected:
  explicit CpuSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kNiceFieldNumber = 2,
    kSystemFieldNumber = 3,
    kIdleFieldNumber = 4,
    kIoWaitFieldNumber = 5,
    kIrqFieldNumber = 6,
    kSoftIrqFieldNumber = 7,
    kStealFieldNumber = 8,
    kGuestFieldNumber = 9,
    kGuestNiceFieldNumber = 10,
  };
  // uint64 user = 1;
  void clear_user();
  ::PROTOBUF_NAMESPACE_ID::uint64 user() const;
  void set_user(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_user() const;
  void _internal_set_user(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 nice = 2;
  void clear_nice();
  ::PROTOBUF_NAMESPACE_ID::uint64 nice() const;
  void set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nice() const;
  void _internal_set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 system = 3;
  void clear_system();
  ::PROTOBUF_NAMESPACE_ID::uint64 system() const;
  void set_system(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_system() const;
  void _internal_set_system(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 idle = 4;
  void clear_idle();
  ::PROTOBUF_NAMESPACE_ID::uint64 idle() const;
  void set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_idle() const;
  void _internal_set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 ioWait = 5;
  void clear_iowait();
  ::PROTOBUF_NAMESPACE_ID::uint64 iowait() const;
  void set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_iowait() const;
  void _internal_set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 irq = 6;
  void clear_irq();
  ::PROTOBUF_NAMESPACE_ID::uint64 irq() const;
  void set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_irq() const;
  void _internal_set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 softIrq = 7;
  void clear_softirq();
  ::PROTOBUF_NAMESPACE_ID::uint64 softirq() const;
  void set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_softirq() const;
  void _internal_set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 steal = 8;
  void clear_steal();
  ::PROTOBUF_NAMESPACE_ID::uint64 steal() const;
  void set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_steal() const;
  void _internal_set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 guest = 9;
  void clear_guest();
  ::PROTOBUF_NAMESPACE_ID::uint64 guest() const;
  void set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_guest() const;
  void _internal_set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 guestNice = 10;
  void clear_guestnice();
  ::PROTOBUF_NAMESPACE_ID::uint64 guestnice() const;
  void set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_guestnice() const;
  void _internal_set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.CpuSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 user_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nice_;
  ::PROTOBUF_NAMESPACE_ID::uint64 system_;
  ::PROTOBUF_NAMESPACE_ID::uint64 idle_;
  ::PROTOBUF_NAMESPACE_ID::uint64 iowait_;
  ::PROTOBUF_NAMESPACE_ID::uint64 irq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 softirq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 steal_;
  ::PROTOBUF_NAMESPACE_ID::uint64 guest_;
  ::PROTOBUF_NAMESPACE_ID::uint64 guestnice_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class MemorySummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.MemorySummary) */ {
 public:
  inline MemorySummary() : MemorySummary(nullptr) {}
  ~MemorySummary() override;
  explicit constexpr MemorySummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemorySummary(const MemorySummary& from);
  MemorySummary(MemorySummary&& from) noexcept
    : MemorySummary() {
    *this = ::std::move(from);
  }

  inline MemorySummary& operator=(const MemorySummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemorySummary& operator=(MemorySummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemorySummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemorySummary* internal_default_instance() {
    return reinterpret_cast<const MemorySummary*>(
               &_MemorySummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MemorySummary& a, MemorySummary& b) {
    a.Swap(&b);
  }
  inline void Swap(MemorySummary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemorySummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MemorySummary* New() const final {
    return new MemorySummary();
  }

  MemorySummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemorySummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemorySummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemorySummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemorySummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.MemorySummary";
  }
  protected:
  explicit MemorySummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemTotalFieldNumber = 1,
    kMemFreeFieldNumber = 2,
    kMemAvailableFieldNumber = 3,
  };
  // uint64 memTotal = 1;
  void clear_memtotal();
  ::PROTOBUF_NAMESPACE_ID::uint64 memtotal() const;
  void set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memtotal() const;
  void _internal_set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 memFree = 2;
  void clear_memfree();
  ::PROTOBUF_NAMESPACE_ID::uint64 memfree() const;
  void set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memfree() const;
  void _internal_set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 memAvailable = 3;
  void clear_memavailable();
  ::PROTOBUF_NAMESPACE_ID::uint64 memavailable() const;
  void set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memavailable() const;
  void _internal_set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.MemorySummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memtotal_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memfree_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memavailable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CompressionConfiguration

// repeated .sensory.api.common.CompressionType compressions = 1;
inline int CompressionConfiguration::_internal_compressions_size() const {
  return compressions_.size();
}
inline int CompressionConfiguration::compressions_size() const {
  return _internal_compressions_size();
}
inline void CompressionConfiguration::clear_compressions() {
  compressions_.Clear();
}
inline ::sensory::api::common::CompressionType CompressionConfiguration::_internal_compressions(int index) const {
  return static_cast< ::sensory::api::common::CompressionType >(compressions_.Get(index));
}
inline ::sensory::api::common::CompressionType CompressionConfiguration::compressions(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CompressionConfiguration.compressions)
  return _internal_compressions(index);
}
inline void CompressionConfiguration::set_compressions(int index, ::sensory::api::common::CompressionType value) {
  compressions_.Set(index, value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CompressionConfiguration.compressions)
}
inline void CompressionConfiguration::_internal_add_compressions(::sensory::api::common::CompressionType value) {
  compressions_.Add(value);
}
inline void CompressionConfiguration::add_compressions(::sensory::api::common::CompressionType value) {
  _internal_add_compressions(value);
  // @@protoc_insertion_point(field_add:sensory.api.common.CompressionConfiguration.compressions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CompressionConfiguration::compressions() const {
  // @@protoc_insertion_point(field_list:sensory.api.common.CompressionConfiguration.compressions)
  return compressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CompressionConfiguration::_internal_mutable_compressions() {
  return &compressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CompressionConfiguration::mutable_compressions() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.common.CompressionConfiguration.compressions)
  return _internal_mutable_compressions();
}

// -------------------------------------------------------------------

// TokenResponse

// string accessToken = 1;
inline void TokenResponse::clear_accesstoken() {
  accesstoken_.ClearToEmpty();
}
inline const std::string& TokenResponse::accesstoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenResponse::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 accesstoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.accessToken)
}
inline std::string* TokenResponse::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TokenResponse.accessToken)
  return _s;
}
inline const std::string& TokenResponse::_internal_accesstoken() const {
  return accesstoken_.Get();
}
inline void TokenResponse::_internal_set_accesstoken(const std::string& value) {
  
  accesstoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenResponse::_internal_mutable_accesstoken() {
  
  return accesstoken_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenResponse::release_accesstoken() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TokenResponse.accessToken)
  return accesstoken_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenResponse::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  accesstoken_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), accesstoken,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TokenResponse.accessToken)
}

// int32 expiresIn = 2;
inline void TokenResponse::clear_expiresin() {
  expiresin_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TokenResponse::_internal_expiresin() const {
  return expiresin_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TokenResponse::expiresin() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.expiresIn)
  return _internal_expiresin();
}
inline void TokenResponse::_internal_set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  expiresin_ = value;
}
inline void TokenResponse::set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_expiresin(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.expiresIn)
}

// string keyId = 3;
inline void TokenResponse::clear_keyid() {
  keyid_.ClearToEmpty();
}
inline const std::string& TokenResponse::keyid() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.keyId)
  return _internal_keyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenResponse::set_keyid(ArgT0&& arg0, ArgT... args) {
 
 keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.keyId)
}
inline std::string* TokenResponse::mutable_keyid() {
  std::string* _s = _internal_mutable_keyid();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TokenResponse.keyId)
  return _s;
}
inline const std::string& TokenResponse::_internal_keyid() const {
  return keyid_.Get();
}
inline void TokenResponse::_internal_set_keyid(const std::string& value) {
  
  keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenResponse::_internal_mutable_keyid() {
  
  return keyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenResponse::release_keyid() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TokenResponse.keyId)
  return keyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenResponse::set_allocated_keyid(std::string* keyid) {
  if (keyid != nullptr) {
    
  } else {
    
  }
  keyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TokenResponse.keyId)
}

// string tokenType = 4;
inline void TokenResponse::clear_tokentype() {
  tokentype_.ClearToEmpty();
}
inline const std::string& TokenResponse::tokentype() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.tokenType)
  return _internal_tokentype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenResponse::set_tokentype(ArgT0&& arg0, ArgT... args) {
 
 tokentype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.tokenType)
}
inline std::string* TokenResponse::mutable_tokentype() {
  std::string* _s = _internal_mutable_tokentype();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TokenResponse.tokenType)
  return _s;
}
inline const std::string& TokenResponse::_internal_tokentype() const {
  return tokentype_.Get();
}
inline void TokenResponse::_internal_set_tokentype(const std::string& value) {
  
  tokentype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenResponse::_internal_mutable_tokentype() {
  
  return tokentype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenResponse::release_tokentype() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TokenResponse.tokenType)
  return tokentype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenResponse::set_allocated_tokentype(std::string* tokentype) {
  if (tokentype != nullptr) {
    
  } else {
    
  }
  tokentype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tokentype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TokenResponse.tokenType)
}

// -------------------------------------------------------------------

// ServiceHealth

// bool isHealthy = 1;
inline void ServiceHealth::clear_ishealthy() {
  ishealthy_ = false;
}
inline bool ServiceHealth::_internal_ishealthy() const {
  return ishealthy_;
}
inline bool ServiceHealth::ishealthy() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServiceHealth.isHealthy)
  return _internal_ishealthy();
}
inline void ServiceHealth::_internal_set_ishealthy(bool value) {
  
  ishealthy_ = value;
}
inline void ServiceHealth::set_ishealthy(bool value) {
  _internal_set_ishealthy(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.ServiceHealth.isHealthy)
}

// string name = 2;
inline void ServiceHealth::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServiceHealth::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServiceHealth.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealth::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServiceHealth.name)
}
inline std::string* ServiceHealth::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServiceHealth.name)
  return _s;
}
inline const std::string& ServiceHealth::_internal_name() const {
  return name_.Get();
}
inline void ServiceHealth::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceHealth::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceHealth::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServiceHealth.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceHealth::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServiceHealth.name)
}

// string message = 3;
inline void ServiceHealth::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& ServiceHealth::message() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServiceHealth.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealth::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServiceHealth.message)
}
inline std::string* ServiceHealth::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServiceHealth.message)
  return _s;
}
inline const std::string& ServiceHealth::_internal_message() const {
  return message_.Get();
}
inline void ServiceHealth::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceHealth::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceHealth::release_message() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServiceHealth.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceHealth::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServiceHealth.message)
}

// -------------------------------------------------------------------

// ServerHealthResponse

// bool isHealthy = 1;
inline void ServerHealthResponse::clear_ishealthy() {
  ishealthy_ = false;
}
inline bool ServerHealthResponse::_internal_ishealthy() const {
  return ishealthy_;
}
inline bool ServerHealthResponse::ishealthy() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.isHealthy)
  return _internal_ishealthy();
}
inline void ServerHealthResponse::_internal_set_ishealthy(bool value) {
  
  ishealthy_ = value;
}
inline void ServerHealthResponse::set_ishealthy(bool value) {
  _internal_set_ishealthy(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.isHealthy)
}

// string serverVersion = 2;
inline void ServerHealthResponse::clear_serverversion() {
  serverversion_.ClearToEmpty();
}
inline const std::string& ServerHealthResponse::serverversion() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.serverVersion)
  return _internal_serverversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerHealthResponse::set_serverversion(ArgT0&& arg0, ArgT... args) {
 
 serverversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.serverVersion)
}
inline std::string* ServerHealthResponse::mutable_serverversion() {
  std::string* _s = _internal_mutable_serverversion();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServerHealthResponse.serverVersion)
  return _s;
}
inline const std::string& ServerHealthResponse::_internal_serverversion() const {
  return serverversion_.Get();
}
inline void ServerHealthResponse::_internal_set_serverversion(const std::string& value) {
  
  serverversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::_internal_mutable_serverversion() {
  
  return serverversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::release_serverversion() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServerHealthResponse.serverVersion)
  return serverversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerHealthResponse::set_allocated_serverversion(std::string* serverversion) {
  if (serverversion != nullptr) {
    
  } else {
    
  }
  serverversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServerHealthResponse.serverVersion)
}

// string id = 3;
inline void ServerHealthResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ServerHealthResponse::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerHealthResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.id)
}
inline std::string* ServerHealthResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServerHealthResponse.id)
  return _s;
}
inline const std::string& ServerHealthResponse::_internal_id() const {
  return id_.Get();
}
inline void ServerHealthResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServerHealthResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerHealthResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServerHealthResponse.id)
}

// repeated .sensory.api.common.ServiceHealth services = 4;
inline int ServerHealthResponse::_internal_services_size() const {
  return services_.size();
}
inline int ServerHealthResponse::services_size() const {
  return _internal_services_size();
}
inline void ServerHealthResponse::clear_services() {
  services_.Clear();
}
inline ::sensory::api::common::ServiceHealth* ServerHealthResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServerHealthResponse.services)
  return services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >*
ServerHealthResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.common.ServerHealthResponse.services)
  return &services_;
}
inline const ::sensory::api::common::ServiceHealth& ServerHealthResponse::_internal_services(int index) const {
  return services_.Get(index);
}
inline const ::sensory::api::common::ServiceHealth& ServerHealthResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.services)
  return _internal_services(index);
}
inline ::sensory::api::common::ServiceHealth* ServerHealthResponse::_internal_add_services() {
  return services_.Add();
}
inline ::sensory::api::common::ServiceHealth* ServerHealthResponse::add_services() {
  ::sensory::api::common::ServiceHealth* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:sensory.api.common.ServerHealthResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >&
ServerHealthResponse::services() const {
  // @@protoc_insertion_point(field_list:sensory.api.common.ServerHealthResponse.services)
  return services_;
}

// -------------------------------------------------------------------

// SystemSummary

// .sensory.api.common.CpuSummary cpu = 1 [(.validate.rules) = {
inline bool SystemSummary::_internal_has_cpu() const {
  return this != internal_default_instance() && cpu_ != nullptr;
}
inline bool SystemSummary::has_cpu() const {
  return _internal_has_cpu();
}
inline void SystemSummary::clear_cpu() {
  if (GetArenaForAllocation() == nullptr && cpu_ != nullptr) {
    delete cpu_;
  }
  cpu_ = nullptr;
}
inline const ::sensory::api::common::CpuSummary& SystemSummary::_internal_cpu() const {
  const ::sensory::api::common::CpuSummary* p = cpu_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::CpuSummary&>(
      ::sensory::api::common::_CpuSummary_default_instance_);
}
inline const ::sensory::api::common::CpuSummary& SystemSummary::cpu() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.SystemSummary.cpu)
  return _internal_cpu();
}
inline void SystemSummary::unsafe_arena_set_allocated_cpu(
    ::sensory::api::common::CpuSummary* cpu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cpu_);
  }
  cpu_ = cpu;
  if (cpu) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.common.SystemSummary.cpu)
}
inline ::sensory::api::common::CpuSummary* SystemSummary::release_cpu() {
  
  ::sensory::api::common::CpuSummary* temp = cpu_;
  cpu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::CpuSummary* SystemSummary::unsafe_arena_release_cpu() {
  // @@protoc_insertion_point(field_release:sensory.api.common.SystemSummary.cpu)
  
  ::sensory::api::common::CpuSummary* temp = cpu_;
  cpu_ = nullptr;
  return temp;
}
inline ::sensory::api::common::CpuSummary* SystemSummary::_internal_mutable_cpu() {
  
  if (cpu_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::CpuSummary>(GetArenaForAllocation());
    cpu_ = p;
  }
  return cpu_;
}
inline ::sensory::api::common::CpuSummary* SystemSummary::mutable_cpu() {
  ::sensory::api::common::CpuSummary* _msg = _internal_mutable_cpu();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.SystemSummary.cpu)
  return _msg;
}
inline void SystemSummary::set_allocated_cpu(::sensory::api::common::CpuSummary* cpu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cpu_;
  }
  if (cpu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::common::CpuSummary>::GetOwningArena(cpu);
    if (message_arena != submessage_arena) {
      cpu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpu, submessage_arena);
    }
    
  } else {
    
  }
  cpu_ = cpu;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.SystemSummary.cpu)
}

// .sensory.api.common.MemorySummary memory = 2 [(.validate.rules) = {
inline bool SystemSummary::_internal_has_memory() const {
  return this != internal_default_instance() && memory_ != nullptr;
}
inline bool SystemSummary::has_memory() const {
  return _internal_has_memory();
}
inline void SystemSummary::clear_memory() {
  if (GetArenaForAllocation() == nullptr && memory_ != nullptr) {
    delete memory_;
  }
  memory_ = nullptr;
}
inline const ::sensory::api::common::MemorySummary& SystemSummary::_internal_memory() const {
  const ::sensory::api::common::MemorySummary* p = memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::MemorySummary&>(
      ::sensory::api::common::_MemorySummary_default_instance_);
}
inline const ::sensory::api::common::MemorySummary& SystemSummary::memory() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.SystemSummary.memory)
  return _internal_memory();
}
inline void SystemSummary::unsafe_arena_set_allocated_memory(
    ::sensory::api::common::MemorySummary* memory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(memory_);
  }
  memory_ = memory;
  if (memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.common.SystemSummary.memory)
}
inline ::sensory::api::common::MemorySummary* SystemSummary::release_memory() {
  
  ::sensory::api::common::MemorySummary* temp = memory_;
  memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::MemorySummary* SystemSummary::unsafe_arena_release_memory() {
  // @@protoc_insertion_point(field_release:sensory.api.common.SystemSummary.memory)
  
  ::sensory::api::common::MemorySummary* temp = memory_;
  memory_ = nullptr;
  return temp;
}
inline ::sensory::api::common::MemorySummary* SystemSummary::_internal_mutable_memory() {
  
  if (memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::MemorySummary>(GetArenaForAllocation());
    memory_ = p;
  }
  return memory_;
}
inline ::sensory::api::common::MemorySummary* SystemSummary::mutable_memory() {
  ::sensory::api::common::MemorySummary* _msg = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.SystemSummary.memory)
  return _msg;
}
inline void SystemSummary::set_allocated_memory(::sensory::api::common::MemorySummary* memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete memory_;
  }
  if (memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::common::MemorySummary>::GetOwningArena(memory);
    if (message_arena != submessage_arena) {
      memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, memory, submessage_arena);
    }
    
  } else {
    
  }
  memory_ = memory;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.SystemSummary.memory)
}

// -------------------------------------------------------------------

// CpuSummary

// uint64 user = 1;
inline void CpuSummary::clear_user() {
  user_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_user() const {
  return user_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::user() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.user)
  return _internal_user();
}
inline void CpuSummary::_internal_set_user(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  user_ = value;
}
inline void CpuSummary::set_user(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.user)
}

// uint64 nice = 2;
inline void CpuSummary::clear_nice() {
  nice_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_nice() const {
  return nice_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::nice() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.nice)
  return _internal_nice();
}
inline void CpuSummary::_internal_set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nice_ = value;
}
inline void CpuSummary::set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nice(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.nice)
}

// uint64 system = 3;
inline void CpuSummary::clear_system() {
  system_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_system() const {
  return system_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::system() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.system)
  return _internal_system();
}
inline void CpuSummary::_internal_set_system(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  system_ = value;
}
inline void CpuSummary::set_system(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_system(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.system)
}

// uint64 idle = 4;
inline void CpuSummary::clear_idle() {
  idle_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_idle() const {
  return idle_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::idle() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.idle)
  return _internal_idle();
}
inline void CpuSummary::_internal_set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  idle_ = value;
}
inline void CpuSummary::set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_idle(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.idle)
}

// uint64 ioWait = 5;
inline void CpuSummary::clear_iowait() {
  iowait_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_iowait() const {
  return iowait_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::iowait() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.ioWait)
  return _internal_iowait();
}
inline void CpuSummary::_internal_set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  iowait_ = value;
}
inline void CpuSummary::set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_iowait(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.ioWait)
}

// uint64 irq = 6;
inline void CpuSummary::clear_irq() {
  irq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_irq() const {
  return irq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::irq() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.irq)
  return _internal_irq();
}
inline void CpuSummary::_internal_set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  irq_ = value;
}
inline void CpuSummary::set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_irq(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.irq)
}

// uint64 softIrq = 7;
inline void CpuSummary::clear_softirq() {
  softirq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_softirq() const {
  return softirq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::softirq() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.softIrq)
  return _internal_softirq();
}
inline void CpuSummary::_internal_set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  softirq_ = value;
}
inline void CpuSummary::set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_softirq(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.softIrq)
}

// uint64 steal = 8;
inline void CpuSummary::clear_steal() {
  steal_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_steal() const {
  return steal_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::steal() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.steal)
  return _internal_steal();
}
inline void CpuSummary::_internal_set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  steal_ = value;
}
inline void CpuSummary::set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_steal(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.steal)
}

// uint64 guest = 9;
inline void CpuSummary::clear_guest() {
  guest_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_guest() const {
  return guest_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::guest() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.guest)
  return _internal_guest();
}
inline void CpuSummary::_internal_set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  guest_ = value;
}
inline void CpuSummary::set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_guest(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.guest)
}

// uint64 guestNice = 10;
inline void CpuSummary::clear_guestnice() {
  guestnice_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_guestnice() const {
  return guestnice_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::guestnice() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.guestNice)
  return _internal_guestnice();
}
inline void CpuSummary::_internal_set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  guestnice_ = value;
}
inline void CpuSummary::set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_guestnice(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.guestNice)
}

// -------------------------------------------------------------------

// MemorySummary

// uint64 memTotal = 1;
inline void MemorySummary::clear_memtotal() {
  memtotal_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::_internal_memtotal() const {
  return memtotal_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::memtotal() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.MemorySummary.memTotal)
  return _internal_memtotal();
}
inline void MemorySummary::_internal_set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memtotal_ = value;
}
inline void MemorySummary::set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memtotal(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.MemorySummary.memTotal)
}

// uint64 memFree = 2;
inline void MemorySummary::clear_memfree() {
  memfree_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::_internal_memfree() const {
  return memfree_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::memfree() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.MemorySummary.memFree)
  return _internal_memfree();
}
inline void MemorySummary::_internal_set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memfree_ = value;
}
inline void MemorySummary::set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memfree(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.MemorySummary.memFree)
}

// uint64 memAvailable = 3;
inline void MemorySummary::clear_memavailable() {
  memavailable_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::_internal_memavailable() const {
  return memavailable_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::memavailable() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.MemorySummary.memAvailable)
  return _internal_memavailable();
}
inline void MemorySummary::_internal_set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memavailable_ = value;
}
inline void MemorySummary::set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memavailable(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.MemorySummary.memAvailable)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace api
}  // namespace sensory

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensory::api::common::KeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::KeyType>() {
  return ::sensory::api::common::KeyType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::ModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::ModelType>() {
  return ::sensory::api::common::ModelType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::TechnologyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::TechnologyType>() {
  return ::sensory::api::common::TechnologyType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::CompressionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::CompressionType>() {
  return ::sensory::api::common::CompressionType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::ClientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::ClientType>() {
  return ::sensory::api::common::ClientType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::UsageEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::UsageEventType>() {
  return ::sensory::api::common::UsageEventType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_2eproto
