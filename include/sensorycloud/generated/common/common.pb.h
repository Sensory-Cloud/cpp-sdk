// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "validate/validate.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2fcommon_2eproto;
namespace sensory {
namespace api {
namespace common {
class CompressionConfiguration;
struct CompressionConfigurationDefaultTypeInternal;
extern CompressionConfigurationDefaultTypeInternal _CompressionConfiguration_default_instance_;
class CpuSummary;
struct CpuSummaryDefaultTypeInternal;
extern CpuSummaryDefaultTypeInternal _CpuSummary_default_instance_;
class CreateKeyRequest;
struct CreateKeyRequestDefaultTypeInternal;
extern CreateKeyRequestDefaultTypeInternal _CreateKeyRequest_default_instance_;
class EnrollmentToken;
struct EnrollmentTokenDefaultTypeInternal;
extern EnrollmentTokenDefaultTypeInternal _EnrollmentToken_default_instance_;
class GenericClient;
struct GenericClientDefaultTypeInternal;
extern GenericClientDefaultTypeInternal _GenericClient_default_instance_;
class KeyResponse;
struct KeyResponseDefaultTypeInternal;
extern KeyResponseDefaultTypeInternal _KeyResponse_default_instance_;
class MemorySummary;
struct MemorySummaryDefaultTypeInternal;
extern MemorySummaryDefaultTypeInternal _MemorySummary_default_instance_;
class PaginationOptions;
struct PaginationOptionsDefaultTypeInternal;
extern PaginationOptionsDefaultTypeInternal _PaginationOptions_default_instance_;
class PaginationResponse;
struct PaginationResponseDefaultTypeInternal;
extern PaginationResponseDefaultTypeInternal _PaginationResponse_default_instance_;
class ServerHealthResponse;
struct ServerHealthResponseDefaultTypeInternal;
extern ServerHealthResponseDefaultTypeInternal _ServerHealthResponse_default_instance_;
class ServiceHealth;
struct ServiceHealthDefaultTypeInternal;
extern ServiceHealthDefaultTypeInternal _ServiceHealth_default_instance_;
class SystemSummary;
struct SystemSummaryDefaultTypeInternal;
extern SystemSummaryDefaultTypeInternal _SystemSummary_default_instance_;
class TenantResponse;
struct TenantResponseDefaultTypeInternal;
extern TenantResponseDefaultTypeInternal _TenantResponse_default_instance_;
class TokenResponse;
struct TokenResponseDefaultTypeInternal;
extern TokenResponseDefaultTypeInternal _TokenResponse_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::common::CompressionConfiguration* Arena::CreateMaybeMessage<::sensory::api::common::CompressionConfiguration>(Arena*);
template<> ::sensory::api::common::CpuSummary* Arena::CreateMaybeMessage<::sensory::api::common::CpuSummary>(Arena*);
template<> ::sensory::api::common::CreateKeyRequest* Arena::CreateMaybeMessage<::sensory::api::common::CreateKeyRequest>(Arena*);
template<> ::sensory::api::common::EnrollmentToken* Arena::CreateMaybeMessage<::sensory::api::common::EnrollmentToken>(Arena*);
template<> ::sensory::api::common::GenericClient* Arena::CreateMaybeMessage<::sensory::api::common::GenericClient>(Arena*);
template<> ::sensory::api::common::KeyResponse* Arena::CreateMaybeMessage<::sensory::api::common::KeyResponse>(Arena*);
template<> ::sensory::api::common::MemorySummary* Arena::CreateMaybeMessage<::sensory::api::common::MemorySummary>(Arena*);
template<> ::sensory::api::common::PaginationOptions* Arena::CreateMaybeMessage<::sensory::api::common::PaginationOptions>(Arena*);
template<> ::sensory::api::common::PaginationResponse* Arena::CreateMaybeMessage<::sensory::api::common::PaginationResponse>(Arena*);
template<> ::sensory::api::common::ServerHealthResponse* Arena::CreateMaybeMessage<::sensory::api::common::ServerHealthResponse>(Arena*);
template<> ::sensory::api::common::ServiceHealth* Arena::CreateMaybeMessage<::sensory::api::common::ServiceHealth>(Arena*);
template<> ::sensory::api::common::SystemSummary* Arena::CreateMaybeMessage<::sensory::api::common::SystemSummary>(Arena*);
template<> ::sensory::api::common::TenantResponse* Arena::CreateMaybeMessage<::sensory::api::common::TenantResponse>(Arena*);
template<> ::sensory::api::common::TokenResponse* Arena::CreateMaybeMessage<::sensory::api::common::TokenResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace common {

enum Void : int {
  VOID_VALUE = 0,
  Void_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Void_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Void_IsValid(int value);
constexpr Void Void_MIN = VOID_VALUE;
constexpr Void Void_MAX = VOID_VALUE;
constexpr int Void_ARRAYSIZE = Void_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Void_descriptor();
template<typename T>
inline const std::string& Void_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Void>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Void_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Void_descriptor(), enum_t_value);
}
inline bool Void_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Void* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Void>(
    Void_descriptor(), name, value);
}
enum KeyType : int {
  PUBLIC_KEY = 0,
  PUBLIC_KEY_ED25519 = 1,
  SHARED_SECRET = 3,
  AES_256 = 4,
  KeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KeyType_IsValid(int value);
constexpr KeyType KeyType_MIN = PUBLIC_KEY;
constexpr KeyType KeyType_MAX = AES_256;
constexpr int KeyType_ARRAYSIZE = KeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyType_descriptor();
template<typename T>
inline const std::string& KeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyType_descriptor(), enum_t_value);
}
inline bool KeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyType>(
    KeyType_descriptor(), name, value);
}
enum FeatureFlag : int {
  TSSV_ALL = 0,
  TS_ALL = 1,
  TNL_ALL = 2,
  FeatureFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FeatureFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FeatureFlag_IsValid(int value);
constexpr FeatureFlag FeatureFlag_MIN = TSSV_ALL;
constexpr FeatureFlag FeatureFlag_MAX = TNL_ALL;
constexpr int FeatureFlag_ARRAYSIZE = FeatureFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FeatureFlag_descriptor();
template<typename T>
inline const std::string& FeatureFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FeatureFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FeatureFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FeatureFlag_descriptor(), enum_t_value);
}
inline bool FeatureFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FeatureFlag>(
    FeatureFlag_descriptor(), name, value);
}
enum ModelType : int {
  UNKNOWN = 0,
  VOICE_BIOMETRIC_TEXT_INDEPENDENT = 1,
  VOICE_BIOMETRIC_WAKEWORD = 2,
  VOICE_EVENT_WAKEWORD = 3,
  VOICE_TRANSCRIBE_GRAMMAR = 4,
  VOICE_TRANSCRIBE_COMMAND_AND_SEARCH = 5,
  VOICE_RECOGNITION_ACTIVITY_DETECTION = 6,
  VOICE_FEATURE_EXTRACTOR = 7,
  VOICE_BIOMETRIC_LIVENESS_DIGIT = 8,
  VOICE_BIOMETRIC_TEXT_DEPENDENT = 9,
  VOICE_SYNTHESIS = 10,
  SOUND_EVENT_ENROLLABLE = 100,
  SOUND_EVENT_REVALIDATION = 101,
  SOUND_EVENT_FIXED = 102,
  SOUND_SCENE_FIXED = 103,
  FACE_BIOMETRIC = 201,
  FACE_RECOGNITION = 202,
  OBJECT_RECOGNITION = 203,
  IMAGE_TRANSFORM = 204,
  FACE_EMBEDDING = 205,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = UNKNOWN;
constexpr ModelType ModelType_MAX = FACE_EMBEDDING;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelType_descriptor();
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelType_descriptor(), enum_t_value);
}
inline bool ModelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelType>(
    ModelType_descriptor(), name, value);
}
enum TechnologyType : int {
  NOT_SET = 0,
  TSSV = 1,
  TS = 2,
  TNL = 3,
  STT = 4,
  TTS = 5,
  TechnologyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TechnologyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TechnologyType_IsValid(int value);
constexpr TechnologyType TechnologyType_MIN = NOT_SET;
constexpr TechnologyType TechnologyType_MAX = TTS;
constexpr int TechnologyType_ARRAYSIZE = TechnologyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TechnologyType_descriptor();
template<typename T>
inline const std::string& TechnologyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TechnologyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TechnologyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TechnologyType_descriptor(), enum_t_value);
}
inline bool TechnologyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TechnologyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TechnologyType>(
    TechnologyType_descriptor(), name, value);
}
enum CompressionType : int {
  IMAGE_GRAYSCALE = 0,
  CompressionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CompressionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = IMAGE_GRAYSCALE;
constexpr CompressionType CompressionType_MAX = IMAGE_GRAYSCALE;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionType_descriptor();
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompressionType_descriptor(), enum_t_value);
}
inline bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressionType>(
    CompressionType_descriptor(), name, value);
}
enum ClientType : int {
  INVALID = 0,
  DEVICE = 1,
  CLUSTER = 2,
  USER = 3,
  SUPER_USER = 4,
  BILLING_USER = 5,
  READ_ONLY_USER = 6,
  ROOT = 100,
  ClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = INVALID;
constexpr ClientType ClientType_MAX = ROOT;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientType_descriptor();
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientType_descriptor(), enum_t_value);
}
inline bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum UsageEventType : int {
  AUTHENTICATION = 0,
  RECOGNITION = 1,
  ENROLLMENT = 2,
  SYNTHESIS = 3,
  TRANSCRIPTION = 4,
  UsageEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UsageEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UsageEventType_IsValid(int value);
constexpr UsageEventType UsageEventType_MIN = AUTHENTICATION;
constexpr UsageEventType UsageEventType_MAX = TRANSCRIPTION;
constexpr int UsageEventType_ARRAYSIZE = UsageEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UsageEventType_descriptor();
template<typename T>
inline const std::string& UsageEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UsageEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UsageEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UsageEventType_descriptor(), enum_t_value);
}
inline bool UsageEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UsageEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UsageEventType>(
    UsageEventType_descriptor(), name, value);
}
enum ServerType : int {
  TITAN = 0,
  IO = 1,
  ServerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServerType_IsValid(int value);
constexpr ServerType ServerType_MIN = TITAN;
constexpr ServerType ServerType_MAX = IO;
constexpr int ServerType_ARRAYSIZE = ServerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerType_descriptor();
template<typename T>
inline const std::string& ServerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerType_descriptor(), enum_t_value);
}
inline bool ServerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerType>(
    ServerType_descriptor(), name, value);
}
// ===================================================================

class CompressionConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.CompressionConfiguration) */ {
 public:
  inline CompressionConfiguration() : CompressionConfiguration(nullptr) {}
  ~CompressionConfiguration() override;
  explicit constexpr CompressionConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressionConfiguration(const CompressionConfiguration& from);
  CompressionConfiguration(CompressionConfiguration&& from) noexcept
    : CompressionConfiguration() {
    *this = ::std::move(from);
  }

  inline CompressionConfiguration& operator=(const CompressionConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressionConfiguration& operator=(CompressionConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressionConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressionConfiguration* internal_default_instance() {
    return reinterpret_cast<const CompressionConfiguration*>(
               &_CompressionConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CompressionConfiguration& a, CompressionConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressionConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressionConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompressionConfiguration* New() const final {
    return new CompressionConfiguration();
  }

  CompressionConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompressionConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressionConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompressionConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressionConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.CompressionConfiguration";
  }
  protected:
  explicit CompressionConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressionsFieldNumber = 1,
  };
  // repeated .sensory.api.common.CompressionType compressions = 1;
  int compressions_size() const;
  private:
  int _internal_compressions_size() const;
  public:
  void clear_compressions();
  private:
  ::sensory::api::common::CompressionType _internal_compressions(int index) const;
  void _internal_add_compressions(::sensory::api::common::CompressionType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_compressions();
  public:
  ::sensory::api::common::CompressionType compressions(int index) const;
  void set_compressions(int index, ::sensory::api::common::CompressionType value);
  void add_compressions(::sensory::api::common::CompressionType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& compressions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_compressions();

  // @@protoc_insertion_point(class_scope:sensory.api.common.CompressionConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> compressions_;
  mutable std::atomic<int> _compressions_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.TokenResponse) */ {
 public:
  inline TokenResponse() : TokenResponse(nullptr) {}
  ~TokenResponse() override;
  explicit constexpr TokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenResponse(const TokenResponse& from);
  TokenResponse(TokenResponse&& from) noexcept
    : TokenResponse() {
    *this = ::std::move(from);
  }

  inline TokenResponse& operator=(const TokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenResponse& operator=(TokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenResponse* internal_default_instance() {
    return reinterpret_cast<const TokenResponse*>(
               &_TokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TokenResponse& a, TokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TokenResponse* New() const final {
    return new TokenResponse();
  }

  TokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TokenResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.TokenResponse";
  }
  protected:
  explicit TokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 1,
    kKeyIdFieldNumber = 3,
    kTokenTypeFieldNumber = 4,
    kExpiresInFieldNumber = 2,
  };
  // string accessToken = 1;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_MUST_USE_RESULT std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // string keyId = 3;
  void clear_keyid();
  const std::string& keyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyid();
  PROTOBUF_MUST_USE_RESULT std::string* release_keyid();
  void set_allocated_keyid(std::string* keyid);
  private:
  const std::string& _internal_keyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyid(const std::string& value);
  std::string* _internal_mutable_keyid();
  public:

  // string tokenType = 4;
  void clear_tokentype();
  const std::string& tokentype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokentype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokentype();
  PROTOBUF_MUST_USE_RESULT std::string* release_tokentype();
  void set_allocated_tokentype(std::string* tokentype);
  private:
  const std::string& _internal_tokentype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokentype(const std::string& value);
  std::string* _internal_mutable_tokentype();
  public:

  // int32 expiresIn = 2;
  void clear_expiresin();
  ::PROTOBUF_NAMESPACE_ID::int32 expiresin() const;
  void set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_expiresin() const;
  void _internal_set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.TokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokentype_;
  ::PROTOBUF_NAMESPACE_ID::int32 expiresin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ServiceHealth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.ServiceHealth) */ {
 public:
  inline ServiceHealth() : ServiceHealth(nullptr) {}
  ~ServiceHealth() override;
  explicit constexpr ServiceHealth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceHealth(const ServiceHealth& from);
  ServiceHealth(ServiceHealth&& from) noexcept
    : ServiceHealth() {
    *this = ::std::move(from);
  }

  inline ServiceHealth& operator=(const ServiceHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceHealth& operator=(ServiceHealth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceHealth* internal_default_instance() {
    return reinterpret_cast<const ServiceHealth*>(
               &_ServiceHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServiceHealth& a, ServiceHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceHealth* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServiceHealth* New() const final {
    return new ServiceHealth();
  }

  ServiceHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServiceHealth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceHealth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceHealth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceHealth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.ServiceHealth";
  }
  protected:
  explicit ServiceHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kIsHealthyFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool isHealthy = 1;
  void clear_ishealthy();
  bool ishealthy() const;
  void set_ishealthy(bool value);
  private:
  bool _internal_ishealthy() const;
  void _internal_set_ishealthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.ServiceHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool ishealthy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ServerHealthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.ServerHealthResponse) */ {
 public:
  inline ServerHealthResponse() : ServerHealthResponse(nullptr) {}
  ~ServerHealthResponse() override;
  explicit constexpr ServerHealthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerHealthResponse(const ServerHealthResponse& from);
  ServerHealthResponse(ServerHealthResponse&& from) noexcept
    : ServerHealthResponse() {
    *this = ::std::move(from);
  }

  inline ServerHealthResponse& operator=(const ServerHealthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerHealthResponse& operator=(ServerHealthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerHealthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerHealthResponse* internal_default_instance() {
    return reinterpret_cast<const ServerHealthResponse*>(
               &_ServerHealthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServerHealthResponse& a, ServerHealthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerHealthResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerHealthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerHealthResponse* New() const final {
    return new ServerHealthResponse();
  }

  ServerHealthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerHealthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerHealthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerHealthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerHealthResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.ServerHealthResponse";
  }
  protected:
  explicit ServerHealthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 4,
    kServerVersionFieldNumber = 2,
    kIdFieldNumber = 3,
    kIsHealthyFieldNumber = 1,
    kIsLeaderFieldNumber = 6,
    kServerTypeFieldNumber = 5,
  };
  // repeated .sensory.api.common.ServiceHealth services = 4;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::sensory::api::common::ServiceHealth* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >*
      mutable_services();
  private:
  const ::sensory::api::common::ServiceHealth& _internal_services(int index) const;
  ::sensory::api::common::ServiceHealth* _internal_add_services();
  public:
  const ::sensory::api::common::ServiceHealth& services(int index) const;
  ::sensory::api::common::ServiceHealth* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >&
      services() const;

  // string serverVersion = 2;
  void clear_serverversion();
  const std::string& serverversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_serverversion();
  void set_allocated_serverversion(std::string* serverversion);
  private:
  const std::string& _internal_serverversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverversion(const std::string& value);
  std::string* _internal_mutable_serverversion();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool isHealthy = 1;
  void clear_ishealthy();
  bool ishealthy() const;
  void set_ishealthy(bool value);
  private:
  bool _internal_ishealthy() const;
  void _internal_set_ishealthy(bool value);
  public:

  // bool isLeader = 6;
  void clear_isleader();
  bool isleader() const;
  void set_isleader(bool value);
  private:
  bool _internal_isleader() const;
  void _internal_set_isleader(bool value);
  public:

  // .sensory.api.common.ServerType serverType = 5;
  void clear_servertype();
  ::sensory::api::common::ServerType servertype() const;
  void set_servertype(::sensory::api::common::ServerType value);
  private:
  ::sensory::api::common::ServerType _internal_servertype() const;
  void _internal_set_servertype(::sensory::api::common::ServerType value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.ServerHealthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth > services_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool ishealthy_;
  bool isleader_;
  int servertype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SystemSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.SystemSummary) */ {
 public:
  inline SystemSummary() : SystemSummary(nullptr) {}
  ~SystemSummary() override;
  explicit constexpr SystemSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemSummary(const SystemSummary& from);
  SystemSummary(SystemSummary&& from) noexcept
    : SystemSummary() {
    *this = ::std::move(from);
  }

  inline SystemSummary& operator=(const SystemSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemSummary& operator=(SystemSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemSummary* internal_default_instance() {
    return reinterpret_cast<const SystemSummary*>(
               &_SystemSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SystemSummary& a, SystemSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemSummary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemSummary* New() const final {
    return new SystemSummary();
  }

  SystemSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SystemSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.SystemSummary";
  }
  protected:
  explicit SystemSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpuFieldNumber = 1,
    kMemoryFieldNumber = 2,
  };
  // .sensory.api.common.CpuSummary cpu = 1 [(.validate.rules) = {
  bool has_cpu() const;
  private:
  bool _internal_has_cpu() const;
  public:
  void clear_cpu();
  const ::sensory::api::common::CpuSummary& cpu() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::CpuSummary* release_cpu();
  ::sensory::api::common::CpuSummary* mutable_cpu();
  void set_allocated_cpu(::sensory::api::common::CpuSummary* cpu);
  private:
  const ::sensory::api::common::CpuSummary& _internal_cpu() const;
  ::sensory::api::common::CpuSummary* _internal_mutable_cpu();
  public:
  void unsafe_arena_set_allocated_cpu(
      ::sensory::api::common::CpuSummary* cpu);
  ::sensory::api::common::CpuSummary* unsafe_arena_release_cpu();

  // .sensory.api.common.MemorySummary memory = 2 [(.validate.rules) = {
  bool has_memory() const;
  private:
  bool _internal_has_memory() const;
  public:
  void clear_memory();
  const ::sensory::api::common::MemorySummary& memory() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::MemorySummary* release_memory();
  ::sensory::api::common::MemorySummary* mutable_memory();
  void set_allocated_memory(::sensory::api::common::MemorySummary* memory);
  private:
  const ::sensory::api::common::MemorySummary& _internal_memory() const;
  ::sensory::api::common::MemorySummary* _internal_mutable_memory();
  public:
  void unsafe_arena_set_allocated_memory(
      ::sensory::api::common::MemorySummary* memory);
  ::sensory::api::common::MemorySummary* unsafe_arena_release_memory();

  // @@protoc_insertion_point(class_scope:sensory.api.common.SystemSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensory::api::common::CpuSummary* cpu_;
  ::sensory::api::common::MemorySummary* memory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class CpuSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.CpuSummary) */ {
 public:
  inline CpuSummary() : CpuSummary(nullptr) {}
  ~CpuSummary() override;
  explicit constexpr CpuSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CpuSummary(const CpuSummary& from);
  CpuSummary(CpuSummary&& from) noexcept
    : CpuSummary() {
    *this = ::std::move(from);
  }

  inline CpuSummary& operator=(const CpuSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuSummary& operator=(CpuSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpuSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuSummary* internal_default_instance() {
    return reinterpret_cast<const CpuSummary*>(
               &_CpuSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CpuSummary& a, CpuSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuSummary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CpuSummary* New() const final {
    return new CpuSummary();
  }

  CpuSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CpuSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CpuSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CpuSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CpuSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.CpuSummary";
  }
  protected:
  explicit CpuSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kNiceFieldNumber = 2,
    kSystemFieldNumber = 3,
    kIdleFieldNumber = 4,
    kIoWaitFieldNumber = 5,
    kIrqFieldNumber = 6,
    kSoftIrqFieldNumber = 7,
    kStealFieldNumber = 8,
    kGuestFieldNumber = 9,
    kGuestNiceFieldNumber = 10,
  };
  // uint64 user = 1;
  void clear_user();
  ::PROTOBUF_NAMESPACE_ID::uint64 user() const;
  void set_user(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_user() const;
  void _internal_set_user(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 nice = 2;
  void clear_nice();
  ::PROTOBUF_NAMESPACE_ID::uint64 nice() const;
  void set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nice() const;
  void _internal_set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 system = 3;
  void clear_system();
  ::PROTOBUF_NAMESPACE_ID::uint64 system() const;
  void set_system(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_system() const;
  void _internal_set_system(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 idle = 4;
  void clear_idle();
  ::PROTOBUF_NAMESPACE_ID::uint64 idle() const;
  void set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_idle() const;
  void _internal_set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 ioWait = 5;
  void clear_iowait();
  ::PROTOBUF_NAMESPACE_ID::uint64 iowait() const;
  void set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_iowait() const;
  void _internal_set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 irq = 6;
  void clear_irq();
  ::PROTOBUF_NAMESPACE_ID::uint64 irq() const;
  void set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_irq() const;
  void _internal_set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 softIrq = 7;
  void clear_softirq();
  ::PROTOBUF_NAMESPACE_ID::uint64 softirq() const;
  void set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_softirq() const;
  void _internal_set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 steal = 8;
  void clear_steal();
  ::PROTOBUF_NAMESPACE_ID::uint64 steal() const;
  void set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_steal() const;
  void _internal_set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 guest = 9;
  void clear_guest();
  ::PROTOBUF_NAMESPACE_ID::uint64 guest() const;
  void set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_guest() const;
  void _internal_set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 guestNice = 10;
  void clear_guestnice();
  ::PROTOBUF_NAMESPACE_ID::uint64 guestnice() const;
  void set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_guestnice() const;
  void _internal_set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.CpuSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 user_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nice_;
  ::PROTOBUF_NAMESPACE_ID::uint64 system_;
  ::PROTOBUF_NAMESPACE_ID::uint64 idle_;
  ::PROTOBUF_NAMESPACE_ID::uint64 iowait_;
  ::PROTOBUF_NAMESPACE_ID::uint64 irq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 softirq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 steal_;
  ::PROTOBUF_NAMESPACE_ID::uint64 guest_;
  ::PROTOBUF_NAMESPACE_ID::uint64 guestnice_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class MemorySummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.MemorySummary) */ {
 public:
  inline MemorySummary() : MemorySummary(nullptr) {}
  ~MemorySummary() override;
  explicit constexpr MemorySummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemorySummary(const MemorySummary& from);
  MemorySummary(MemorySummary&& from) noexcept
    : MemorySummary() {
    *this = ::std::move(from);
  }

  inline MemorySummary& operator=(const MemorySummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemorySummary& operator=(MemorySummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemorySummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemorySummary* internal_default_instance() {
    return reinterpret_cast<const MemorySummary*>(
               &_MemorySummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MemorySummary& a, MemorySummary& b) {
    a.Swap(&b);
  }
  inline void Swap(MemorySummary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemorySummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MemorySummary* New() const final {
    return new MemorySummary();
  }

  MemorySummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemorySummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemorySummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemorySummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemorySummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.MemorySummary";
  }
  protected:
  explicit MemorySummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemTotalFieldNumber = 1,
    kMemFreeFieldNumber = 2,
    kMemAvailableFieldNumber = 3,
  };
  // uint64 memTotal = 1;
  void clear_memtotal();
  ::PROTOBUF_NAMESPACE_ID::uint64 memtotal() const;
  void set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memtotal() const;
  void _internal_set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 memFree = 2;
  void clear_memfree();
  ::PROTOBUF_NAMESPACE_ID::uint64 memfree() const;
  void set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memfree() const;
  void _internal_set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 memAvailable = 3;
  void clear_memavailable();
  ::PROTOBUF_NAMESPACE_ID::uint64 memavailable() const;
  void set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memavailable() const;
  void _internal_set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.MemorySummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memtotal_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memfree_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memavailable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class GenericClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.GenericClient) */ {
 public:
  inline GenericClient() : GenericClient(nullptr) {}
  ~GenericClient() override;
  explicit constexpr GenericClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericClient(const GenericClient& from);
  GenericClient(GenericClient&& from) noexcept
    : GenericClient() {
    *this = ::std::move(from);
  }

  inline GenericClient& operator=(const GenericClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericClient& operator=(GenericClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericClient* internal_default_instance() {
    return reinterpret_cast<const GenericClient*>(
               &_GenericClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GenericClient& a, GenericClient& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericClient* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericClient* New() const final {
    return new GenericClient();
  }

  GenericClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenericClient& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.GenericClient";
  }
  protected:
  explicit GenericClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kSecretFieldNumber = 2,
  };
  // string clientId = 1 [(.validate.rules) = {
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_MUST_USE_RESULT std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string secret = 2 [(.validate.rules) = {
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_MUST_USE_RESULT std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.GenericClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TenantResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.TenantResponse) */ {
 public:
  inline TenantResponse() : TenantResponse(nullptr) {}
  ~TenantResponse() override;
  explicit constexpr TenantResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TenantResponse(const TenantResponse& from);
  TenantResponse(TenantResponse&& from) noexcept
    : TenantResponse() {
    *this = ::std::move(from);
  }

  inline TenantResponse& operator=(const TenantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TenantResponse& operator=(TenantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TenantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TenantResponse* internal_default_instance() {
    return reinterpret_cast<const TenantResponse*>(
               &_TenantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TenantResponse& a, TenantResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TenantResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TenantResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TenantResponse* New() const final {
    return new TenantResponse();
  }

  TenantResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TenantResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TenantResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TenantResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TenantResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.TenantResponse";
  }
  protected:
  explicit TenantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp createdAt = 3;
  bool has_createdat() const;
  private:
  bool _internal_has_createdat() const;
  public:
  void clear_createdat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& createdat() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_createdat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_createdat();
  void set_allocated_createdat(::PROTOBUF_NAMESPACE_ID::Timestamp* createdat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_createdat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_createdat();
  public:
  void unsafe_arena_set_allocated_createdat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_createdat();

  // .google.protobuf.Timestamp updatedAt = 4;
  bool has_updatedat() const;
  private:
  bool _internal_has_updatedat() const;
  public:
  void clear_updatedat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updatedat() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updatedat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updatedat();
  void set_allocated_updatedat(::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updatedat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updatedat();
  public:
  void unsafe_arena_set_allocated_updatedat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updatedat();

  // @@protoc_insertion_point(class_scope:sensory.api.common.TenantResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class PaginationOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.PaginationOptions) */ {
 public:
  inline PaginationOptions() : PaginationOptions(nullptr) {}
  ~PaginationOptions() override;
  explicit constexpr PaginationOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationOptions(const PaginationOptions& from);
  PaginationOptions(PaginationOptions&& from) noexcept
    : PaginationOptions() {
    *this = ::std::move(from);
  }

  inline PaginationOptions& operator=(const PaginationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationOptions& operator=(PaginationOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginationOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationOptions* internal_default_instance() {
    return reinterpret_cast<const PaginationOptions*>(
               &_PaginationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PaginationOptions& a, PaginationOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginationOptions* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaginationOptions* New() const final {
    return new PaginationOptions();
  }

  PaginationOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaginationOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginationOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaginationOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginationOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.PaginationOptions";
  }
  protected:
  explicit PaginationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderingFieldNumber = 1,
    kDecendingFieldNumber = 2,
    kPageIndexFieldNumber = 3,
    kPageSizeFieldNumber = 4,
  };
  // string ordering = 1;
  void clear_ordering();
  const std::string& ordering() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ordering(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ordering();
  PROTOBUF_MUST_USE_RESULT std::string* release_ordering();
  void set_allocated_ordering(std::string* ordering);
  private:
  const std::string& _internal_ordering() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordering(const std::string& value);
  std::string* _internal_mutable_ordering();
  public:

  // bool decending = 2;
  void clear_decending();
  bool decending() const;
  void set_decending(bool value);
  private:
  bool _internal_decending() const;
  void _internal_set_decending(bool value);
  public:

  // int32 pageIndex = 3;
  void clear_pageindex();
  ::PROTOBUF_NAMESPACE_ID::int32 pageindex() const;
  void set_pageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pageindex() const;
  void _internal_set_pageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 pageSize = 4;
  void clear_pagesize();
  ::PROTOBUF_NAMESPACE_ID::int32 pagesize() const;
  void set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pagesize() const;
  void _internal_set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.PaginationOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ordering_;
  bool decending_;
  ::PROTOBUF_NAMESPACE_ID::int32 pageindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 pagesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class PaginationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.PaginationResponse) */ {
 public:
  inline PaginationResponse() : PaginationResponse(nullptr) {}
  ~PaginationResponse() override;
  explicit constexpr PaginationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationResponse(const PaginationResponse& from);
  PaginationResponse(PaginationResponse&& from) noexcept
    : PaginationResponse() {
    *this = ::std::move(from);
  }

  inline PaginationResponse& operator=(const PaginationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationResponse& operator=(PaginationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationResponse* internal_default_instance() {
    return reinterpret_cast<const PaginationResponse*>(
               &_PaginationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PaginationResponse& a, PaginationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaginationResponse* New() const final {
    return new PaginationResponse();
  }

  PaginationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaginationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaginationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.PaginationResponse";
  }
  protected:
  explicit PaginationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPossibleOrderingsFieldNumber = 3,
    kOrderingFieldNumber = 1,
    kDecendingFieldNumber = 2,
    kPageSizeFieldNumber = 5,
    kTotalCountFieldNumber = 4,
    kPrevPageIndexFieldNumber = 6,
    kCurrentPageIndexFieldNumber = 7,
    kNextPageIndexFieldNumber = 8,
  };
  // repeated string possibleOrderings = 3;
  int possibleorderings_size() const;
  private:
  int _internal_possibleorderings_size() const;
  public:
  void clear_possibleorderings();
  const std::string& possibleorderings(int index) const;
  std::string* mutable_possibleorderings(int index);
  void set_possibleorderings(int index, const std::string& value);
  void set_possibleorderings(int index, std::string&& value);
  void set_possibleorderings(int index, const char* value);
  void set_possibleorderings(int index, const char* value, size_t size);
  std::string* add_possibleorderings();
  void add_possibleorderings(const std::string& value);
  void add_possibleorderings(std::string&& value);
  void add_possibleorderings(const char* value);
  void add_possibleorderings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& possibleorderings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_possibleorderings();
  private:
  const std::string& _internal_possibleorderings(int index) const;
  std::string* _internal_add_possibleorderings();
  public:

  // string ordering = 1;
  void clear_ordering();
  const std::string& ordering() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ordering(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ordering();
  PROTOBUF_MUST_USE_RESULT std::string* release_ordering();
  void set_allocated_ordering(std::string* ordering);
  private:
  const std::string& _internal_ordering() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordering(const std::string& value);
  std::string* _internal_mutable_ordering();
  public:

  // bool decending = 2;
  void clear_decending();
  bool decending() const;
  void set_decending(bool value);
  private:
  bool _internal_decending() const;
  void _internal_set_decending(bool value);
  public:

  // int32 pageSize = 5;
  void clear_pagesize();
  ::PROTOBUF_NAMESPACE_ID::int32 pagesize() const;
  void set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pagesize() const;
  void _internal_set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 totalCount = 4;
  void clear_totalcount();
  ::PROTOBUF_NAMESPACE_ID::int64 totalcount() const;
  void set_totalcount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalcount() const;
  void _internal_set_totalcount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 prevPageIndex = 6;
  void clear_prevpageindex();
  ::PROTOBUF_NAMESPACE_ID::int32 prevpageindex() const;
  void set_prevpageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_prevpageindex() const;
  void _internal_set_prevpageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 currentPageIndex = 7;
  void clear_currentpageindex();
  ::PROTOBUF_NAMESPACE_ID::int32 currentpageindex() const;
  void set_currentpageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_currentpageindex() const;
  void _internal_set_currentpageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 nextPageIndex = 8;
  void clear_nextpageindex();
  ::PROTOBUF_NAMESPACE_ID::int32 nextpageindex() const;
  void set_nextpageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nextpageindex() const;
  void _internal_set_nextpageindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.PaginationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> possibleorderings_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ordering_;
  bool decending_;
  ::PROTOBUF_NAMESPACE_ID::int32 pagesize_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalcount_;
  ::PROTOBUF_NAMESPACE_ID::int32 prevpageindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 currentpageindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 nextpageindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class EnrollmentToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.EnrollmentToken) */ {
 public:
  inline EnrollmentToken() : EnrollmentToken(nullptr) {}
  ~EnrollmentToken() override;
  explicit constexpr EnrollmentToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnrollmentToken(const EnrollmentToken& from);
  EnrollmentToken(EnrollmentToken&& from) noexcept
    : EnrollmentToken() {
    *this = ::std::move(from);
  }

  inline EnrollmentToken& operator=(const EnrollmentToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnrollmentToken& operator=(EnrollmentToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnrollmentToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnrollmentToken* internal_default_instance() {
    return reinterpret_cast<const EnrollmentToken*>(
               &_EnrollmentToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EnrollmentToken& a, EnrollmentToken& b) {
    a.Swap(&b);
  }
  inline void Swap(EnrollmentToken* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnrollmentToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnrollmentToken* New() const final {
    return new EnrollmentToken();
  }

  EnrollmentToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnrollmentToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnrollmentToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnrollmentToken& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnrollmentToken* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.EnrollmentToken";
  }
  protected:
  explicit EnrollmentToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kExpirationFieldNumber = 2,
  };
  // bytes token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 expiration = 2;
  void clear_expiration();
  ::PROTOBUF_NAMESPACE_ID::int64 expiration() const;
  void set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_expiration() const;
  void _internal_set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.EnrollmentToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::int64 expiration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class CreateKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.CreateKeyRequest) */ {
 public:
  inline CreateKeyRequest() : CreateKeyRequest(nullptr) {}
  ~CreateKeyRequest() override;
  explicit constexpr CreateKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateKeyRequest(const CreateKeyRequest& from);
  CreateKeyRequest(CreateKeyRequest&& from) noexcept
    : CreateKeyRequest() {
    *this = ::std::move(from);
  }

  inline CreateKeyRequest& operator=(const CreateKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateKeyRequest& operator=(CreateKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateKeyRequest* internal_default_instance() {
    return reinterpret_cast<const CreateKeyRequest*>(
               &_CreateKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateKeyRequest& a, CreateKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateKeyRequest* New() const final {
    return new CreateKeyRequest();
  }

  CreateKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.CreateKeyRequest";
  }
  protected:
  explicit CreateKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 3,
    kExpirationFieldNumber = 4,
    kKeyTypeFieldNumber = 2,
  };
  // string name = 1 [(.validate.rules) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int64 expiration = 4;
  void clear_expiration();
  ::PROTOBUF_NAMESPACE_ID::int64 expiration() const;
  void set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_expiration() const;
  void _internal_set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .sensory.api.common.KeyType keyType = 2 [(.validate.rules) = {
  void clear_keytype();
  ::sensory::api::common::KeyType keytype() const;
  void set_keytype(::sensory::api::common::KeyType value);
  private:
  ::sensory::api::common::KeyType _internal_keytype() const;
  void _internal_set_keytype(::sensory::api::common::KeyType value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.CreateKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::int64 expiration_;
  int keytype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class KeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.common.KeyResponse) */ {
 public:
  inline KeyResponse() : KeyResponse(nullptr) {}
  ~KeyResponse() override;
  explicit constexpr KeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyResponse(const KeyResponse& from);
  KeyResponse(KeyResponse&& from) noexcept
    : KeyResponse() {
    *this = ::std::move(from);
  }

  inline KeyResponse& operator=(const KeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyResponse& operator=(KeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyResponse* internal_default_instance() {
    return reinterpret_cast<const KeyResponse*>(
               &_KeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(KeyResponse& a, KeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyResponse* New() const final {
    return new KeyResponse();
  }

  KeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.common.KeyResponse";
  }
  protected:
  explicit KeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTenantIdFieldNumber = 5,
    kExpirationFieldNumber = 4,
    kKeyTypeFieldNumber = 3,
    kDisabledFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string tenantId = 5;
  void clear_tenantid();
  const std::string& tenantid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenantid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenantid();
  PROTOBUF_MUST_USE_RESULT std::string* release_tenantid();
  void set_allocated_tenantid(std::string* tenantid);
  private:
  const std::string& _internal_tenantid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenantid(const std::string& value);
  std::string* _internal_mutable_tenantid();
  public:

  // int64 expiration = 4;
  void clear_expiration();
  ::PROTOBUF_NAMESPACE_ID::int64 expiration() const;
  void set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_expiration() const;
  void _internal_set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .sensory.api.common.KeyType keyType = 3;
  void clear_keytype();
  ::sensory::api::common::KeyType keytype() const;
  void set_keytype(::sensory::api::common::KeyType value);
  private:
  ::sensory::api::common::KeyType _internal_keytype() const;
  void _internal_set_keytype(::sensory::api::common::KeyType value);
  public:

  // bool disabled = 6;
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.common.KeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenantid_;
  ::PROTOBUF_NAMESPACE_ID::int64 expiration_;
  int keytype_;
  bool disabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CompressionConfiguration

// repeated .sensory.api.common.CompressionType compressions = 1;
inline int CompressionConfiguration::_internal_compressions_size() const {
  return compressions_.size();
}
inline int CompressionConfiguration::compressions_size() const {
  return _internal_compressions_size();
}
inline void CompressionConfiguration::clear_compressions() {
  compressions_.Clear();
}
inline ::sensory::api::common::CompressionType CompressionConfiguration::_internal_compressions(int index) const {
  return static_cast< ::sensory::api::common::CompressionType >(compressions_.Get(index));
}
inline ::sensory::api::common::CompressionType CompressionConfiguration::compressions(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CompressionConfiguration.compressions)
  return _internal_compressions(index);
}
inline void CompressionConfiguration::set_compressions(int index, ::sensory::api::common::CompressionType value) {
  compressions_.Set(index, value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CompressionConfiguration.compressions)
}
inline void CompressionConfiguration::_internal_add_compressions(::sensory::api::common::CompressionType value) {
  compressions_.Add(value);
}
inline void CompressionConfiguration::add_compressions(::sensory::api::common::CompressionType value) {
  _internal_add_compressions(value);
  // @@protoc_insertion_point(field_add:sensory.api.common.CompressionConfiguration.compressions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CompressionConfiguration::compressions() const {
  // @@protoc_insertion_point(field_list:sensory.api.common.CompressionConfiguration.compressions)
  return compressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CompressionConfiguration::_internal_mutable_compressions() {
  return &compressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CompressionConfiguration::mutable_compressions() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.common.CompressionConfiguration.compressions)
  return _internal_mutable_compressions();
}

// -------------------------------------------------------------------

// TokenResponse

// string accessToken = 1;
inline void TokenResponse::clear_accesstoken() {
  accesstoken_.ClearToEmpty();
}
inline const std::string& TokenResponse::accesstoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenResponse::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 accesstoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.accessToken)
}
inline std::string* TokenResponse::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TokenResponse.accessToken)
  return _s;
}
inline const std::string& TokenResponse::_internal_accesstoken() const {
  return accesstoken_.Get();
}
inline void TokenResponse::_internal_set_accesstoken(const std::string& value) {
  
  accesstoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenResponse::_internal_mutable_accesstoken() {
  
  return accesstoken_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenResponse::release_accesstoken() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TokenResponse.accessToken)
  return accesstoken_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenResponse::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  accesstoken_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), accesstoken,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TokenResponse.accessToken)
}

// int32 expiresIn = 2;
inline void TokenResponse::clear_expiresin() {
  expiresin_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TokenResponse::_internal_expiresin() const {
  return expiresin_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TokenResponse::expiresin() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.expiresIn)
  return _internal_expiresin();
}
inline void TokenResponse::_internal_set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  expiresin_ = value;
}
inline void TokenResponse::set_expiresin(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_expiresin(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.expiresIn)
}

// string keyId = 3;
inline void TokenResponse::clear_keyid() {
  keyid_.ClearToEmpty();
}
inline const std::string& TokenResponse::keyid() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.keyId)
  return _internal_keyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenResponse::set_keyid(ArgT0&& arg0, ArgT... args) {
 
 keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.keyId)
}
inline std::string* TokenResponse::mutable_keyid() {
  std::string* _s = _internal_mutable_keyid();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TokenResponse.keyId)
  return _s;
}
inline const std::string& TokenResponse::_internal_keyid() const {
  return keyid_.Get();
}
inline void TokenResponse::_internal_set_keyid(const std::string& value) {
  
  keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenResponse::_internal_mutable_keyid() {
  
  return keyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenResponse::release_keyid() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TokenResponse.keyId)
  return keyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenResponse::set_allocated_keyid(std::string* keyid) {
  if (keyid != nullptr) {
    
  } else {
    
  }
  keyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TokenResponse.keyId)
}

// string tokenType = 4;
inline void TokenResponse::clear_tokentype() {
  tokentype_.ClearToEmpty();
}
inline const std::string& TokenResponse::tokentype() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TokenResponse.tokenType)
  return _internal_tokentype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenResponse::set_tokentype(ArgT0&& arg0, ArgT... args) {
 
 tokentype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TokenResponse.tokenType)
}
inline std::string* TokenResponse::mutable_tokentype() {
  std::string* _s = _internal_mutable_tokentype();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TokenResponse.tokenType)
  return _s;
}
inline const std::string& TokenResponse::_internal_tokentype() const {
  return tokentype_.Get();
}
inline void TokenResponse::_internal_set_tokentype(const std::string& value) {
  
  tokentype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenResponse::_internal_mutable_tokentype() {
  
  return tokentype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenResponse::release_tokentype() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TokenResponse.tokenType)
  return tokentype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenResponse::set_allocated_tokentype(std::string* tokentype) {
  if (tokentype != nullptr) {
    
  } else {
    
  }
  tokentype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tokentype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TokenResponse.tokenType)
}

// -------------------------------------------------------------------

// ServiceHealth

// bool isHealthy = 1;
inline void ServiceHealth::clear_ishealthy() {
  ishealthy_ = false;
}
inline bool ServiceHealth::_internal_ishealthy() const {
  return ishealthy_;
}
inline bool ServiceHealth::ishealthy() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServiceHealth.isHealthy)
  return _internal_ishealthy();
}
inline void ServiceHealth::_internal_set_ishealthy(bool value) {
  
  ishealthy_ = value;
}
inline void ServiceHealth::set_ishealthy(bool value) {
  _internal_set_ishealthy(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.ServiceHealth.isHealthy)
}

// string name = 2;
inline void ServiceHealth::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServiceHealth::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServiceHealth.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealth::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServiceHealth.name)
}
inline std::string* ServiceHealth::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServiceHealth.name)
  return _s;
}
inline const std::string& ServiceHealth::_internal_name() const {
  return name_.Get();
}
inline void ServiceHealth::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceHealth::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceHealth::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServiceHealth.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceHealth::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServiceHealth.name)
}

// string message = 3;
inline void ServiceHealth::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& ServiceHealth::message() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServiceHealth.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealth::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServiceHealth.message)
}
inline std::string* ServiceHealth::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServiceHealth.message)
  return _s;
}
inline const std::string& ServiceHealth::_internal_message() const {
  return message_.Get();
}
inline void ServiceHealth::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceHealth::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceHealth::release_message() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServiceHealth.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceHealth::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServiceHealth.message)
}

// -------------------------------------------------------------------

// ServerHealthResponse

// bool isHealthy = 1;
inline void ServerHealthResponse::clear_ishealthy() {
  ishealthy_ = false;
}
inline bool ServerHealthResponse::_internal_ishealthy() const {
  return ishealthy_;
}
inline bool ServerHealthResponse::ishealthy() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.isHealthy)
  return _internal_ishealthy();
}
inline void ServerHealthResponse::_internal_set_ishealthy(bool value) {
  
  ishealthy_ = value;
}
inline void ServerHealthResponse::set_ishealthy(bool value) {
  _internal_set_ishealthy(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.isHealthy)
}

// string serverVersion = 2;
inline void ServerHealthResponse::clear_serverversion() {
  serverversion_.ClearToEmpty();
}
inline const std::string& ServerHealthResponse::serverversion() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.serverVersion)
  return _internal_serverversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerHealthResponse::set_serverversion(ArgT0&& arg0, ArgT... args) {
 
 serverversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.serverVersion)
}
inline std::string* ServerHealthResponse::mutable_serverversion() {
  std::string* _s = _internal_mutable_serverversion();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServerHealthResponse.serverVersion)
  return _s;
}
inline const std::string& ServerHealthResponse::_internal_serverversion() const {
  return serverversion_.Get();
}
inline void ServerHealthResponse::_internal_set_serverversion(const std::string& value) {
  
  serverversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::_internal_mutable_serverversion() {
  
  return serverversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::release_serverversion() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServerHealthResponse.serverVersion)
  return serverversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerHealthResponse::set_allocated_serverversion(std::string* serverversion) {
  if (serverversion != nullptr) {
    
  } else {
    
  }
  serverversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServerHealthResponse.serverVersion)
}

// string id = 3;
inline void ServerHealthResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ServerHealthResponse::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerHealthResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.id)
}
inline std::string* ServerHealthResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServerHealthResponse.id)
  return _s;
}
inline const std::string& ServerHealthResponse::_internal_id() const {
  return id_.Get();
}
inline void ServerHealthResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerHealthResponse::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.common.ServerHealthResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerHealthResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.ServerHealthResponse.id)
}

// repeated .sensory.api.common.ServiceHealth services = 4;
inline int ServerHealthResponse::_internal_services_size() const {
  return services_.size();
}
inline int ServerHealthResponse::services_size() const {
  return _internal_services_size();
}
inline void ServerHealthResponse::clear_services() {
  services_.Clear();
}
inline ::sensory::api::common::ServiceHealth* ServerHealthResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.common.ServerHealthResponse.services)
  return services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >*
ServerHealthResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.common.ServerHealthResponse.services)
  return &services_;
}
inline const ::sensory::api::common::ServiceHealth& ServerHealthResponse::_internal_services(int index) const {
  return services_.Get(index);
}
inline const ::sensory::api::common::ServiceHealth& ServerHealthResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.services)
  return _internal_services(index);
}
inline ::sensory::api::common::ServiceHealth* ServerHealthResponse::_internal_add_services() {
  return services_.Add();
}
inline ::sensory::api::common::ServiceHealth* ServerHealthResponse::add_services() {
  ::sensory::api::common::ServiceHealth* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:sensory.api.common.ServerHealthResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::common::ServiceHealth >&
ServerHealthResponse::services() const {
  // @@protoc_insertion_point(field_list:sensory.api.common.ServerHealthResponse.services)
  return services_;
}

// .sensory.api.common.ServerType serverType = 5;
inline void ServerHealthResponse::clear_servertype() {
  servertype_ = 0;
}
inline ::sensory::api::common::ServerType ServerHealthResponse::_internal_servertype() const {
  return static_cast< ::sensory::api::common::ServerType >(servertype_);
}
inline ::sensory::api::common::ServerType ServerHealthResponse::servertype() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.serverType)
  return _internal_servertype();
}
inline void ServerHealthResponse::_internal_set_servertype(::sensory::api::common::ServerType value) {
  
  servertype_ = value;
}
inline void ServerHealthResponse::set_servertype(::sensory::api::common::ServerType value) {
  _internal_set_servertype(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.serverType)
}

// bool isLeader = 6;
inline void ServerHealthResponse::clear_isleader() {
  isleader_ = false;
}
inline bool ServerHealthResponse::_internal_isleader() const {
  return isleader_;
}
inline bool ServerHealthResponse::isleader() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.ServerHealthResponse.isLeader)
  return _internal_isleader();
}
inline void ServerHealthResponse::_internal_set_isleader(bool value) {
  
  isleader_ = value;
}
inline void ServerHealthResponse::set_isleader(bool value) {
  _internal_set_isleader(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.ServerHealthResponse.isLeader)
}

// -------------------------------------------------------------------

// SystemSummary

// .sensory.api.common.CpuSummary cpu = 1 [(.validate.rules) = {
inline bool SystemSummary::_internal_has_cpu() const {
  return this != internal_default_instance() && cpu_ != nullptr;
}
inline bool SystemSummary::has_cpu() const {
  return _internal_has_cpu();
}
inline void SystemSummary::clear_cpu() {
  if (GetArenaForAllocation() == nullptr && cpu_ != nullptr) {
    delete cpu_;
  }
  cpu_ = nullptr;
}
inline const ::sensory::api::common::CpuSummary& SystemSummary::_internal_cpu() const {
  const ::sensory::api::common::CpuSummary* p = cpu_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::CpuSummary&>(
      ::sensory::api::common::_CpuSummary_default_instance_);
}
inline const ::sensory::api::common::CpuSummary& SystemSummary::cpu() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.SystemSummary.cpu)
  return _internal_cpu();
}
inline void SystemSummary::unsafe_arena_set_allocated_cpu(
    ::sensory::api::common::CpuSummary* cpu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cpu_);
  }
  cpu_ = cpu;
  if (cpu) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.common.SystemSummary.cpu)
}
inline ::sensory::api::common::CpuSummary* SystemSummary::release_cpu() {
  
  ::sensory::api::common::CpuSummary* temp = cpu_;
  cpu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::CpuSummary* SystemSummary::unsafe_arena_release_cpu() {
  // @@protoc_insertion_point(field_release:sensory.api.common.SystemSummary.cpu)
  
  ::sensory::api::common::CpuSummary* temp = cpu_;
  cpu_ = nullptr;
  return temp;
}
inline ::sensory::api::common::CpuSummary* SystemSummary::_internal_mutable_cpu() {
  
  if (cpu_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::CpuSummary>(GetArenaForAllocation());
    cpu_ = p;
  }
  return cpu_;
}
inline ::sensory::api::common::CpuSummary* SystemSummary::mutable_cpu() {
  ::sensory::api::common::CpuSummary* _msg = _internal_mutable_cpu();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.SystemSummary.cpu)
  return _msg;
}
inline void SystemSummary::set_allocated_cpu(::sensory::api::common::CpuSummary* cpu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cpu_;
  }
  if (cpu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::common::CpuSummary>::GetOwningArena(cpu);
    if (message_arena != submessage_arena) {
      cpu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpu, submessage_arena);
    }
    
  } else {
    
  }
  cpu_ = cpu;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.SystemSummary.cpu)
}

// .sensory.api.common.MemorySummary memory = 2 [(.validate.rules) = {
inline bool SystemSummary::_internal_has_memory() const {
  return this != internal_default_instance() && memory_ != nullptr;
}
inline bool SystemSummary::has_memory() const {
  return _internal_has_memory();
}
inline void SystemSummary::clear_memory() {
  if (GetArenaForAllocation() == nullptr && memory_ != nullptr) {
    delete memory_;
  }
  memory_ = nullptr;
}
inline const ::sensory::api::common::MemorySummary& SystemSummary::_internal_memory() const {
  const ::sensory::api::common::MemorySummary* p = memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::MemorySummary&>(
      ::sensory::api::common::_MemorySummary_default_instance_);
}
inline const ::sensory::api::common::MemorySummary& SystemSummary::memory() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.SystemSummary.memory)
  return _internal_memory();
}
inline void SystemSummary::unsafe_arena_set_allocated_memory(
    ::sensory::api::common::MemorySummary* memory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(memory_);
  }
  memory_ = memory;
  if (memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.common.SystemSummary.memory)
}
inline ::sensory::api::common::MemorySummary* SystemSummary::release_memory() {
  
  ::sensory::api::common::MemorySummary* temp = memory_;
  memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::MemorySummary* SystemSummary::unsafe_arena_release_memory() {
  // @@protoc_insertion_point(field_release:sensory.api.common.SystemSummary.memory)
  
  ::sensory::api::common::MemorySummary* temp = memory_;
  memory_ = nullptr;
  return temp;
}
inline ::sensory::api::common::MemorySummary* SystemSummary::_internal_mutable_memory() {
  
  if (memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::MemorySummary>(GetArenaForAllocation());
    memory_ = p;
  }
  return memory_;
}
inline ::sensory::api::common::MemorySummary* SystemSummary::mutable_memory() {
  ::sensory::api::common::MemorySummary* _msg = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.SystemSummary.memory)
  return _msg;
}
inline void SystemSummary::set_allocated_memory(::sensory::api::common::MemorySummary* memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete memory_;
  }
  if (memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::common::MemorySummary>::GetOwningArena(memory);
    if (message_arena != submessage_arena) {
      memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, memory, submessage_arena);
    }
    
  } else {
    
  }
  memory_ = memory;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.SystemSummary.memory)
}

// -------------------------------------------------------------------

// CpuSummary

// uint64 user = 1;
inline void CpuSummary::clear_user() {
  user_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_user() const {
  return user_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::user() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.user)
  return _internal_user();
}
inline void CpuSummary::_internal_set_user(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  user_ = value;
}
inline void CpuSummary::set_user(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.user)
}

// uint64 nice = 2;
inline void CpuSummary::clear_nice() {
  nice_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_nice() const {
  return nice_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::nice() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.nice)
  return _internal_nice();
}
inline void CpuSummary::_internal_set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nice_ = value;
}
inline void CpuSummary::set_nice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nice(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.nice)
}

// uint64 system = 3;
inline void CpuSummary::clear_system() {
  system_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_system() const {
  return system_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::system() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.system)
  return _internal_system();
}
inline void CpuSummary::_internal_set_system(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  system_ = value;
}
inline void CpuSummary::set_system(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_system(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.system)
}

// uint64 idle = 4;
inline void CpuSummary::clear_idle() {
  idle_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_idle() const {
  return idle_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::idle() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.idle)
  return _internal_idle();
}
inline void CpuSummary::_internal_set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  idle_ = value;
}
inline void CpuSummary::set_idle(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_idle(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.idle)
}

// uint64 ioWait = 5;
inline void CpuSummary::clear_iowait() {
  iowait_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_iowait() const {
  return iowait_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::iowait() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.ioWait)
  return _internal_iowait();
}
inline void CpuSummary::_internal_set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  iowait_ = value;
}
inline void CpuSummary::set_iowait(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_iowait(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.ioWait)
}

// uint64 irq = 6;
inline void CpuSummary::clear_irq() {
  irq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_irq() const {
  return irq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::irq() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.irq)
  return _internal_irq();
}
inline void CpuSummary::_internal_set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  irq_ = value;
}
inline void CpuSummary::set_irq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_irq(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.irq)
}

// uint64 softIrq = 7;
inline void CpuSummary::clear_softirq() {
  softirq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_softirq() const {
  return softirq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::softirq() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.softIrq)
  return _internal_softirq();
}
inline void CpuSummary::_internal_set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  softirq_ = value;
}
inline void CpuSummary::set_softirq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_softirq(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.softIrq)
}

// uint64 steal = 8;
inline void CpuSummary::clear_steal() {
  steal_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_steal() const {
  return steal_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::steal() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.steal)
  return _internal_steal();
}
inline void CpuSummary::_internal_set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  steal_ = value;
}
inline void CpuSummary::set_steal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_steal(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.steal)
}

// uint64 guest = 9;
inline void CpuSummary::clear_guest() {
  guest_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_guest() const {
  return guest_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::guest() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.guest)
  return _internal_guest();
}
inline void CpuSummary::_internal_set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  guest_ = value;
}
inline void CpuSummary::set_guest(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_guest(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.guest)
}

// uint64 guestNice = 10;
inline void CpuSummary::clear_guestnice() {
  guestnice_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::_internal_guestnice() const {
  return guestnice_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CpuSummary::guestnice() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CpuSummary.guestNice)
  return _internal_guestnice();
}
inline void CpuSummary::_internal_set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  guestnice_ = value;
}
inline void CpuSummary::set_guestnice(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_guestnice(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CpuSummary.guestNice)
}

// -------------------------------------------------------------------

// MemorySummary

// uint64 memTotal = 1;
inline void MemorySummary::clear_memtotal() {
  memtotal_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::_internal_memtotal() const {
  return memtotal_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::memtotal() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.MemorySummary.memTotal)
  return _internal_memtotal();
}
inline void MemorySummary::_internal_set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memtotal_ = value;
}
inline void MemorySummary::set_memtotal(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memtotal(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.MemorySummary.memTotal)
}

// uint64 memFree = 2;
inline void MemorySummary::clear_memfree() {
  memfree_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::_internal_memfree() const {
  return memfree_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::memfree() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.MemorySummary.memFree)
  return _internal_memfree();
}
inline void MemorySummary::_internal_set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memfree_ = value;
}
inline void MemorySummary::set_memfree(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memfree(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.MemorySummary.memFree)
}

// uint64 memAvailable = 3;
inline void MemorySummary::clear_memavailable() {
  memavailable_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::_internal_memavailable() const {
  return memavailable_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MemorySummary::memavailable() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.MemorySummary.memAvailable)
  return _internal_memavailable();
}
inline void MemorySummary::_internal_set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memavailable_ = value;
}
inline void MemorySummary::set_memavailable(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memavailable(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.MemorySummary.memAvailable)
}

// -------------------------------------------------------------------

// GenericClient

// string clientId = 1 [(.validate.rules) = {
inline void GenericClient::clear_clientid() {
  clientid_.ClearToEmpty();
}
inline const std::string& GenericClient::clientid() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.GenericClient.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericClient::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.GenericClient.clientId)
}
inline std::string* GenericClient::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.GenericClient.clientId)
  return _s;
}
inline const std::string& GenericClient::_internal_clientid() const {
  return clientid_.Get();
}
inline void GenericClient::_internal_set_clientid(const std::string& value) {
  
  clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenericClient::_internal_mutable_clientid() {
  
  return clientid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenericClient::release_clientid() {
  // @@protoc_insertion_point(field_release:sensory.api.common.GenericClient.clientId)
  return clientid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenericClient::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  clientid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.GenericClient.clientId)
}

// string secret = 2 [(.validate.rules) = {
inline void GenericClient::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& GenericClient::secret() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.GenericClient.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericClient::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.GenericClient.secret)
}
inline std::string* GenericClient::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.GenericClient.secret)
  return _s;
}
inline const std::string& GenericClient::_internal_secret() const {
  return secret_.Get();
}
inline void GenericClient::_internal_set_secret(const std::string& value) {
  
  secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenericClient::_internal_mutable_secret() {
  
  return secret_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenericClient::release_secret() {
  // @@protoc_insertion_point(field_release:sensory.api.common.GenericClient.secret)
  return secret_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenericClient::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.GenericClient.secret)
}

// -------------------------------------------------------------------

// TenantResponse

// string id = 1;
inline void TenantResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TenantResponse::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TenantResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TenantResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TenantResponse.id)
}
inline std::string* TenantResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TenantResponse.id)
  return _s;
}
inline const std::string& TenantResponse::_internal_id() const {
  return id_.Get();
}
inline void TenantResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TenantResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TenantResponse::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TenantResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TenantResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TenantResponse.id)
}

// string name = 2;
inline void TenantResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TenantResponse::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TenantResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TenantResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.TenantResponse.name)
}
inline std::string* TenantResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TenantResponse.name)
  return _s;
}
inline const std::string& TenantResponse::_internal_name() const {
  return name_.Get();
}
inline void TenantResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TenantResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TenantResponse::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TenantResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TenantResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TenantResponse.name)
}

// .google.protobuf.Timestamp createdAt = 3;
inline bool TenantResponse::_internal_has_createdat() const {
  return this != internal_default_instance() && createdat_ != nullptr;
}
inline bool TenantResponse::has_createdat() const {
  return _internal_has_createdat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TenantResponse::_internal_createdat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = createdat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TenantResponse::createdat() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TenantResponse.createdAt)
  return _internal_createdat();
}
inline void TenantResponse::unsafe_arena_set_allocated_createdat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat_);
  }
  createdat_ = createdat;
  if (createdat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.common.TenantResponse.createdAt)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::release_createdat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = createdat_;
  createdat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::unsafe_arena_release_createdat() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TenantResponse.createdAt)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = createdat_;
  createdat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::_internal_mutable_createdat() {
  
  if (createdat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    createdat_ = p;
  }
  return createdat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::mutable_createdat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_createdat();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TenantResponse.createdAt)
  return _msg;
}
inline void TenantResponse::set_allocated_createdat(::PROTOBUF_NAMESPACE_ID::Timestamp* createdat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat_);
  }
  if (createdat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat));
    if (message_arena != submessage_arena) {
      createdat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createdat, submessage_arena);
    }
    
  } else {
    
  }
  createdat_ = createdat;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TenantResponse.createdAt)
}

// .google.protobuf.Timestamp updatedAt = 4;
inline bool TenantResponse::_internal_has_updatedat() const {
  return this != internal_default_instance() && updatedat_ != nullptr;
}
inline bool TenantResponse::has_updatedat() const {
  return _internal_has_updatedat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TenantResponse::_internal_updatedat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updatedat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TenantResponse::updatedat() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.TenantResponse.updatedAt)
  return _internal_updatedat();
}
inline void TenantResponse::unsafe_arena_set_allocated_updatedat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat_);
  }
  updatedat_ = updatedat;
  if (updatedat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.common.TenantResponse.updatedAt)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::release_updatedat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updatedat_;
  updatedat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::unsafe_arena_release_updatedat() {
  // @@protoc_insertion_point(field_release:sensory.api.common.TenantResponse.updatedAt)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updatedat_;
  updatedat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::_internal_mutable_updatedat() {
  
  if (updatedat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updatedat_ = p;
  }
  return updatedat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TenantResponse::mutable_updatedat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updatedat();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.TenantResponse.updatedAt)
  return _msg;
}
inline void TenantResponse::set_allocated_updatedat(::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat_);
  }
  if (updatedat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat));
    if (message_arena != submessage_arena) {
      updatedat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updatedat, submessage_arena);
    }
    
  } else {
    
  }
  updatedat_ = updatedat;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.TenantResponse.updatedAt)
}

// -------------------------------------------------------------------

// PaginationOptions

// string ordering = 1;
inline void PaginationOptions::clear_ordering() {
  ordering_.ClearToEmpty();
}
inline const std::string& PaginationOptions::ordering() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationOptions.ordering)
  return _internal_ordering();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationOptions::set_ordering(ArgT0&& arg0, ArgT... args) {
 
 ordering_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationOptions.ordering)
}
inline std::string* PaginationOptions::mutable_ordering() {
  std::string* _s = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.PaginationOptions.ordering)
  return _s;
}
inline const std::string& PaginationOptions::_internal_ordering() const {
  return ordering_.Get();
}
inline void PaginationOptions::_internal_set_ordering(const std::string& value) {
  
  ordering_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PaginationOptions::_internal_mutable_ordering() {
  
  return ordering_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PaginationOptions::release_ordering() {
  // @@protoc_insertion_point(field_release:sensory.api.common.PaginationOptions.ordering)
  return ordering_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PaginationOptions::set_allocated_ordering(std::string* ordering) {
  if (ordering != nullptr) {
    
  } else {
    
  }
  ordering_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ordering,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.PaginationOptions.ordering)
}

// bool decending = 2;
inline void PaginationOptions::clear_decending() {
  decending_ = false;
}
inline bool PaginationOptions::_internal_decending() const {
  return decending_;
}
inline bool PaginationOptions::decending() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationOptions.decending)
  return _internal_decending();
}
inline void PaginationOptions::_internal_set_decending(bool value) {
  
  decending_ = value;
}
inline void PaginationOptions::set_decending(bool value) {
  _internal_set_decending(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationOptions.decending)
}

// int32 pageIndex = 3;
inline void PaginationOptions::clear_pageindex() {
  pageindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationOptions::_internal_pageindex() const {
  return pageindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationOptions::pageindex() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationOptions.pageIndex)
  return _internal_pageindex();
}
inline void PaginationOptions::_internal_set_pageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pageindex_ = value;
}
inline void PaginationOptions::set_pageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pageindex(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationOptions.pageIndex)
}

// int32 pageSize = 4;
inline void PaginationOptions::clear_pagesize() {
  pagesize_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationOptions::_internal_pagesize() const {
  return pagesize_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationOptions::pagesize() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationOptions.pageSize)
  return _internal_pagesize();
}
inline void PaginationOptions::_internal_set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pagesize_ = value;
}
inline void PaginationOptions::set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pagesize(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationOptions.pageSize)
}

// -------------------------------------------------------------------

// PaginationResponse

// string ordering = 1;
inline void PaginationResponse::clear_ordering() {
  ordering_.ClearToEmpty();
}
inline const std::string& PaginationResponse::ordering() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.ordering)
  return _internal_ordering();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationResponse::set_ordering(ArgT0&& arg0, ArgT... args) {
 
 ordering_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.ordering)
}
inline std::string* PaginationResponse::mutable_ordering() {
  std::string* _s = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.PaginationResponse.ordering)
  return _s;
}
inline const std::string& PaginationResponse::_internal_ordering() const {
  return ordering_.Get();
}
inline void PaginationResponse::_internal_set_ordering(const std::string& value) {
  
  ordering_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PaginationResponse::_internal_mutable_ordering() {
  
  return ordering_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PaginationResponse::release_ordering() {
  // @@protoc_insertion_point(field_release:sensory.api.common.PaginationResponse.ordering)
  return ordering_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PaginationResponse::set_allocated_ordering(std::string* ordering) {
  if (ordering != nullptr) {
    
  } else {
    
  }
  ordering_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ordering,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.PaginationResponse.ordering)
}

// bool decending = 2;
inline void PaginationResponse::clear_decending() {
  decending_ = false;
}
inline bool PaginationResponse::_internal_decending() const {
  return decending_;
}
inline bool PaginationResponse::decending() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.decending)
  return _internal_decending();
}
inline void PaginationResponse::_internal_set_decending(bool value) {
  
  decending_ = value;
}
inline void PaginationResponse::set_decending(bool value) {
  _internal_set_decending(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.decending)
}

// repeated string possibleOrderings = 3;
inline int PaginationResponse::_internal_possibleorderings_size() const {
  return possibleorderings_.size();
}
inline int PaginationResponse::possibleorderings_size() const {
  return _internal_possibleorderings_size();
}
inline void PaginationResponse::clear_possibleorderings() {
  possibleorderings_.Clear();
}
inline std::string* PaginationResponse::add_possibleorderings() {
  std::string* _s = _internal_add_possibleorderings();
  // @@protoc_insertion_point(field_add_mutable:sensory.api.common.PaginationResponse.possibleOrderings)
  return _s;
}
inline const std::string& PaginationResponse::_internal_possibleorderings(int index) const {
  return possibleorderings_.Get(index);
}
inline const std::string& PaginationResponse::possibleorderings(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.possibleOrderings)
  return _internal_possibleorderings(index);
}
inline std::string* PaginationResponse::mutable_possibleorderings(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.common.PaginationResponse.possibleOrderings)
  return possibleorderings_.Mutable(index);
}
inline void PaginationResponse::set_possibleorderings(int index, const std::string& value) {
  possibleorderings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline void PaginationResponse::set_possibleorderings(int index, std::string&& value) {
  possibleorderings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline void PaginationResponse::set_possibleorderings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  possibleorderings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline void PaginationResponse::set_possibleorderings(int index, const char* value, size_t size) {
  possibleorderings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline std::string* PaginationResponse::_internal_add_possibleorderings() {
  return possibleorderings_.Add();
}
inline void PaginationResponse::add_possibleorderings(const std::string& value) {
  possibleorderings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline void PaginationResponse::add_possibleorderings(std::string&& value) {
  possibleorderings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline void PaginationResponse::add_possibleorderings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  possibleorderings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline void PaginationResponse::add_possibleorderings(const char* value, size_t size) {
  possibleorderings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensory.api.common.PaginationResponse.possibleOrderings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PaginationResponse::possibleorderings() const {
  // @@protoc_insertion_point(field_list:sensory.api.common.PaginationResponse.possibleOrderings)
  return possibleorderings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PaginationResponse::mutable_possibleorderings() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.common.PaginationResponse.possibleOrderings)
  return &possibleorderings_;
}

// int64 totalCount = 4;
inline void PaginationResponse::clear_totalcount() {
  totalcount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaginationResponse::_internal_totalcount() const {
  return totalcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaginationResponse::totalcount() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.totalCount)
  return _internal_totalcount();
}
inline void PaginationResponse::_internal_set_totalcount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalcount_ = value;
}
inline void PaginationResponse::set_totalcount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalcount(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.totalCount)
}

// int32 pageSize = 5;
inline void PaginationResponse::clear_pagesize() {
  pagesize_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::_internal_pagesize() const {
  return pagesize_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::pagesize() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.pageSize)
  return _internal_pagesize();
}
inline void PaginationResponse::_internal_set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pagesize_ = value;
}
inline void PaginationResponse::set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pagesize(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.pageSize)
}

// int32 prevPageIndex = 6;
inline void PaginationResponse::clear_prevpageindex() {
  prevpageindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::_internal_prevpageindex() const {
  return prevpageindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::prevpageindex() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.prevPageIndex)
  return _internal_prevpageindex();
}
inline void PaginationResponse::_internal_set_prevpageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  prevpageindex_ = value;
}
inline void PaginationResponse::set_prevpageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_prevpageindex(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.prevPageIndex)
}

// int32 currentPageIndex = 7;
inline void PaginationResponse::clear_currentpageindex() {
  currentpageindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::_internal_currentpageindex() const {
  return currentpageindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::currentpageindex() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.currentPageIndex)
  return _internal_currentpageindex();
}
inline void PaginationResponse::_internal_set_currentpageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  currentpageindex_ = value;
}
inline void PaginationResponse::set_currentpageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_currentpageindex(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.currentPageIndex)
}

// int32 nextPageIndex = 8;
inline void PaginationResponse::clear_nextpageindex() {
  nextpageindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::_internal_nextpageindex() const {
  return nextpageindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaginationResponse::nextpageindex() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.PaginationResponse.nextPageIndex)
  return _internal_nextpageindex();
}
inline void PaginationResponse::_internal_set_nextpageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nextpageindex_ = value;
}
inline void PaginationResponse::set_nextpageindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nextpageindex(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.PaginationResponse.nextPageIndex)
}

// -------------------------------------------------------------------

// EnrollmentToken

// bytes token = 1;
inline void EnrollmentToken::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& EnrollmentToken::token() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.EnrollmentToken.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentToken::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.EnrollmentToken.token)
}
inline std::string* EnrollmentToken::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.EnrollmentToken.token)
  return _s;
}
inline const std::string& EnrollmentToken::_internal_token() const {
  return token_.Get();
}
inline void EnrollmentToken::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentToken::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentToken::release_token() {
  // @@protoc_insertion_point(field_release:sensory.api.common.EnrollmentToken.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentToken::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.EnrollmentToken.token)
}

// int64 expiration = 2;
inline void EnrollmentToken::clear_expiration() {
  expiration_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EnrollmentToken::_internal_expiration() const {
  return expiration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EnrollmentToken::expiration() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.EnrollmentToken.expiration)
  return _internal_expiration();
}
inline void EnrollmentToken::_internal_set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  expiration_ = value;
}
inline void EnrollmentToken::set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.EnrollmentToken.expiration)
}

// -------------------------------------------------------------------

// CreateKeyRequest

// string name = 1 [(.validate.rules) = {
inline void CreateKeyRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CreateKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.CreateKeyRequest.name)
}
inline std::string* CreateKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.CreateKeyRequest.name)
  return _s;
}
inline const std::string& CreateKeyRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateKeyRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.common.CreateKeyRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.CreateKeyRequest.name)
}

// .sensory.api.common.KeyType keyType = 2 [(.validate.rules) = {
inline void CreateKeyRequest::clear_keytype() {
  keytype_ = 0;
}
inline ::sensory::api::common::KeyType CreateKeyRequest::_internal_keytype() const {
  return static_cast< ::sensory::api::common::KeyType >(keytype_);
}
inline ::sensory::api::common::KeyType CreateKeyRequest::keytype() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CreateKeyRequest.keyType)
  return _internal_keytype();
}
inline void CreateKeyRequest::_internal_set_keytype(::sensory::api::common::KeyType value) {
  
  keytype_ = value;
}
inline void CreateKeyRequest::set_keytype(::sensory::api::common::KeyType value) {
  _internal_set_keytype(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CreateKeyRequest.keyType)
}

// string value = 3;
inline void CreateKeyRequest::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& CreateKeyRequest::value() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CreateKeyRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateKeyRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.CreateKeyRequest.value)
}
inline std::string* CreateKeyRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.CreateKeyRequest.value)
  return _s;
}
inline const std::string& CreateKeyRequest::_internal_value() const {
  return value_.Get();
}
inline void CreateKeyRequest::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateKeyRequest::release_value() {
  // @@protoc_insertion_point(field_release:sensory.api.common.CreateKeyRequest.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateKeyRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.CreateKeyRequest.value)
}

// int64 expiration = 4;
inline void CreateKeyRequest::clear_expiration() {
  expiration_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateKeyRequest::_internal_expiration() const {
  return expiration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateKeyRequest::expiration() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.CreateKeyRequest.expiration)
  return _internal_expiration();
}
inline void CreateKeyRequest::_internal_set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  expiration_ = value;
}
inline void CreateKeyRequest::set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.CreateKeyRequest.expiration)
}

// -------------------------------------------------------------------

// KeyResponse

// string id = 1;
inline void KeyResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& KeyResponse::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.KeyResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.KeyResponse.id)
}
inline std::string* KeyResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.KeyResponse.id)
  return _s;
}
inline const std::string& KeyResponse::_internal_id() const {
  return id_.Get();
}
inline void KeyResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyResponse::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.common.KeyResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.KeyResponse.id)
}

// string name = 2;
inline void KeyResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& KeyResponse::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.KeyResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.KeyResponse.name)
}
inline std::string* KeyResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.KeyResponse.name)
  return _s;
}
inline const std::string& KeyResponse::_internal_name() const {
  return name_.Get();
}
inline void KeyResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyResponse::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.common.KeyResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.KeyResponse.name)
}

// .sensory.api.common.KeyType keyType = 3;
inline void KeyResponse::clear_keytype() {
  keytype_ = 0;
}
inline ::sensory::api::common::KeyType KeyResponse::_internal_keytype() const {
  return static_cast< ::sensory::api::common::KeyType >(keytype_);
}
inline ::sensory::api::common::KeyType KeyResponse::keytype() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.KeyResponse.keyType)
  return _internal_keytype();
}
inline void KeyResponse::_internal_set_keytype(::sensory::api::common::KeyType value) {
  
  keytype_ = value;
}
inline void KeyResponse::set_keytype(::sensory::api::common::KeyType value) {
  _internal_set_keytype(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.KeyResponse.keyType)
}

// int64 expiration = 4;
inline void KeyResponse::clear_expiration() {
  expiration_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 KeyResponse::_internal_expiration() const {
  return expiration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 KeyResponse::expiration() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.KeyResponse.expiration)
  return _internal_expiration();
}
inline void KeyResponse::_internal_set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  expiration_ = value;
}
inline void KeyResponse::set_expiration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.KeyResponse.expiration)
}

// string tenantId = 5;
inline void KeyResponse::clear_tenantid() {
  tenantid_.ClearToEmpty();
}
inline const std::string& KeyResponse::tenantid() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.KeyResponse.tenantId)
  return _internal_tenantid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyResponse::set_tenantid(ArgT0&& arg0, ArgT... args) {
 
 tenantid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.common.KeyResponse.tenantId)
}
inline std::string* KeyResponse::mutable_tenantid() {
  std::string* _s = _internal_mutable_tenantid();
  // @@protoc_insertion_point(field_mutable:sensory.api.common.KeyResponse.tenantId)
  return _s;
}
inline const std::string& KeyResponse::_internal_tenantid() const {
  return tenantid_.Get();
}
inline void KeyResponse::_internal_set_tenantid(const std::string& value) {
  
  tenantid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyResponse::_internal_mutable_tenantid() {
  
  return tenantid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyResponse::release_tenantid() {
  // @@protoc_insertion_point(field_release:sensory.api.common.KeyResponse.tenantId)
  return tenantid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyResponse::set_allocated_tenantid(std::string* tenantid) {
  if (tenantid != nullptr) {
    
  } else {
    
  }
  tenantid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tenantid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.common.KeyResponse.tenantId)
}

// bool disabled = 6;
inline void KeyResponse::clear_disabled() {
  disabled_ = false;
}
inline bool KeyResponse::_internal_disabled() const {
  return disabled_;
}
inline bool KeyResponse::disabled() const {
  // @@protoc_insertion_point(field_get:sensory.api.common.KeyResponse.disabled)
  return _internal_disabled();
}
inline void KeyResponse::_internal_set_disabled(bool value) {
  
  disabled_ = value;
}
inline void KeyResponse::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:sensory.api.common.KeyResponse.disabled)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace api
}  // namespace sensory

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensory::api::common::Void> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::Void>() {
  return ::sensory::api::common::Void_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::KeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::KeyType>() {
  return ::sensory::api::common::KeyType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::FeatureFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::FeatureFlag>() {
  return ::sensory::api::common::FeatureFlag_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::ModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::ModelType>() {
  return ::sensory::api::common::ModelType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::TechnologyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::TechnologyType>() {
  return ::sensory::api::common::TechnologyType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::CompressionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::CompressionType>() {
  return ::sensory::api::common::CompressionType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::ClientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::ClientType>() {
  return ::sensory::api::common::ClientType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::UsageEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::UsageEventType>() {
  return ::sensory::api::common::UsageEventType_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::common::ServerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::common::ServerType>() {
  return ::sensory::api::common::ServerType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_2eproto
