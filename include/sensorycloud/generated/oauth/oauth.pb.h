// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: oauth/oauth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_oauth_2foauth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_oauth_2foauth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "validate/validate.pb.h"
#include "common/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_oauth_2foauth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_oauth_2foauth_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_oauth_2foauth_2eproto;
namespace sensory {
namespace api {
namespace oauth {
class PublicKeyRequest;
struct PublicKeyRequestDefaultTypeInternal;
extern PublicKeyRequestDefaultTypeInternal _PublicKeyRequest_default_instance_;
class PublicKeyResponse;
struct PublicKeyResponseDefaultTypeInternal;
extern PublicKeyResponseDefaultTypeInternal _PublicKeyResponse_default_instance_;
class SignTokenRequest;
struct SignTokenRequestDefaultTypeInternal;
extern SignTokenRequestDefaultTypeInternal _SignTokenRequest_default_instance_;
class TokenRequest;
struct TokenRequestDefaultTypeInternal;
extern TokenRequestDefaultTypeInternal _TokenRequest_default_instance_;
class WhoAmIRequest;
struct WhoAmIRequestDefaultTypeInternal;
extern WhoAmIRequestDefaultTypeInternal _WhoAmIRequest_default_instance_;
class WhoAmIResponse;
struct WhoAmIResponseDefaultTypeInternal;
extern WhoAmIResponseDefaultTypeInternal _WhoAmIResponse_default_instance_;
}  // namespace oauth
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::oauth::PublicKeyRequest* Arena::CreateMaybeMessage<::sensory::api::oauth::PublicKeyRequest>(Arena*);
template<> ::sensory::api::oauth::PublicKeyResponse* Arena::CreateMaybeMessage<::sensory::api::oauth::PublicKeyResponse>(Arena*);
template<> ::sensory::api::oauth::SignTokenRequest* Arena::CreateMaybeMessage<::sensory::api::oauth::SignTokenRequest>(Arena*);
template<> ::sensory::api::oauth::TokenRequest* Arena::CreateMaybeMessage<::sensory::api::oauth::TokenRequest>(Arena*);
template<> ::sensory::api::oauth::WhoAmIRequest* Arena::CreateMaybeMessage<::sensory::api::oauth::WhoAmIRequest>(Arena*);
template<> ::sensory::api::oauth::WhoAmIResponse* Arena::CreateMaybeMessage<::sensory::api::oauth::WhoAmIResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace oauth {

enum SignTokenRequest_TokenScope : int {
  SignTokenRequest_TokenScope_USER = 0,
  SignTokenRequest_TokenScope_SUPER_ADMIN = 1,
  SignTokenRequest_TokenScope_BILLING_ADMIN = 2,
  SignTokenRequest_TokenScope_READ_ONLY_ADMIN = 3,
  SignTokenRequest_TokenScope_SignTokenRequest_TokenScope_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SignTokenRequest_TokenScope_SignTokenRequest_TokenScope_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SignTokenRequest_TokenScope_IsValid(int value);
constexpr SignTokenRequest_TokenScope SignTokenRequest_TokenScope_TokenScope_MIN = SignTokenRequest_TokenScope_USER;
constexpr SignTokenRequest_TokenScope SignTokenRequest_TokenScope_TokenScope_MAX = SignTokenRequest_TokenScope_READ_ONLY_ADMIN;
constexpr int SignTokenRequest_TokenScope_TokenScope_ARRAYSIZE = SignTokenRequest_TokenScope_TokenScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignTokenRequest_TokenScope_descriptor();
template<typename T>
inline const std::string& SignTokenRequest_TokenScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignTokenRequest_TokenScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignTokenRequest_TokenScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignTokenRequest_TokenScope_descriptor(), enum_t_value);
}
inline bool SignTokenRequest_TokenScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignTokenRequest_TokenScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignTokenRequest_TokenScope>(
    SignTokenRequest_TokenScope_descriptor(), name, value);
}
// ===================================================================

class TokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.oauth.TokenRequest) */ {
 public:
  inline TokenRequest() : TokenRequest(nullptr) {}
  ~TokenRequest() override;
  explicit constexpr TokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenRequest(const TokenRequest& from);
  TokenRequest(TokenRequest&& from) noexcept
    : TokenRequest() {
    *this = ::std::move(from);
  }

  inline TokenRequest& operator=(const TokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenRequest& operator=(TokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenRequest* internal_default_instance() {
    return reinterpret_cast<const TokenRequest*>(
               &_TokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TokenRequest& a, TokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TokenRequest* New() const final {
    return new TokenRequest();
  }

  TokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TokenRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.oauth.TokenRequest";
  }
  protected:
  explicit TokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kSecretFieldNumber = 2,
  };
  // string clientId = 1 [(.validate.rules) = {
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_MUST_USE_RESULT std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string secret = 2;
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_MUST_USE_RESULT std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.oauth.TokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_oauth_2foauth_2eproto;
};
// -------------------------------------------------------------------

class SignTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.oauth.SignTokenRequest) */ {
 public:
  inline SignTokenRequest() : SignTokenRequest(nullptr) {}
  ~SignTokenRequest() override;
  explicit constexpr SignTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignTokenRequest(const SignTokenRequest& from);
  SignTokenRequest(SignTokenRequest&& from) noexcept
    : SignTokenRequest() {
    *this = ::std::move(from);
  }

  inline SignTokenRequest& operator=(const SignTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignTokenRequest& operator=(SignTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignTokenRequest* internal_default_instance() {
    return reinterpret_cast<const SignTokenRequest*>(
               &_SignTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignTokenRequest& a, SignTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignTokenRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignTokenRequest* New() const final {
    return new SignTokenRequest();
  }

  SignTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignTokenRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignTokenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.oauth.SignTokenRequest";
  }
  protected:
  explicit SignTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SignTokenRequest_TokenScope TokenScope;
  static constexpr TokenScope USER =
    SignTokenRequest_TokenScope_USER;
  static constexpr TokenScope SUPER_ADMIN =
    SignTokenRequest_TokenScope_SUPER_ADMIN;
  static constexpr TokenScope BILLING_ADMIN =
    SignTokenRequest_TokenScope_BILLING_ADMIN;
  static constexpr TokenScope READ_ONLY_ADMIN =
    SignTokenRequest_TokenScope_READ_ONLY_ADMIN;
  static inline bool TokenScope_IsValid(int value) {
    return SignTokenRequest_TokenScope_IsValid(value);
  }
  static constexpr TokenScope TokenScope_MIN =
    SignTokenRequest_TokenScope_TokenScope_MIN;
  static constexpr TokenScope TokenScope_MAX =
    SignTokenRequest_TokenScope_TokenScope_MAX;
  static constexpr int TokenScope_ARRAYSIZE =
    SignTokenRequest_TokenScope_TokenScope_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TokenScope_descriptor() {
    return SignTokenRequest_TokenScope_descriptor();
  }
  template<typename T>
  static inline const std::string& TokenScope_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TokenScope>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TokenScope_Name.");
    return SignTokenRequest_TokenScope_Name(enum_t_value);
  }
  static inline bool TokenScope_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TokenScope* value) {
    return SignTokenRequest_TokenScope_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kScopeFieldNumber = 2,
  };
  // string subject = 1 [(.validate.rules) = {
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_MUST_USE_RESULT std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // .sensory.api.oauth.SignTokenRequest.TokenScope scope = 2 [(.validate.rules) = {
  void clear_scope();
  ::sensory::api::oauth::SignTokenRequest_TokenScope scope() const;
  void set_scope(::sensory::api::oauth::SignTokenRequest_TokenScope value);
  private:
  ::sensory::api::oauth::SignTokenRequest_TokenScope _internal_scope() const;
  void _internal_set_scope(::sensory::api::oauth::SignTokenRequest_TokenScope value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.oauth.SignTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
  int scope_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_oauth_2foauth_2eproto;
};
// -------------------------------------------------------------------

class WhoAmIRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.oauth.WhoAmIRequest) */ {
 public:
  inline WhoAmIRequest() : WhoAmIRequest(nullptr) {}
  ~WhoAmIRequest() override;
  explicit constexpr WhoAmIRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WhoAmIRequest(const WhoAmIRequest& from);
  WhoAmIRequest(WhoAmIRequest&& from) noexcept
    : WhoAmIRequest() {
    *this = ::std::move(from);
  }

  inline WhoAmIRequest& operator=(const WhoAmIRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhoAmIRequest& operator=(WhoAmIRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhoAmIRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhoAmIRequest* internal_default_instance() {
    return reinterpret_cast<const WhoAmIRequest*>(
               &_WhoAmIRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WhoAmIRequest& a, WhoAmIRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WhoAmIRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhoAmIRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WhoAmIRequest* New() const final {
    return new WhoAmIRequest();
  }

  WhoAmIRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WhoAmIRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WhoAmIRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WhoAmIRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WhoAmIRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.oauth.WhoAmIRequest";
  }
  protected:
  explicit WhoAmIRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensory.api.oauth.WhoAmIRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_oauth_2foauth_2eproto;
};
// -------------------------------------------------------------------

class WhoAmIResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.oauth.WhoAmIResponse) */ {
 public:
  inline WhoAmIResponse() : WhoAmIResponse(nullptr) {}
  ~WhoAmIResponse() override;
  explicit constexpr WhoAmIResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WhoAmIResponse(const WhoAmIResponse& from);
  WhoAmIResponse(WhoAmIResponse&& from) noexcept
    : WhoAmIResponse() {
    *this = ::std::move(from);
  }

  inline WhoAmIResponse& operator=(const WhoAmIResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhoAmIResponse& operator=(WhoAmIResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhoAmIResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhoAmIResponse* internal_default_instance() {
    return reinterpret_cast<const WhoAmIResponse*>(
               &_WhoAmIResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WhoAmIResponse& a, WhoAmIResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WhoAmIResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhoAmIResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WhoAmIResponse* New() const final {
    return new WhoAmIResponse();
  }

  WhoAmIResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WhoAmIResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WhoAmIResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WhoAmIResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WhoAmIResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.oauth.WhoAmIResponse";
  }
  protected:
  explicit WhoAmIResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kTenantIdFieldNumber = 2,
  };
  // string clientId = 1;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_MUST_USE_RESULT std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string tenantId = 2;
  void clear_tenantid();
  const std::string& tenantid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenantid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenantid();
  PROTOBUF_MUST_USE_RESULT std::string* release_tenantid();
  void set_allocated_tenantid(std::string* tenantid);
  private:
  const std::string& _internal_tenantid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenantid(const std::string& value);
  std::string* _internal_mutable_tenantid();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.oauth.WhoAmIResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenantid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_oauth_2foauth_2eproto;
};
// -------------------------------------------------------------------

class PublicKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.oauth.PublicKeyRequest) */ {
 public:
  inline PublicKeyRequest() : PublicKeyRequest(nullptr) {}
  ~PublicKeyRequest() override;
  explicit constexpr PublicKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicKeyRequest(const PublicKeyRequest& from);
  PublicKeyRequest(PublicKeyRequest&& from) noexcept
    : PublicKeyRequest() {
    *this = ::std::move(from);
  }

  inline PublicKeyRequest& operator=(const PublicKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicKeyRequest& operator=(PublicKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicKeyRequest* internal_default_instance() {
    return reinterpret_cast<const PublicKeyRequest*>(
               &_PublicKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PublicKeyRequest& a, PublicKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublicKeyRequest* New() const final {
    return new PublicKeyRequest();
  }

  PublicKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublicKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PublicKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.oauth.PublicKeyRequest";
  }
  protected:
  explicit PublicKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
  };
  // string keyId = 1 [(.validate.rules) = {
  void clear_keyid();
  const std::string& keyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyid();
  PROTOBUF_MUST_USE_RESULT std::string* release_keyid();
  void set_allocated_keyid(std::string* keyid);
  private:
  const std::string& _internal_keyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyid(const std::string& value);
  std::string* _internal_mutable_keyid();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.oauth.PublicKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_oauth_2foauth_2eproto;
};
// -------------------------------------------------------------------

class PublicKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.oauth.PublicKeyResponse) */ {
 public:
  inline PublicKeyResponse() : PublicKeyResponse(nullptr) {}
  ~PublicKeyResponse() override;
  explicit constexpr PublicKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicKeyResponse(const PublicKeyResponse& from);
  PublicKeyResponse(PublicKeyResponse&& from) noexcept
    : PublicKeyResponse() {
    *this = ::std::move(from);
  }

  inline PublicKeyResponse& operator=(const PublicKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicKeyResponse& operator=(PublicKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicKeyResponse* internal_default_instance() {
    return reinterpret_cast<const PublicKeyResponse*>(
               &_PublicKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PublicKeyResponse& a, PublicKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicKeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublicKeyResponse* New() const final {
    return new PublicKeyResponse();
  }

  PublicKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublicKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PublicKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicKeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.oauth.PublicKeyResponse";
  }
  protected:
  explicit PublicKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kKeyTypeFieldNumber = 2,
  };
  // bytes publicKey = 1;
  void clear_publickey();
  const std::string& publickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey();
  PROTOBUF_MUST_USE_RESULT std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // .sensory.api.common.KeyType keyType = 2;
  void clear_keytype();
  ::sensory::api::common::KeyType keytype() const;
  void set_keytype(::sensory::api::common::KeyType value);
  private:
  ::sensory::api::common::KeyType _internal_keytype() const;
  void _internal_set_keytype(::sensory::api::common::KeyType value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.oauth.PublicKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
  int keytype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_oauth_2foauth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TokenRequest

// string clientId = 1 [(.validate.rules) = {
inline void TokenRequest::clear_clientid() {
  clientid_.ClearToEmpty();
}
inline const std::string& TokenRequest::clientid() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.TokenRequest.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenRequest::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.oauth.TokenRequest.clientId)
}
inline std::string* TokenRequest::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:sensory.api.oauth.TokenRequest.clientId)
  return _s;
}
inline const std::string& TokenRequest::_internal_clientid() const {
  return clientid_.Get();
}
inline void TokenRequest::_internal_set_clientid(const std::string& value) {
  
  clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenRequest::_internal_mutable_clientid() {
  
  return clientid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenRequest::release_clientid() {
  // @@protoc_insertion_point(field_release:sensory.api.oauth.TokenRequest.clientId)
  return clientid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenRequest::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  clientid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.oauth.TokenRequest.clientId)
}

// string secret = 2;
inline void TokenRequest::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& TokenRequest::secret() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.TokenRequest.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenRequest::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.oauth.TokenRequest.secret)
}
inline std::string* TokenRequest::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:sensory.api.oauth.TokenRequest.secret)
  return _s;
}
inline const std::string& TokenRequest::_internal_secret() const {
  return secret_.Get();
}
inline void TokenRequest::_internal_set_secret(const std::string& value) {
  
  secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TokenRequest::_internal_mutable_secret() {
  
  return secret_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TokenRequest::release_secret() {
  // @@protoc_insertion_point(field_release:sensory.api.oauth.TokenRequest.secret)
  return secret_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TokenRequest::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.oauth.TokenRequest.secret)
}

// -------------------------------------------------------------------

// SignTokenRequest

// string subject = 1 [(.validate.rules) = {
inline void SignTokenRequest::clear_subject() {
  subject_.ClearToEmpty();
}
inline const std::string& SignTokenRequest::subject() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.SignTokenRequest.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignTokenRequest::set_subject(ArgT0&& arg0, ArgT... args) {
 
 subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.oauth.SignTokenRequest.subject)
}
inline std::string* SignTokenRequest::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:sensory.api.oauth.SignTokenRequest.subject)
  return _s;
}
inline const std::string& SignTokenRequest::_internal_subject() const {
  return subject_.Get();
}
inline void SignTokenRequest::_internal_set_subject(const std::string& value) {
  
  subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignTokenRequest::_internal_mutable_subject() {
  
  return subject_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignTokenRequest::release_subject() {
  // @@protoc_insertion_point(field_release:sensory.api.oauth.SignTokenRequest.subject)
  return subject_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignTokenRequest::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  subject_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subject,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.oauth.SignTokenRequest.subject)
}

// .sensory.api.oauth.SignTokenRequest.TokenScope scope = 2 [(.validate.rules) = {
inline void SignTokenRequest::clear_scope() {
  scope_ = 0;
}
inline ::sensory::api::oauth::SignTokenRequest_TokenScope SignTokenRequest::_internal_scope() const {
  return static_cast< ::sensory::api::oauth::SignTokenRequest_TokenScope >(scope_);
}
inline ::sensory::api::oauth::SignTokenRequest_TokenScope SignTokenRequest::scope() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.SignTokenRequest.scope)
  return _internal_scope();
}
inline void SignTokenRequest::_internal_set_scope(::sensory::api::oauth::SignTokenRequest_TokenScope value) {
  
  scope_ = value;
}
inline void SignTokenRequest::set_scope(::sensory::api::oauth::SignTokenRequest_TokenScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:sensory.api.oauth.SignTokenRequest.scope)
}

// -------------------------------------------------------------------

// WhoAmIRequest

// -------------------------------------------------------------------

// WhoAmIResponse

// string clientId = 1;
inline void WhoAmIResponse::clear_clientid() {
  clientid_.ClearToEmpty();
}
inline const std::string& WhoAmIResponse::clientid() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.WhoAmIResponse.clientId)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WhoAmIResponse::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.oauth.WhoAmIResponse.clientId)
}
inline std::string* WhoAmIResponse::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:sensory.api.oauth.WhoAmIResponse.clientId)
  return _s;
}
inline const std::string& WhoAmIResponse::_internal_clientid() const {
  return clientid_.Get();
}
inline void WhoAmIResponse::_internal_set_clientid(const std::string& value) {
  
  clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WhoAmIResponse::_internal_mutable_clientid() {
  
  return clientid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WhoAmIResponse::release_clientid() {
  // @@protoc_insertion_point(field_release:sensory.api.oauth.WhoAmIResponse.clientId)
  return clientid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WhoAmIResponse::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  clientid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.oauth.WhoAmIResponse.clientId)
}

// string tenantId = 2;
inline void WhoAmIResponse::clear_tenantid() {
  tenantid_.ClearToEmpty();
}
inline const std::string& WhoAmIResponse::tenantid() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.WhoAmIResponse.tenantId)
  return _internal_tenantid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WhoAmIResponse::set_tenantid(ArgT0&& arg0, ArgT... args) {
 
 tenantid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.oauth.WhoAmIResponse.tenantId)
}
inline std::string* WhoAmIResponse::mutable_tenantid() {
  std::string* _s = _internal_mutable_tenantid();
  // @@protoc_insertion_point(field_mutable:sensory.api.oauth.WhoAmIResponse.tenantId)
  return _s;
}
inline const std::string& WhoAmIResponse::_internal_tenantid() const {
  return tenantid_.Get();
}
inline void WhoAmIResponse::_internal_set_tenantid(const std::string& value) {
  
  tenantid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WhoAmIResponse::_internal_mutable_tenantid() {
  
  return tenantid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WhoAmIResponse::release_tenantid() {
  // @@protoc_insertion_point(field_release:sensory.api.oauth.WhoAmIResponse.tenantId)
  return tenantid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WhoAmIResponse::set_allocated_tenantid(std::string* tenantid) {
  if (tenantid != nullptr) {
    
  } else {
    
  }
  tenantid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tenantid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.oauth.WhoAmIResponse.tenantId)
}

// -------------------------------------------------------------------

// PublicKeyRequest

// string keyId = 1 [(.validate.rules) = {
inline void PublicKeyRequest::clear_keyid() {
  keyid_.ClearToEmpty();
}
inline const std::string& PublicKeyRequest::keyid() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.PublicKeyRequest.keyId)
  return _internal_keyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicKeyRequest::set_keyid(ArgT0&& arg0, ArgT... args) {
 
 keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.oauth.PublicKeyRequest.keyId)
}
inline std::string* PublicKeyRequest::mutable_keyid() {
  std::string* _s = _internal_mutable_keyid();
  // @@protoc_insertion_point(field_mutable:sensory.api.oauth.PublicKeyRequest.keyId)
  return _s;
}
inline const std::string& PublicKeyRequest::_internal_keyid() const {
  return keyid_.Get();
}
inline void PublicKeyRequest::_internal_set_keyid(const std::string& value) {
  
  keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicKeyRequest::_internal_mutable_keyid() {
  
  return keyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicKeyRequest::release_keyid() {
  // @@protoc_insertion_point(field_release:sensory.api.oauth.PublicKeyRequest.keyId)
  return keyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicKeyRequest::set_allocated_keyid(std::string* keyid) {
  if (keyid != nullptr) {
    
  } else {
    
  }
  keyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.oauth.PublicKeyRequest.keyId)
}

// -------------------------------------------------------------------

// PublicKeyResponse

// bytes publicKey = 1;
inline void PublicKeyResponse::clear_publickey() {
  publickey_.ClearToEmpty();
}
inline const std::string& PublicKeyResponse::publickey() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.PublicKeyResponse.publicKey)
  return _internal_publickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicKeyResponse::set_publickey(ArgT0&& arg0, ArgT... args) {
 
 publickey_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.oauth.PublicKeyResponse.publicKey)
}
inline std::string* PublicKeyResponse::mutable_publickey() {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:sensory.api.oauth.PublicKeyResponse.publicKey)
  return _s;
}
inline const std::string& PublicKeyResponse::_internal_publickey() const {
  return publickey_.Get();
}
inline void PublicKeyResponse::_internal_set_publickey(const std::string& value) {
  
  publickey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublicKeyResponse::_internal_mutable_publickey() {
  
  return publickey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublicKeyResponse::release_publickey() {
  // @@protoc_insertion_point(field_release:sensory.api.oauth.PublicKeyResponse.publicKey)
  return publickey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublicKeyResponse::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    
  } else {
    
  }
  publickey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.oauth.PublicKeyResponse.publicKey)
}

// .sensory.api.common.KeyType keyType = 2;
inline void PublicKeyResponse::clear_keytype() {
  keytype_ = 0;
}
inline ::sensory::api::common::KeyType PublicKeyResponse::_internal_keytype() const {
  return static_cast< ::sensory::api::common::KeyType >(keytype_);
}
inline ::sensory::api::common::KeyType PublicKeyResponse::keytype() const {
  // @@protoc_insertion_point(field_get:sensory.api.oauth.PublicKeyResponse.keyType)
  return _internal_keytype();
}
inline void PublicKeyResponse::_internal_set_keytype(::sensory::api::common::KeyType value) {
  
  keytype_ = value;
}
inline void PublicKeyResponse::set_keytype(::sensory::api::common::KeyType value) {
  _internal_set_keytype(value);
  // @@protoc_insertion_point(field_set:sensory.api.oauth.PublicKeyResponse.keyType)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace oauth
}  // namespace api
}  // namespace sensory

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensory::api::oauth::SignTokenRequest_TokenScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::oauth::SignTokenRequest_TokenScope>() {
  return ::sensory::api::oauth::SignTokenRequest_TokenScope_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_oauth_2foauth_2eproto
