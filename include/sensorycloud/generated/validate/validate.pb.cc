// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validate/validate.proto

#include "validate/validate.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace validate {
constexpr FieldRules::FieldRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(nullptr)
  , _oneof_case_{}{}
struct FieldRulesDefaultTypeInternal {
  constexpr FieldRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FieldRulesDefaultTypeInternal() {}
  union {
    FieldRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FieldRulesDefaultTypeInternal _FieldRules_default_instance_;
constexpr FloatRules::FloatRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0)
  , lt_(0)
  , lte_(0)
  , gt_(0)
  , gte_(0){}
struct FloatRulesDefaultTypeInternal {
  constexpr FloatRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FloatRulesDefaultTypeInternal() {}
  union {
    FloatRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
constexpr DoubleRules::DoubleRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0)
  , lt_(0)
  , lte_(0)
  , gt_(0)
  , gte_(0){}
struct DoubleRulesDefaultTypeInternal {
  constexpr DoubleRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DoubleRulesDefaultTypeInternal() {}
  union {
    DoubleRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
constexpr Int32Rules::Int32Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0)
  , lt_(0)
  , lte_(0)
  , gt_(0)
  , gte_(0){}
struct Int32RulesDefaultTypeInternal {
  constexpr Int32RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int32RulesDefaultTypeInternal() {}
  union {
    Int32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
constexpr Int64Rules::Int64Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(int64_t{0})
  , lt_(int64_t{0})
  , lte_(int64_t{0})
  , gt_(int64_t{0})
  , gte_(int64_t{0}){}
struct Int64RulesDefaultTypeInternal {
  constexpr Int64RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Int64RulesDefaultTypeInternal() {}
  union {
    Int64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
constexpr UInt32Rules::UInt32Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0u)
  , lt_(0u)
  , lte_(0u)
  , gt_(0u)
  , gte_(0u){}
struct UInt32RulesDefaultTypeInternal {
  constexpr UInt32RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UInt32RulesDefaultTypeInternal() {}
  union {
    UInt32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
constexpr UInt64Rules::UInt64Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(uint64_t{0u})
  , lt_(uint64_t{0u})
  , lte_(uint64_t{0u})
  , gt_(uint64_t{0u})
  , gte_(uint64_t{0u}){}
struct UInt64RulesDefaultTypeInternal {
  constexpr UInt64RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UInt64RulesDefaultTypeInternal() {}
  union {
    UInt64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
constexpr SInt32Rules::SInt32Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0)
  , lt_(0)
  , lte_(0)
  , gt_(0)
  , gte_(0){}
struct SInt32RulesDefaultTypeInternal {
  constexpr SInt32RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SInt32RulesDefaultTypeInternal() {}
  union {
    SInt32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
constexpr SInt64Rules::SInt64Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(int64_t{0})
  , lt_(int64_t{0})
  , lte_(int64_t{0})
  , gt_(int64_t{0})
  , gte_(int64_t{0}){}
struct SInt64RulesDefaultTypeInternal {
  constexpr SInt64RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SInt64RulesDefaultTypeInternal() {}
  union {
    SInt64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
constexpr Fixed32Rules::Fixed32Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0u)
  , lt_(0u)
  , lte_(0u)
  , gt_(0u)
  , gte_(0u){}
struct Fixed32RulesDefaultTypeInternal {
  constexpr Fixed32RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Fixed32RulesDefaultTypeInternal() {}
  union {
    Fixed32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
constexpr Fixed64Rules::Fixed64Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(uint64_t{0u})
  , lt_(uint64_t{0u})
  , lte_(uint64_t{0u})
  , gt_(uint64_t{0u})
  , gte_(uint64_t{0u}){}
struct Fixed64RulesDefaultTypeInternal {
  constexpr Fixed64RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Fixed64RulesDefaultTypeInternal() {}
  union {
    Fixed64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
constexpr SFixed32Rules::SFixed32Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0)
  , lt_(0)
  , lte_(0)
  , gt_(0)
  , gte_(0){}
struct SFixed32RulesDefaultTypeInternal {
  constexpr SFixed32RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SFixed32RulesDefaultTypeInternal() {}
  union {
    SFixed32Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
constexpr SFixed64Rules::SFixed64Rules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(int64_t{0})
  , lt_(int64_t{0})
  , lte_(int64_t{0})
  , gt_(int64_t{0})
  , gte_(int64_t{0}){}
struct SFixed64RulesDefaultTypeInternal {
  constexpr SFixed64RulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SFixed64RulesDefaultTypeInternal() {}
  union {
    SFixed64Rules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
constexpr BoolRules::BoolRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : const__(false){}
struct BoolRulesDefaultTypeInternal {
  constexpr BoolRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BoolRulesDefaultTypeInternal() {}
  union {
    BoolRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
constexpr StringRules::StringRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , pattern_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , prefix_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , suffix_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , contains_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , not_contains_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , min_len_(uint64_t{0u})
  , max_len_(uint64_t{0u})
  , min_bytes_(uint64_t{0u})
  , max_bytes_(uint64_t{0u})
  , len_(uint64_t{0u})
  , len_bytes_(uint64_t{0u})
  , strict_(true)
  , _oneof_case_{}{}
struct StringRulesDefaultTypeInternal {
  constexpr StringRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringRulesDefaultTypeInternal() {}
  union {
    StringRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringRulesDefaultTypeInternal _StringRules_default_instance_;
constexpr BytesRules::BytesRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , pattern_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , prefix_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , suffix_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , contains_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , min_len_(uint64_t{0u})
  , max_len_(uint64_t{0u})
  , len_(uint64_t{0u})
  , _oneof_case_{}{}
struct BytesRulesDefaultTypeInternal {
  constexpr BytesRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BytesRulesDefaultTypeInternal() {}
  union {
    BytesRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
constexpr EnumRules::EnumRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(0)
  , defined_only_(false){}
struct EnumRulesDefaultTypeInternal {
  constexpr EnumRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EnumRulesDefaultTypeInternal() {}
  union {
    EnumRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
constexpr MessageRules::MessageRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : skip_(false)
  , required_(false){}
struct MessageRulesDefaultTypeInternal {
  constexpr MessageRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MessageRulesDefaultTypeInternal() {}
  union {
    MessageRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MessageRulesDefaultTypeInternal _MessageRules_default_instance_;
constexpr RepeatedRules::RepeatedRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : items_(nullptr)
  , min_items_(uint64_t{0u})
  , max_items_(uint64_t{0u})
  , unique_(false){}
struct RepeatedRulesDefaultTypeInternal {
  constexpr RepeatedRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RepeatedRulesDefaultTypeInternal() {}
  union {
    RepeatedRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
constexpr MapRules::MapRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keys_(nullptr)
  , values_(nullptr)
  , min_pairs_(uint64_t{0u})
  , max_pairs_(uint64_t{0u})
  , no_sparse_(false){}
struct MapRulesDefaultTypeInternal {
  constexpr MapRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MapRulesDefaultTypeInternal() {}
  union {
    MapRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MapRulesDefaultTypeInternal _MapRules_default_instance_;
constexpr AnyRules::AnyRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , required_(false){}
struct AnyRulesDefaultTypeInternal {
  constexpr AnyRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnyRulesDefaultTypeInternal() {}
  union {
    AnyRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
constexpr DurationRules::DurationRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_()
  , not_in_()
  , const__(nullptr)
  , lt_(nullptr)
  , lte_(nullptr)
  , gt_(nullptr)
  , gte_(nullptr)
  , required_(false){}
struct DurationRulesDefaultTypeInternal {
  constexpr DurationRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DurationRulesDefaultTypeInternal() {}
  union {
    DurationRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
constexpr TimestampRules::TimestampRules(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : const__(nullptr)
  , lt_(nullptr)
  , lte_(nullptr)
  , gt_(nullptr)
  , gte_(nullptr)
  , within_(nullptr)
  , required_(false)
  , lt_now_(false)
  , gt_now_(false){}
struct TimestampRulesDefaultTypeInternal {
  constexpr TimestampRulesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TimestampRulesDefaultTypeInternal() {}
  union {
    TimestampRules _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
}  // namespace validate
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_validate_2fvalidate_2eproto[23];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_validate_2fvalidate_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_validate_2fvalidate_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_validate_2fvalidate_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, message_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::validate::FieldRules, type_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::FloatRules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, not_in_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::BoolRules, const__),
  0,
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, min_len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, max_len_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, len_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, min_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, max_bytes_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, pattern_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, prefix_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, suffix_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, contains_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, not_contains_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, not_in_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, strict_),
  PROTOBUF_FIELD_OFFSET(::validate::StringRules, well_known_),
  0,
  10,
  6,
  7,
  11,
  8,
  9,
  1,
  2,
  3,
  4,
  5,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  12,
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, min_len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, max_len_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, pattern_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, prefix_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, suffix_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, contains_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, not_in_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::validate::BytesRules, well_known_),
  0,
  7,
  5,
  6,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, defined_only_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::EnumRules, not_in_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, skip_),
  PROTOBUF_FIELD_OFFSET(::validate::MessageRules, required_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, min_items_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, max_items_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, unique_),
  PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, items_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, min_pairs_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, max_pairs_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, no_sparse_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, keys_),
  PROTOBUF_FIELD_OFFSET(::validate::MapRules, values_),
  2,
  3,
  4,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, required_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::AnyRules, not_in_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, required_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, in_),
  PROTOBUF_FIELD_OFFSET(::validate::DurationRules, not_in_),
  5,
  0,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, required_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, const__),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, lt_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, lte_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, gt_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, gte_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, lt_now_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, gt_now_),
  PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, within_),
  6,
  0,
  1,
  2,
  3,
  4,
  7,
  8,
  5,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 28, sizeof(::validate::FieldRules)},
  { 50, 62, sizeof(::validate::FloatRules)},
  { 69, 81, sizeof(::validate::DoubleRules)},
  { 88, 100, sizeof(::validate::Int32Rules)},
  { 107, 119, sizeof(::validate::Int64Rules)},
  { 126, 138, sizeof(::validate::UInt32Rules)},
  { 145, 157, sizeof(::validate::UInt64Rules)},
  { 164, 176, sizeof(::validate::SInt32Rules)},
  { 183, 195, sizeof(::validate::SInt64Rules)},
  { 202, 214, sizeof(::validate::Fixed32Rules)},
  { 221, 233, sizeof(::validate::Fixed64Rules)},
  { 240, 252, sizeof(::validate::SFixed32Rules)},
  { 259, 271, sizeof(::validate::SFixed64Rules)},
  { 278, 284, sizeof(::validate::BoolRules)},
  { 285, 316, sizeof(::validate::StringRules)},
  { 341, 360, sizeof(::validate::BytesRules)},
  { 373, 382, sizeof(::validate::EnumRules)},
  { 386, 393, sizeof(::validate::MessageRules)},
  { 395, 404, sizeof(::validate::RepeatedRules)},
  { 408, 418, sizeof(::validate::MapRules)},
  { 423, 431, sizeof(::validate::AnyRules)},
  { 434, 447, sizeof(::validate::DurationRules)},
  { 455, 469, sizeof(::validate::TimestampRules)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_FieldRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_FloatRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_DoubleRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_Int32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_Int64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_UInt32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_UInt64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_SInt32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_SInt64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_Fixed32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_Fixed64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_SFixed32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_SFixed64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_BoolRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_StringRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_BytesRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_EnumRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_MessageRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_RepeatedRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_MapRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_AnyRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_DurationRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::validate::_TimestampRules_default_instance_),
};

const char descriptor_table_protodef_validate_2fvalidate_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\027validate/validate.proto\022\010validate\032 goo"
  "gle/protobuf/descriptor.proto\032\036google/pr"
  "otobuf/duration.proto\032\037google/protobuf/t"
  "imestamp.proto\"\230\007\n\nFieldRules\022\'\n\007message"
  "\030\021 \001(\0132\026.validate.MessageRules\022%\n\005float\030"
  "\001 \001(\0132\024.validate.FloatRulesH\000\022\'\n\006double\030"
  "\002 \001(\0132\025.validate.DoubleRulesH\000\022%\n\005int32\030"
  "\003 \001(\0132\024.validate.Int32RulesH\000\022%\n\005int64\030\004"
  " \001(\0132\024.validate.Int64RulesH\000\022\'\n\006uint32\030\005"
  " \001(\0132\025.validate.UInt32RulesH\000\022\'\n\006uint64\030"
  "\006 \001(\0132\025.validate.UInt64RulesH\000\022\'\n\006sint32"
  "\030\007 \001(\0132\025.validate.SInt32RulesH\000\022\'\n\006sint6"
  "4\030\010 \001(\0132\025.validate.SInt64RulesH\000\022)\n\007fixe"
  "d32\030\t \001(\0132\026.validate.Fixed32RulesH\000\022)\n\007f"
  "ixed64\030\n \001(\0132\026.validate.Fixed64RulesH\000\022+"
  "\n\010sfixed32\030\013 \001(\0132\027.validate.SFixed32Rule"
  "sH\000\022+\n\010sfixed64\030\014 \001(\0132\027.validate.SFixed6"
  "4RulesH\000\022#\n\004bool\030\r \001(\0132\023.validate.BoolRu"
  "lesH\000\022\'\n\006string\030\016 \001(\0132\025.validate.StringR"
  "ulesH\000\022%\n\005bytes\030\017 \001(\0132\024.validate.BytesRu"
  "lesH\000\022#\n\004enum\030\020 \001(\0132\023.validate.EnumRules"
  "H\000\022+\n\010repeated\030\022 \001(\0132\027.validate.Repeated"
  "RulesH\000\022!\n\003map\030\023 \001(\0132\022.validate.MapRules"
  "H\000\022!\n\003any\030\024 \001(\0132\022.validate.AnyRulesH\000\022+\n"
  "\010duration\030\025 \001(\0132\027.validate.DurationRules"
  "H\000\022-\n\ttimestamp\030\026 \001(\0132\030.validate.Timesta"
  "mpRulesH\000B\006\n\004type\"i\n\nFloatRules\022\r\n\005const"
  "\030\001 \001(\002\022\n\n\002lt\030\002 \001(\002\022\013\n\003lte\030\003 \001(\002\022\n\n\002gt\030\004 "
  "\001(\002\022\013\n\003gte\030\005 \001(\002\022\n\n\002in\030\006 \003(\002\022\016\n\006not_in\030\007"
  " \003(\002\"j\n\013DoubleRules\022\r\n\005const\030\001 \001(\001\022\n\n\002lt"
  "\030\002 \001(\001\022\013\n\003lte\030\003 \001(\001\022\n\n\002gt\030\004 \001(\001\022\013\n\003gte\030\005"
  " \001(\001\022\n\n\002in\030\006 \003(\001\022\016\n\006not_in\030\007 \003(\001\"i\n\nInt3"
  "2Rules\022\r\n\005const\030\001 \001(\005\022\n\n\002lt\030\002 \001(\005\022\013\n\003lte"
  "\030\003 \001(\005\022\n\n\002gt\030\004 \001(\005\022\013\n\003gte\030\005 \001(\005\022\n\n\002in\030\006 "
  "\003(\005\022\016\n\006not_in\030\007 \003(\005\"i\n\nInt64Rules\022\r\n\005con"
  "st\030\001 \001(\003\022\n\n\002lt\030\002 \001(\003\022\013\n\003lte\030\003 \001(\003\022\n\n\002gt\030"
  "\004 \001(\003\022\013\n\003gte\030\005 \001(\003\022\n\n\002in\030\006 \003(\003\022\016\n\006not_in"
  "\030\007 \003(\003\"j\n\013UInt32Rules\022\r\n\005const\030\001 \001(\r\022\n\n\002"
  "lt\030\002 \001(\r\022\013\n\003lte\030\003 \001(\r\022\n\n\002gt\030\004 \001(\r\022\013\n\003gte"
  "\030\005 \001(\r\022\n\n\002in\030\006 \003(\r\022\016\n\006not_in\030\007 \003(\r\"j\n\013UI"
  "nt64Rules\022\r\n\005const\030\001 \001(\004\022\n\n\002lt\030\002 \001(\004\022\013\n\003"
  "lte\030\003 \001(\004\022\n\n\002gt\030\004 \001(\004\022\013\n\003gte\030\005 \001(\004\022\n\n\002in"
  "\030\006 \003(\004\022\016\n\006not_in\030\007 \003(\004\"j\n\013SInt32Rules\022\r\n"
  "\005const\030\001 \001(\021\022\n\n\002lt\030\002 \001(\021\022\013\n\003lte\030\003 \001(\021\022\n\n"
  "\002gt\030\004 \001(\021\022\013\n\003gte\030\005 \001(\021\022\n\n\002in\030\006 \003(\021\022\016\n\006no"
  "t_in\030\007 \003(\021\"j\n\013SInt64Rules\022\r\n\005const\030\001 \001(\022"
  "\022\n\n\002lt\030\002 \001(\022\022\013\n\003lte\030\003 \001(\022\022\n\n\002gt\030\004 \001(\022\022\013\n"
  "\003gte\030\005 \001(\022\022\n\n\002in\030\006 \003(\022\022\016\n\006not_in\030\007 \003(\022\"k"
  "\n\014Fixed32Rules\022\r\n\005const\030\001 \001(\007\022\n\n\002lt\030\002 \001("
  "\007\022\013\n\003lte\030\003 \001(\007\022\n\n\002gt\030\004 \001(\007\022\013\n\003gte\030\005 \001(\007\022"
  "\n\n\002in\030\006 \003(\007\022\016\n\006not_in\030\007 \003(\007\"k\n\014Fixed64Ru"
  "les\022\r\n\005const\030\001 \001(\006\022\n\n\002lt\030\002 \001(\006\022\013\n\003lte\030\003 "
  "\001(\006\022\n\n\002gt\030\004 \001(\006\022\013\n\003gte\030\005 \001(\006\022\n\n\002in\030\006 \003(\006"
  "\022\016\n\006not_in\030\007 \003(\006\"l\n\rSFixed32Rules\022\r\n\005con"
  "st\030\001 \001(\017\022\n\n\002lt\030\002 \001(\017\022\013\n\003lte\030\003 \001(\017\022\n\n\002gt\030"
  "\004 \001(\017\022\013\n\003gte\030\005 \001(\017\022\n\n\002in\030\006 \003(\017\022\016\n\006not_in"
  "\030\007 \003(\017\"l\n\rSFixed64Rules\022\r\n\005const\030\001 \001(\020\022\n"
  "\n\002lt\030\002 \001(\020\022\013\n\003lte\030\003 \001(\020\022\n\n\002gt\030\004 \001(\020\022\013\n\003g"
  "te\030\005 \001(\020\022\n\n\002in\030\006 \003(\020\022\016\n\006not_in\030\007 \003(\020\"\032\n\t"
  "BoolRules\022\r\n\005const\030\001 \001(\010\"\347\003\n\013StringRules"
  "\022\r\n\005const\030\001 \001(\t\022\013\n\003len\030\023 \001(\004\022\017\n\007min_len\030"
  "\002 \001(\004\022\017\n\007max_len\030\003 \001(\004\022\021\n\tlen_bytes\030\024 \001("
  "\004\022\021\n\tmin_bytes\030\004 \001(\004\022\021\n\tmax_bytes\030\005 \001(\004\022"
  "\017\n\007pattern\030\006 \001(\t\022\016\n\006prefix\030\007 \001(\t\022\016\n\006suff"
  "ix\030\010 \001(\t\022\020\n\010contains\030\t \001(\t\022\024\n\014not_contai"
  "ns\030\027 \001(\t\022\n\n\002in\030\n \003(\t\022\016\n\006not_in\030\013 \003(\t\022\017\n\005"
  "email\030\014 \001(\010H\000\022\022\n\010hostname\030\r \001(\010H\000\022\014\n\002ip\030"
  "\016 \001(\010H\000\022\016\n\004ipv4\030\017 \001(\010H\000\022\016\n\004ipv6\030\020 \001(\010H\000\022"
  "\r\n\003uri\030\021 \001(\010H\000\022\021\n\007uri_ref\030\022 \001(\010H\000\022\021\n\007add"
  "ress\030\025 \001(\010H\000\022\016\n\004uuid\030\026 \001(\010H\000\0220\n\020well_kno"
  "wn_regex\030\030 \001(\0162\024.validate.KnownRegexH\000\022\024"
  "\n\006strict\030\031 \001(\010:\004trueB\014\n\nwell_known\"\345\001\n\nB"
  "ytesRules\022\r\n\005const\030\001 \001(\014\022\013\n\003len\030\r \001(\004\022\017\n"
  "\007min_len\030\002 \001(\004\022\017\n\007max_len\030\003 \001(\004\022\017\n\007patte"
  "rn\030\004 \001(\t\022\016\n\006prefix\030\005 \001(\014\022\016\n\006suffix\030\006 \001(\014"
  "\022\020\n\010contains\030\007 \001(\014\022\n\n\002in\030\010 \003(\014\022\016\n\006not_in"
  "\030\t \003(\014\022\014\n\002ip\030\n \001(\010H\000\022\016\n\004ipv4\030\013 \001(\010H\000\022\016\n\004"
  "ipv6\030\014 \001(\010H\000B\014\n\nwell_known\"L\n\tEnumRules\022"
  "\r\n\005const\030\001 \001(\005\022\024\n\014defined_only\030\002 \001(\010\022\n\n\002"
  "in\030\003 \003(\005\022\016\n\006not_in\030\004 \003(\005\".\n\014MessageRules"
  "\022\014\n\004skip\030\001 \001(\010\022\020\n\010required\030\002 \001(\010\"j\n\rRepe"
  "atedRules\022\021\n\tmin_items\030\001 \001(\004\022\021\n\tmax_item"
  "s\030\002 \001(\004\022\016\n\006unique\030\003 \001(\010\022#\n\005items\030\004 \001(\0132\024"
  ".validate.FieldRules\"\215\001\n\010MapRules\022\021\n\tmin"
  "_pairs\030\001 \001(\004\022\021\n\tmax_pairs\030\002 \001(\004\022\021\n\tno_sp"
  "arse\030\003 \001(\010\022\"\n\004keys\030\004 \001(\0132\024.validate.Fiel"
  "dRules\022$\n\006values\030\005 \001(\0132\024.validate.FieldR"
  "ules\"8\n\010AnyRules\022\020\n\010required\030\001 \001(\010\022\n\n\002in"
  "\030\002 \003(\t\022\016\n\006not_in\030\003 \003(\t\"\273\002\n\rDurationRules"
  "\022\020\n\010required\030\001 \001(\010\022(\n\005const\030\002 \001(\0132\031.goog"
  "le.protobuf.Duration\022%\n\002lt\030\003 \001(\0132\031.googl"
  "e.protobuf.Duration\022&\n\003lte\030\004 \001(\0132\031.googl"
  "e.protobuf.Duration\022%\n\002gt\030\005 \001(\0132\031.google"
  ".protobuf.Duration\022&\n\003gte\030\006 \001(\0132\031.google"
  ".protobuf.Duration\022%\n\002in\030\007 \003(\0132\031.google."
  "protobuf.Duration\022)\n\006not_in\030\010 \003(\0132\031.goog"
  "le.protobuf.Duration\"\272\002\n\016TimestampRules\022"
  "\020\n\010required\030\001 \001(\010\022)\n\005const\030\002 \001(\0132\032.googl"
  "e.protobuf.Timestamp\022&\n\002lt\030\003 \001(\0132\032.googl"
  "e.protobuf.Timestamp\022\'\n\003lte\030\004 \001(\0132\032.goog"
  "le.protobuf.Timestamp\022&\n\002gt\030\005 \001(\0132\032.goog"
  "le.protobuf.Timestamp\022\'\n\003gte\030\006 \001(\0132\032.goo"
  "gle.protobuf.Timestamp\022\016\n\006lt_now\030\007 \001(\010\022\016"
  "\n\006gt_now\030\010 \001(\010\022)\n\006within\030\t \001(\0132\031.google."
  "protobuf.Duration*F\n\nKnownRegex\022\013\n\007UNKNO"
  "WN\020\000\022\024\n\020HTTP_HEADER_NAME\020\001\022\025\n\021HTTP_HEADE"
  "R_VALUE\020\002:2\n\010disabled\022\037.google.protobuf."
  "MessageOptions\030\257\010 \001(\010:0\n\010required\022\035.goog"
  "le.protobuf.OneofOptions\030\257\010 \001(\010:C\n\005rules"
  "\022\035.google.protobuf.FieldOptions\030\257\010 \001(\0132\024"
  ".validate.FieldRulesBP\n\032io.envoyproxy.pg"
  "v.validateZ2github.com/envoyproxy/protoc"
  "-gen-validate/validate"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_validate_2fvalidate_2eproto_deps[3] = {
  &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_validate_2fvalidate_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_validate_2fvalidate_2eproto = {
  false, false, 4502, descriptor_table_protodef_validate_2fvalidate_2eproto, "validate/validate.proto", 
  &descriptor_table_validate_2fvalidate_2eproto_once, descriptor_table_validate_2fvalidate_2eproto_deps, 3, 23,
  schemas, file_default_instances, TableStruct_validate_2fvalidate_2eproto::offsets,
  file_level_metadata_validate_2fvalidate_2eproto, file_level_enum_descriptors_validate_2fvalidate_2eproto, file_level_service_descriptors_validate_2fvalidate_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_validate_2fvalidate_2eproto_getter() {
  return &descriptor_table_validate_2fvalidate_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_validate_2fvalidate_2eproto(&descriptor_table_validate_2fvalidate_2eproto);
namespace validate {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KnownRegex_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_validate_2fvalidate_2eproto);
  return file_level_enum_descriptors_validate_2fvalidate_2eproto[0];
}
bool KnownRegex_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FieldRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FieldRules>()._has_bits_);
  static const ::validate::MessageRules& message(const FieldRules* msg);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::validate::FloatRules& float_(const FieldRules* msg);
  static const ::validate::DoubleRules& double_(const FieldRules* msg);
  static const ::validate::Int32Rules& int32(const FieldRules* msg);
  static const ::validate::Int64Rules& int64(const FieldRules* msg);
  static const ::validate::UInt32Rules& uint32(const FieldRules* msg);
  static const ::validate::UInt64Rules& uint64(const FieldRules* msg);
  static const ::validate::SInt32Rules& sint32(const FieldRules* msg);
  static const ::validate::SInt64Rules& sint64(const FieldRules* msg);
  static const ::validate::Fixed32Rules& fixed32(const FieldRules* msg);
  static const ::validate::Fixed64Rules& fixed64(const FieldRules* msg);
  static const ::validate::SFixed32Rules& sfixed32(const FieldRules* msg);
  static const ::validate::SFixed64Rules& sfixed64(const FieldRules* msg);
  static const ::validate::BoolRules& bool_(const FieldRules* msg);
  static const ::validate::StringRules& string(const FieldRules* msg);
  static const ::validate::BytesRules& bytes(const FieldRules* msg);
  static const ::validate::EnumRules& enum_(const FieldRules* msg);
  static const ::validate::RepeatedRules& repeated(const FieldRules* msg);
  static const ::validate::MapRules& map(const FieldRules* msg);
  static const ::validate::AnyRules& any(const FieldRules* msg);
  static const ::validate::DurationRules& duration(const FieldRules* msg);
  static const ::validate::TimestampRules& timestamp(const FieldRules* msg);
};

const ::validate::MessageRules&
FieldRules::_Internal::message(const FieldRules* msg) {
  return *msg->message_;
}
const ::validate::FloatRules&
FieldRules::_Internal::float_(const FieldRules* msg) {
  return *msg->type_.float__;
}
const ::validate::DoubleRules&
FieldRules::_Internal::double_(const FieldRules* msg) {
  return *msg->type_.double__;
}
const ::validate::Int32Rules&
FieldRules::_Internal::int32(const FieldRules* msg) {
  return *msg->type_.int32_;
}
const ::validate::Int64Rules&
FieldRules::_Internal::int64(const FieldRules* msg) {
  return *msg->type_.int64_;
}
const ::validate::UInt32Rules&
FieldRules::_Internal::uint32(const FieldRules* msg) {
  return *msg->type_.uint32_;
}
const ::validate::UInt64Rules&
FieldRules::_Internal::uint64(const FieldRules* msg) {
  return *msg->type_.uint64_;
}
const ::validate::SInt32Rules&
FieldRules::_Internal::sint32(const FieldRules* msg) {
  return *msg->type_.sint32_;
}
const ::validate::SInt64Rules&
FieldRules::_Internal::sint64(const FieldRules* msg) {
  return *msg->type_.sint64_;
}
const ::validate::Fixed32Rules&
FieldRules::_Internal::fixed32(const FieldRules* msg) {
  return *msg->type_.fixed32_;
}
const ::validate::Fixed64Rules&
FieldRules::_Internal::fixed64(const FieldRules* msg) {
  return *msg->type_.fixed64_;
}
const ::validate::SFixed32Rules&
FieldRules::_Internal::sfixed32(const FieldRules* msg) {
  return *msg->type_.sfixed32_;
}
const ::validate::SFixed64Rules&
FieldRules::_Internal::sfixed64(const FieldRules* msg) {
  return *msg->type_.sfixed64_;
}
const ::validate::BoolRules&
FieldRules::_Internal::bool_(const FieldRules* msg) {
  return *msg->type_.bool__;
}
const ::validate::StringRules&
FieldRules::_Internal::string(const FieldRules* msg) {
  return *msg->type_.string_;
}
const ::validate::BytesRules&
FieldRules::_Internal::bytes(const FieldRules* msg) {
  return *msg->type_.bytes_;
}
const ::validate::EnumRules&
FieldRules::_Internal::enum_(const FieldRules* msg) {
  return *msg->type_.enum__;
}
const ::validate::RepeatedRules&
FieldRules::_Internal::repeated(const FieldRules* msg) {
  return *msg->type_.repeated_;
}
const ::validate::MapRules&
FieldRules::_Internal::map(const FieldRules* msg) {
  return *msg->type_.map_;
}
const ::validate::AnyRules&
FieldRules::_Internal::any(const FieldRules* msg) {
  return *msg->type_.any_;
}
const ::validate::DurationRules&
FieldRules::_Internal::duration(const FieldRules* msg) {
  return *msg->type_.duration_;
}
const ::validate::TimestampRules&
FieldRules::_Internal::timestamp(const FieldRules* msg) {
  return *msg->type_.timestamp_;
}
void FieldRules::set_allocated_float_(::validate::FloatRules* float_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (float_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::FloatRules>::GetOwningArena(float_);
    if (message_arena != submessage_arena) {
      float_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, float_, submessage_arena);
    }
    set_has_float_();
    type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.float)
}
void FieldRules::set_allocated_double_(::validate::DoubleRules* double_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (double_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::DoubleRules>::GetOwningArena(double_);
    if (message_arena != submessage_arena) {
      double_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, double_, submessage_arena);
    }
    set_has_double_();
    type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.double)
}
void FieldRules::set_allocated_int32(::validate::Int32Rules* int32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (int32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::Int32Rules>::GetOwningArena(int32);
    if (message_arena != submessage_arena) {
      int32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int32, submessage_arena);
    }
    set_has_int32();
    type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int32)
}
void FieldRules::set_allocated_int64(::validate::Int64Rules* int64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (int64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::Int64Rules>::GetOwningArena(int64);
    if (message_arena != submessage_arena) {
      int64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64, submessage_arena);
    }
    set_has_int64();
    type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int64)
}
void FieldRules::set_allocated_uint32(::validate::UInt32Rules* uint32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (uint32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::UInt32Rules>::GetOwningArena(uint32);
    if (message_arena != submessage_arena) {
      uint32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uint32, submessage_arena);
    }
    set_has_uint32();
    type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint32)
}
void FieldRules::set_allocated_uint64(::validate::UInt64Rules* uint64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (uint64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::UInt64Rules>::GetOwningArena(uint64);
    if (message_arena != submessage_arena) {
      uint64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uint64, submessage_arena);
    }
    set_has_uint64();
    type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint64)
}
void FieldRules::set_allocated_sint32(::validate::SInt32Rules* sint32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sint32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::SInt32Rules>::GetOwningArena(sint32);
    if (message_arena != submessage_arena) {
      sint32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sint32, submessage_arena);
    }
    set_has_sint32();
    type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint32)
}
void FieldRules::set_allocated_sint64(::validate::SInt64Rules* sint64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sint64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::SInt64Rules>::GetOwningArena(sint64);
    if (message_arena != submessage_arena) {
      sint64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sint64, submessage_arena);
    }
    set_has_sint64();
    type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint64)
}
void FieldRules::set_allocated_fixed32(::validate::Fixed32Rules* fixed32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (fixed32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::Fixed32Rules>::GetOwningArena(fixed32);
    if (message_arena != submessage_arena) {
      fixed32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed32, submessage_arena);
    }
    set_has_fixed32();
    type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed32)
}
void FieldRules::set_allocated_fixed64(::validate::Fixed64Rules* fixed64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (fixed64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::Fixed64Rules>::GetOwningArena(fixed64);
    if (message_arena != submessage_arena) {
      fixed64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed64, submessage_arena);
    }
    set_has_fixed64();
    type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed64)
}
void FieldRules::set_allocated_sfixed32(::validate::SFixed32Rules* sfixed32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sfixed32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::SFixed32Rules>::GetOwningArena(sfixed32);
    if (message_arena != submessage_arena) {
      sfixed32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sfixed32, submessage_arena);
    }
    set_has_sfixed32();
    type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed32)
}
void FieldRules::set_allocated_sfixed64(::validate::SFixed64Rules* sfixed64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sfixed64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::SFixed64Rules>::GetOwningArena(sfixed64);
    if (message_arena != submessage_arena) {
      sfixed64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sfixed64, submessage_arena);
    }
    set_has_sfixed64();
    type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed64)
}
void FieldRules::set_allocated_bool_(::validate::BoolRules* bool_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (bool_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::BoolRules>::GetOwningArena(bool_);
    if (message_arena != submessage_arena) {
      bool_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bool_, submessage_arena);
    }
    set_has_bool_();
    type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bool)
}
void FieldRules::set_allocated_string(::validate::StringRules* string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::StringRules>::GetOwningArena(string);
    if (message_arena != submessage_arena) {
      string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, string, submessage_arena);
    }
    set_has_string();
    type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.string)
}
void FieldRules::set_allocated_bytes(::validate::BytesRules* bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::BytesRules>::GetOwningArena(bytes);
    if (message_arena != submessage_arena) {
      bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bytes)
}
void FieldRules::set_allocated_enum_(::validate::EnumRules* enum_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (enum_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::EnumRules>::GetOwningArena(enum_);
    if (message_arena != submessage_arena) {
      enum_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enum_, submessage_arena);
    }
    set_has_enum_();
    type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.enum)
}
void FieldRules::set_allocated_repeated(::validate::RepeatedRules* repeated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (repeated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::RepeatedRules>::GetOwningArena(repeated);
    if (message_arena != submessage_arena) {
      repeated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repeated, submessage_arena);
    }
    set_has_repeated();
    type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.repeated)
}
void FieldRules::set_allocated_map(::validate::MapRules* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::MapRules>::GetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
    type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.map)
}
void FieldRules::set_allocated_any(::validate::AnyRules* any) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (any) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::AnyRules>::GetOwningArena(any);
    if (message_arena != submessage_arena) {
      any = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, any, submessage_arena);
    }
    set_has_any();
    type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.any)
}
void FieldRules::set_allocated_duration(::validate::DurationRules* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::DurationRules>::GetOwningArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
    type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.duration)
}
void FieldRules::set_allocated_timestamp(::validate::TimestampRules* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::validate::TimestampRules>::GetOwningArena(timestamp);
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
    type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.timestamp)
}
FieldRules::FieldRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.FieldRules)
}
FieldRules::FieldRules(const FieldRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_message()) {
    message_ = new ::validate::MessageRules(*from.message_);
  } else {
    message_ = nullptr;
  }
  clear_has_type();
  switch (from.type_case()) {
    case kFloat: {
      _internal_mutable_float_()->::validate::FloatRules::MergeFrom(from._internal_float_());
      break;
    }
    case kDouble: {
      _internal_mutable_double_()->::validate::DoubleRules::MergeFrom(from._internal_double_());
      break;
    }
    case kInt32: {
      _internal_mutable_int32()->::validate::Int32Rules::MergeFrom(from._internal_int32());
      break;
    }
    case kInt64: {
      _internal_mutable_int64()->::validate::Int64Rules::MergeFrom(from._internal_int64());
      break;
    }
    case kUint32: {
      _internal_mutable_uint32()->::validate::UInt32Rules::MergeFrom(from._internal_uint32());
      break;
    }
    case kUint64: {
      _internal_mutable_uint64()->::validate::UInt64Rules::MergeFrom(from._internal_uint64());
      break;
    }
    case kSint32: {
      _internal_mutable_sint32()->::validate::SInt32Rules::MergeFrom(from._internal_sint32());
      break;
    }
    case kSint64: {
      _internal_mutable_sint64()->::validate::SInt64Rules::MergeFrom(from._internal_sint64());
      break;
    }
    case kFixed32: {
      _internal_mutable_fixed32()->::validate::Fixed32Rules::MergeFrom(from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _internal_mutable_fixed64()->::validate::Fixed64Rules::MergeFrom(from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _internal_mutable_sfixed32()->::validate::SFixed32Rules::MergeFrom(from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _internal_mutable_sfixed64()->::validate::SFixed64Rules::MergeFrom(from._internal_sfixed64());
      break;
    }
    case kBool: {
      _internal_mutable_bool_()->::validate::BoolRules::MergeFrom(from._internal_bool_());
      break;
    }
    case kString: {
      _internal_mutable_string()->::validate::StringRules::MergeFrom(from._internal_string());
      break;
    }
    case kBytes: {
      _internal_mutable_bytes()->::validate::BytesRules::MergeFrom(from._internal_bytes());
      break;
    }
    case kEnum: {
      _internal_mutable_enum_()->::validate::EnumRules::MergeFrom(from._internal_enum_());
      break;
    }
    case kRepeated: {
      _internal_mutable_repeated()->::validate::RepeatedRules::MergeFrom(from._internal_repeated());
      break;
    }
    case kMap: {
      _internal_mutable_map()->::validate::MapRules::MergeFrom(from._internal_map());
      break;
    }
    case kAny: {
      _internal_mutable_any()->::validate::AnyRules::MergeFrom(from._internal_any());
      break;
    }
    case kDuration: {
      _internal_mutable_duration()->::validate::DurationRules::MergeFrom(from._internal_duration());
      break;
    }
    case kTimestamp: {
      _internal_mutable_timestamp()->::validate::TimestampRules::MergeFrom(from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.FieldRules)
}

inline void FieldRules::SharedCtor() {
message_ = nullptr;
clear_has_type();
}

FieldRules::~FieldRules() {
  // @@protoc_insertion_point(destructor:validate.FieldRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FieldRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete message_;
  if (has_type()) {
    clear_type();
  }
}

void FieldRules::ArenaDtor(void* object) {
  FieldRules* _this = reinterpret_cast< FieldRules* >(object);
  (void)_this;
}
void FieldRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FieldRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FieldRules::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:validate.FieldRules)
  switch (type_case()) {
    case kFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.float__;
      }
      break;
    }
    case kDouble: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.double__;
      }
      break;
    }
    case kInt32: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.int32_;
      }
      break;
    }
    case kInt64: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.int64_;
      }
      break;
    }
    case kUint32: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.uint32_;
      }
      break;
    }
    case kUint64: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.uint64_;
      }
      break;
    }
    case kSint32: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.sint32_;
      }
      break;
    }
    case kSint64: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.sint64_;
      }
      break;
    }
    case kFixed32: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.fixed32_;
      }
      break;
    }
    case kFixed64: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.fixed64_;
      }
      break;
    }
    case kSfixed32: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.sfixed32_;
      }
      break;
    }
    case kSfixed64: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.sfixed64_;
      }
      break;
    }
    case kBool: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.bool__;
      }
      break;
    }
    case kString: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.string_;
      }
      break;
    }
    case kBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.bytes_;
      }
      break;
    }
    case kEnum: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.enum__;
      }
      break;
    }
    case kRepeated: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.repeated_;
      }
      break;
    }
    case kMap: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.map_;
      }
      break;
    }
    case kAny: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.any_;
      }
      break;
    }
    case kDuration: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.duration_;
      }
      break;
    }
    case kTimestamp: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.timestamp_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void FieldRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FieldRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(message_ != nullptr);
    message_->Clear();
  }
  clear_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .validate.FloatRules float = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_float_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.DoubleRules double = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_double_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.Int32Rules int32 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_int32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.Int64Rules int64 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.UInt32Rules uint32 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_uint32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.UInt64Rules uint64 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_uint64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.SInt32Rules sint32 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_sint32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.SInt64Rules sint64 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_sint64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.Fixed32Rules fixed32 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.Fixed64Rules fixed64 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.SFixed32Rules sfixed32 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_sfixed32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.SFixed64Rules sfixed64 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_sfixed64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.BoolRules bool = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_bool_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.StringRules string = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_string(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.BytesRules bytes = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_bytes(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.EnumRules enum = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_enum_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .validate.MessageRules message = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.RepeatedRules repeated = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_repeated(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.MapRules map = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_map(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.AnyRules any = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_any(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.DurationRules duration = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.TimestampRules timestamp = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FieldRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.FieldRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kFloat: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          1, _Internal::float_(this), target, stream);
      break;
    }
    case kDouble: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          2, _Internal::double_(this), target, stream);
      break;
    }
    case kInt32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::int32(this), target, stream);
      break;
    }
    case kInt64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::int64(this), target, stream);
      break;
    }
    case kUint32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          5, _Internal::uint32(this), target, stream);
      break;
    }
    case kUint64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          6, _Internal::uint64(this), target, stream);
      break;
    }
    case kSint32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          7, _Internal::sint32(this), target, stream);
      break;
    }
    case kSint64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          8, _Internal::sint64(this), target, stream);
      break;
    }
    case kFixed32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          9, _Internal::fixed32(this), target, stream);
      break;
    }
    case kFixed64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          10, _Internal::fixed64(this), target, stream);
      break;
    }
    case kSfixed32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          11, _Internal::sfixed32(this), target, stream);
      break;
    }
    case kSfixed64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          12, _Internal::sfixed64(this), target, stream);
      break;
    }
    case kBool: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          13, _Internal::bool_(this), target, stream);
      break;
    }
    case kString: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          14, _Internal::string(this), target, stream);
      break;
    }
    case kBytes: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          15, _Internal::bytes(this), target, stream);
      break;
    }
    case kEnum: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          16, _Internal::enum_(this), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _has_bits_[0];
  // optional .validate.MessageRules message = 17;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::message(this), target, stream);
  }

  switch (type_case()) {
    case kRepeated: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          18, _Internal::repeated(this), target, stream);
      break;
    }
    case kMap: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          19, _Internal::map(this), target, stream);
      break;
    }
    case kAny: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          20, _Internal::any(this), target, stream);
      break;
    }
    case kDuration: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          21, _Internal::duration(this), target, stream);
      break;
    }
    case kTimestamp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          22, _Internal::timestamp(this), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FieldRules)
  return target;
}

size_t FieldRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.FieldRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .validate.MessageRules message = 17;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *message_);
  }

  switch (type_case()) {
    // .validate.FloatRules float = 1;
    case kFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.float__);
      break;
    }
    // .validate.DoubleRules double = 2;
    case kDouble: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.double__);
      break;
    }
    // .validate.Int32Rules int32 = 3;
    case kInt32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.int32_);
      break;
    }
    // .validate.Int64Rules int64 = 4;
    case kInt64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.int64_);
      break;
    }
    // .validate.UInt32Rules uint32 = 5;
    case kUint32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.uint32_);
      break;
    }
    // .validate.UInt64Rules uint64 = 6;
    case kUint64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.uint64_);
      break;
    }
    // .validate.SInt32Rules sint32 = 7;
    case kSint32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sint32_);
      break;
    }
    // .validate.SInt64Rules sint64 = 8;
    case kSint64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sint64_);
      break;
    }
    // .validate.Fixed32Rules fixed32 = 9;
    case kFixed32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.fixed32_);
      break;
    }
    // .validate.Fixed64Rules fixed64 = 10;
    case kFixed64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.fixed64_);
      break;
    }
    // .validate.SFixed32Rules sfixed32 = 11;
    case kSfixed32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sfixed32_);
      break;
    }
    // .validate.SFixed64Rules sfixed64 = 12;
    case kSfixed64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sfixed64_);
      break;
    }
    // .validate.BoolRules bool = 13;
    case kBool: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.bool__);
      break;
    }
    // .validate.StringRules string = 14;
    case kString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.string_);
      break;
    }
    // .validate.BytesRules bytes = 15;
    case kBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.bytes_);
      break;
    }
    // .validate.EnumRules enum = 16;
    case kEnum: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.enum__);
      break;
    }
    // .validate.RepeatedRules repeated = 18;
    case kRepeated: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.repeated_);
      break;
    }
    // .validate.MapRules map = 19;
    case kMap: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.map_);
      break;
    }
    // .validate.AnyRules any = 20;
    case kAny: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.any_);
      break;
    }
    // .validate.DurationRules duration = 21;
    case kDuration: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.duration_);
      break;
    }
    // .validate.TimestampRules timestamp = 22;
    case kTimestamp: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.timestamp_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FieldRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FieldRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FieldRules::GetClassData() const { return &_class_data_; }

void FieldRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<FieldRules *>(to)->MergeFrom(
      static_cast<const FieldRules &>(from));
}


void FieldRules::MergeFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.FieldRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message()) {
    _internal_mutable_message()->::validate::MessageRules::MergeFrom(from._internal_message());
  }
  switch (from.type_case()) {
    case kFloat: {
      _internal_mutable_float_()->::validate::FloatRules::MergeFrom(from._internal_float_());
      break;
    }
    case kDouble: {
      _internal_mutable_double_()->::validate::DoubleRules::MergeFrom(from._internal_double_());
      break;
    }
    case kInt32: {
      _internal_mutable_int32()->::validate::Int32Rules::MergeFrom(from._internal_int32());
      break;
    }
    case kInt64: {
      _internal_mutable_int64()->::validate::Int64Rules::MergeFrom(from._internal_int64());
      break;
    }
    case kUint32: {
      _internal_mutable_uint32()->::validate::UInt32Rules::MergeFrom(from._internal_uint32());
      break;
    }
    case kUint64: {
      _internal_mutable_uint64()->::validate::UInt64Rules::MergeFrom(from._internal_uint64());
      break;
    }
    case kSint32: {
      _internal_mutable_sint32()->::validate::SInt32Rules::MergeFrom(from._internal_sint32());
      break;
    }
    case kSint64: {
      _internal_mutable_sint64()->::validate::SInt64Rules::MergeFrom(from._internal_sint64());
      break;
    }
    case kFixed32: {
      _internal_mutable_fixed32()->::validate::Fixed32Rules::MergeFrom(from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _internal_mutable_fixed64()->::validate::Fixed64Rules::MergeFrom(from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _internal_mutable_sfixed32()->::validate::SFixed32Rules::MergeFrom(from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _internal_mutable_sfixed64()->::validate::SFixed64Rules::MergeFrom(from._internal_sfixed64());
      break;
    }
    case kBool: {
      _internal_mutable_bool_()->::validate::BoolRules::MergeFrom(from._internal_bool_());
      break;
    }
    case kString: {
      _internal_mutable_string()->::validate::StringRules::MergeFrom(from._internal_string());
      break;
    }
    case kBytes: {
      _internal_mutable_bytes()->::validate::BytesRules::MergeFrom(from._internal_bytes());
      break;
    }
    case kEnum: {
      _internal_mutable_enum_()->::validate::EnumRules::MergeFrom(from._internal_enum_());
      break;
    }
    case kRepeated: {
      _internal_mutable_repeated()->::validate::RepeatedRules::MergeFrom(from._internal_repeated());
      break;
    }
    case kMap: {
      _internal_mutable_map()->::validate::MapRules::MergeFrom(from._internal_map());
      break;
    }
    case kAny: {
      _internal_mutable_any()->::validate::AnyRules::MergeFrom(from._internal_any());
      break;
    }
    case kDuration: {
      _internal_mutable_duration()->::validate::DurationRules::MergeFrom(from._internal_duration());
      break;
    }
    case kTimestamp: {
      _internal_mutable_timestamp()->::validate::TimestampRules::MergeFrom(from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FieldRules::CopyFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FieldRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldRules::IsInitialized() const {
  return true;
}

void FieldRules::InternalSwap(FieldRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(message_, other->message_);
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[0]);
}

// ===================================================================

class FloatRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FloatRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

FloatRules::FloatRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.FloatRules)
}
FloatRules::FloatRules(const FloatRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.FloatRules)
}

inline void FloatRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

FloatRules::~FloatRules() {
  // @@protoc_insertion_point(destructor:validate.FloatRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FloatRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FloatRules::ArenaDtor(void* object) {
  FloatRules* _this = reinterpret_cast< FloatRules* >(object);
  (void)_this;
}
void FloatRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FloatRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FloatRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FloatRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FloatRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FloatRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.FloatRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_const_(), target);
  }

  // optional float lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_lt(), target);
  }

  // optional float lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_lte(), target);
  }

  // optional float gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_gt(), target);
  }

  // optional float gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_gte(), target);
  }

  // repeated float in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_in(i), target);
  }

  // repeated float not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FloatRules)
  return target;
}

size_t FloatRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.FloatRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated float not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FloatRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FloatRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FloatRules::GetClassData() const { return &_class_data_; }

void FloatRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<FloatRules *>(to)->MergeFrom(
      static_cast<const FloatRules &>(from));
}


void FloatRules::MergeFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.FloatRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FloatRules::CopyFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatRules::IsInitialized() const {
  return true;
}

void FloatRules::InternalSwap(FloatRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatRules, gte_)
      + sizeof(FloatRules::gte_)
      - PROTOBUF_FIELD_OFFSET(FloatRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata FloatRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[1]);
}

// ===================================================================

class DoubleRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DoubleRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

DoubleRules::DoubleRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.DoubleRules)
}
DoubleRules::DoubleRules(const DoubleRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.DoubleRules)
}

inline void DoubleRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

DoubleRules::~DoubleRules() {
  // @@protoc_insertion_point(destructor:validate.DoubleRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DoubleRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoubleRules::ArenaDtor(void* object) {
  DoubleRules* _this = reinterpret_cast< DoubleRules* >(object);
  (void)_this;
}
void DoubleRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DoubleRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DoubleRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DoubleRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoubleRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // repeated double in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DoubleRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.DoubleRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_const_(), target);
  }

  // optional double lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_lt(), target);
  }

  // optional double lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_lte(), target);
  }

  // optional double gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_gt(), target);
  }

  // optional double gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_gte(), target);
  }

  // repeated double in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_in(i), target);
  }

  // repeated double not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DoubleRules)
  return target;
}

size_t DoubleRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.DoubleRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated double not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional double const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoubleRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DoubleRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoubleRules::GetClassData() const { return &_class_data_; }

void DoubleRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<DoubleRules *>(to)->MergeFrom(
      static_cast<const DoubleRules &>(from));
}


void DoubleRules::MergeFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.DoubleRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleRules::CopyFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleRules::IsInitialized() const {
  return true;
}

void DoubleRules::InternalSwap(DoubleRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRules, gte_)
      + sizeof(DoubleRules::gte_)
      - PROTOBUF_FIELD_OFFSET(DoubleRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoubleRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[2]);
}

// ===================================================================

class Int32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Int32Rules::Int32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.Int32Rules)
}
Int32Rules::Int32Rules(const Int32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Int32Rules)
}

inline void Int32Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Int32Rules::~Int32Rules() {
  // @@protoc_insertion_point(destructor:validate.Int32Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Int32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int32Rules::ArenaDtor(void* object) {
  Int32Rules* _this = reinterpret_cast< Int32Rules* >(object);
  (void)_this;
}
void Int32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Int32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Int32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional int32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_lt(), target);
  }

  // optional int32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_lte(), target);
  }

  // optional int32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_gt(), target);
  }

  // optional int32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_gte(), target);
  }

  // repeated int32 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated int32 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int32Rules)
  return target;
}

size_t Int32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Int32Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_const_());
    }

    // optional int32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_lt());
    }

    // optional int32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_lte());
    }

    // optional int32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_gt());
    }

    // optional int32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_gte());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Int32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Int32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Int32Rules::GetClassData() const { return &_class_data_; }

void Int32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<Int32Rules *>(to)->MergeFrom(
      static_cast<const Int32Rules &>(from));
}


void Int32Rules::MergeFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Int32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Int32Rules::CopyFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int32Rules::IsInitialized() const {
  return true;
}

void Int32Rules::InternalSwap(Int32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Int32Rules, gte_)
      + sizeof(Int32Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(Int32Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Int32Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[3]);
}

// ===================================================================

class Int64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Int64Rules::Int64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.Int64Rules)
}
Int64Rules::Int64Rules(const Int64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Int64Rules)
}

inline void Int64Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Int64Rules::~Int64Rules() {
  // @@protoc_insertion_point(destructor:validate.Int64Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Int64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Int64Rules::ArenaDtor(void* object) {
  Int64Rules* _this = reinterpret_cast< Int64Rules* >(object);
  (void)_this;
}
void Int64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Int64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Int64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Int64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_const_(), target);
  }

  // optional int64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_lt(), target);
  }

  // optional int64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_lte(), target);
  }

  // optional int64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_gt(), target);
  }

  // optional int64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_gte(), target);
  }

  // repeated int64 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated int64 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int64Rules)
  return target;
}

size_t Int64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Int64Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 in = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int64 not_in = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_const_());
    }

    // optional int64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_lt());
    }

    // optional int64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_lte());
    }

    // optional int64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_gt());
    }

    // optional int64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_gte());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Int64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Int64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Int64Rules::GetClassData() const { return &_class_data_; }

void Int64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<Int64Rules *>(to)->MergeFrom(
      static_cast<const Int64Rules &>(from));
}


void Int64Rules::MergeFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Int64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Int64Rules::CopyFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Rules::IsInitialized() const {
  return true;
}

void Int64Rules::InternalSwap(Int64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Int64Rules, gte_)
      + sizeof(Int64Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(Int64Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Int64Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[4]);
}

// ===================================================================

class UInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UInt32Rules::UInt32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.UInt32Rules)
}
UInt32Rules::UInt32Rules(const UInt32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.UInt32Rules)
}

inline void UInt32Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

UInt32Rules::~UInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt32Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UInt32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UInt32Rules::ArenaDtor(void* object) {
  UInt32Rules* _this = reinterpret_cast< UInt32Rules* >(object);
  (void)_this;
}
void UInt32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UInt32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UInt32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UInt32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional uint32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lt(), target);
  }

  // optional uint32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lte(), target);
  }

  // optional uint32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gt(), target);
  }

  // optional uint32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_gte(), target);
  }

  // repeated uint32 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated uint32 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt32Rules)
  return target;
}

size_t UInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.UInt32Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 in = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated uint32 not_in = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_const_());
    }

    // optional uint32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lt());
    }

    // optional uint32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lte());
    }

    // optional uint32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_gt());
    }

    // optional uint32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_gte());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UInt32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UInt32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UInt32Rules::GetClassData() const { return &_class_data_; }

void UInt32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<UInt32Rules *>(to)->MergeFrom(
      static_cast<const UInt32Rules &>(from));
}


void UInt32Rules::MergeFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UInt32Rules::CopyFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt32Rules::IsInitialized() const {
  return true;
}

void UInt32Rules::InternalSwap(UInt32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UInt32Rules, gte_)
      + sizeof(UInt32Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(UInt32Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata UInt32Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[5]);
}

// ===================================================================

class UInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UInt64Rules::UInt64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.UInt64Rules)
}
UInt64Rules::UInt64Rules(const UInt64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.UInt64Rules)
}

inline void UInt64Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

UInt64Rules::~UInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt64Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UInt64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UInt64Rules::ArenaDtor(void* object) {
  UInt64Rules* _this = reinterpret_cast< UInt64Rules* >(object);
  (void)_this;
}
void UInt64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UInt64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UInt64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UInt64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_const_(), target);
  }

  // optional uint64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_lt(), target);
  }

  // optional uint64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_lte(), target);
  }

  // optional uint64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_gt(), target);
  }

  // optional uint64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_gte(), target);
  }

  // repeated uint64 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated uint64 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt64Rules)
  return target;
}

size_t UInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.UInt64Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 in = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated uint64 not_in = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_const_());
    }

    // optional uint64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_lt());
    }

    // optional uint64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_lte());
    }

    // optional uint64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_gt());
    }

    // optional uint64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_gte());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UInt64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UInt64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UInt64Rules::GetClassData() const { return &_class_data_; }

void UInt64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<UInt64Rules *>(to)->MergeFrom(
      static_cast<const UInt64Rules &>(from));
}


void UInt64Rules::MergeFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UInt64Rules::CopyFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt64Rules::IsInitialized() const {
  return true;
}

void UInt64Rules::InternalSwap(UInt64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UInt64Rules, gte_)
      + sizeof(UInt64Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(UInt64Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata UInt64Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[6]);
}

// ===================================================================

class SInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SInt32Rules::SInt32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.SInt32Rules)
}
SInt32Rules::SInt32Rules(const SInt32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SInt32Rules)
}

inline void SInt32Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SInt32Rules::~SInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt32Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SInt32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SInt32Rules::ArenaDtor(void* object) {
  SInt32Rules* _this = reinterpret_cast< SInt32Rules* >(object);
  (void)_this;
}
void SInt32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SInt32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SInt32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint32 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint32 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SInt32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional sint32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(2, this->_internal_lt(), target);
  }

  // optional sint32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->_internal_lte(), target);
  }

  // optional sint32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(4, this->_internal_gt(), target);
  }

  // optional sint32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(5, this->_internal_gte(), target);
  }

  // repeated sint32 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated sint32 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt32Rules)
  return target;
}

size_t SInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SInt32Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint32 in = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sint32 not_in = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sint32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_const_());
    }

    // optional sint32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_lt());
    }

    // optional sint32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_lte());
    }

    // optional sint32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_gt());
    }

    // optional sint32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_gte());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SInt32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SInt32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SInt32Rules::GetClassData() const { return &_class_data_; }

void SInt32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<SInt32Rules *>(to)->MergeFrom(
      static_cast<const SInt32Rules &>(from));
}


void SInt32Rules::MergeFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SInt32Rules::CopyFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt32Rules::IsInitialized() const {
  return true;
}

void SInt32Rules::InternalSwap(SInt32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SInt32Rules, gte_)
      + sizeof(SInt32Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(SInt32Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SInt32Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[7]);
}

// ===================================================================

class SInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SInt64Rules::SInt64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.SInt64Rules)
}
SInt64Rules::SInt64Rules(const SInt64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SInt64Rules)
}

inline void SInt64Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SInt64Rules::~SInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt64Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SInt64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SInt64Rules::ArenaDtor(void* object) {
  SInt64Rules* _this = reinterpret_cast< SInt64Rules* >(object);
  (void)_this;
}
void SInt64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SInt64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SInt64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint64 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint64 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint64 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint64 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint64 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint64 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint64 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SInt64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(1, this->_internal_const_(), target);
  }

  // optional sint64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(2, this->_internal_lt(), target);
  }

  // optional sint64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(3, this->_internal_lte(), target);
  }

  // optional sint64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(4, this->_internal_gt(), target);
  }

  // optional sint64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(5, this->_internal_gte(), target);
  }

  // repeated sint64 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated sint64 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt64Rules)
  return target;
}

size_t SInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SInt64Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint64 in = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt64Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sint64 not_in = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt64Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sint64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_const_());
    }

    // optional sint64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_lt());
    }

    // optional sint64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_lte());
    }

    // optional sint64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_gt());
    }

    // optional sint64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_gte());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SInt64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SInt64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SInt64Rules::GetClassData() const { return &_class_data_; }

void SInt64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<SInt64Rules *>(to)->MergeFrom(
      static_cast<const SInt64Rules &>(from));
}


void SInt64Rules::MergeFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SInt64Rules::CopyFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt64Rules::IsInitialized() const {
  return true;
}

void SInt64Rules::InternalSwap(SInt64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SInt64Rules, gte_)
      + sizeof(SInt64Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(SInt64Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SInt64Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[8]);
}

// ===================================================================

class Fixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Fixed32Rules::Fixed32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.Fixed32Rules)
}
Fixed32Rules::Fixed32Rules(const Fixed32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Fixed32Rules)
}

inline void Fixed32Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Fixed32Rules::~Fixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed32Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Fixed32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fixed32Rules::ArenaDtor(void* object) {
  Fixed32Rules* _this = reinterpret_cast< Fixed32Rules* >(object);
  (void)_this;
}
void Fixed32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Fixed32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fixed32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed32 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed32 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed32 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed32 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // repeated fixed32 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated fixed32 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Fixed32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(1, this->_internal_const_(), target);
  }

  // optional fixed32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(2, this->_internal_lt(), target);
  }

  // optional fixed32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(3, this->_internal_lte(), target);
  }

  // optional fixed32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(4, this->_internal_gt(), target);
  }

  // optional fixed32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(5, this->_internal_gte(), target);
  }

  // repeated fixed32 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(6, this->_internal_in(i), target);
  }

  // repeated fixed32 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed32Rules)
  return target;
}

size_t Fixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Fixed32Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated fixed32 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional fixed32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional fixed32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional fixed32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fixed32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Fixed32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fixed32Rules::GetClassData() const { return &_class_data_; }

void Fixed32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<Fixed32Rules *>(to)->MergeFrom(
      static_cast<const Fixed32Rules &>(from));
}


void Fixed32Rules::MergeFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed32Rules::CopyFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed32Rules::IsInitialized() const {
  return true;
}

void Fixed32Rules::InternalSwap(Fixed32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fixed32Rules, gte_)
      + sizeof(Fixed32Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(Fixed32Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Fixed32Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[9]);
}

// ===================================================================

class Fixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Fixed64Rules::Fixed64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.Fixed64Rules)
}
Fixed64Rules::Fixed64Rules(const Fixed64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.Fixed64Rules)
}

inline void Fixed64Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

Fixed64Rules::~Fixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed64Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Fixed64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fixed64Rules::ArenaDtor(void* object) {
  Fixed64Rules* _this = reinterpret_cast< Fixed64Rules* >(object);
  (void)_this;
}
void Fixed64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Fixed64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fixed64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional fixed64 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional fixed64 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional fixed64 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional fixed64 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // repeated fixed64 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated fixed64 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Fixed64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_const_(), target);
  }

  // optional fixed64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_lt(), target);
  }

  // optional fixed64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(3, this->_internal_lte(), target);
  }

  // optional fixed64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(4, this->_internal_gt(), target);
  }

  // optional fixed64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(5, this->_internal_gte(), target);
  }

  // repeated fixed64 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(6, this->_internal_in(i), target);
  }

  // repeated fixed64 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed64Rules)
  return target;
}

size_t Fixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.Fixed64Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated fixed64 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional fixed64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional fixed64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional fixed64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fixed64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Fixed64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fixed64Rules::GetClassData() const { return &_class_data_; }

void Fixed64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<Fixed64Rules *>(to)->MergeFrom(
      static_cast<const Fixed64Rules &>(from));
}


void Fixed64Rules::MergeFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed64Rules::CopyFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed64Rules::IsInitialized() const {
  return true;
}

void Fixed64Rules::InternalSwap(Fixed64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fixed64Rules, gte_)
      + sizeof(Fixed64Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(Fixed64Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Fixed64Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[10]);
}

// ===================================================================

class SFixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SFixed32Rules::SFixed32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.SFixed32Rules)
}
SFixed32Rules::SFixed32Rules(const SFixed32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SFixed32Rules)
}

inline void SFixed32Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SFixed32Rules::~SFixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed32Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SFixed32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SFixed32Rules::ArenaDtor(void* object) {
  SFixed32Rules* _this = reinterpret_cast< SFixed32Rules* >(object);
  (void)_this;
}
void SFixed32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SFixed32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SFixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SFixed32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sfixed32 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // optional sfixed32 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // optional sfixed32 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // optional sfixed32 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // optional sfixed32 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // repeated sfixed32 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sfixed32 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SFixed32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(1, this->_internal_const_(), target);
  }

  // optional sfixed32 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(2, this->_internal_lt(), target);
  }

  // optional sfixed32 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(3, this->_internal_lte(), target);
  }

  // optional sfixed32 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(4, this->_internal_gt(), target);
  }

  // optional sfixed32 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(5, this->_internal_gte(), target);
  }

  // repeated sfixed32 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(6, this->_internal_in(i), target);
  }

  // repeated sfixed32 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed32Rules)
  return target;
}

size_t SFixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SFixed32Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed32 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sfixed32 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sfixed32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SFixed32Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SFixed32Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SFixed32Rules::GetClassData() const { return &_class_data_; }

void SFixed32Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<SFixed32Rules *>(to)->MergeFrom(
      static_cast<const SFixed32Rules &>(from));
}


void SFixed32Rules::MergeFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed32Rules::CopyFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed32Rules::IsInitialized() const {
  return true;
}

void SFixed32Rules::InternalSwap(SFixed32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SFixed32Rules, gte_)
      + sizeof(SFixed32Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(SFixed32Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SFixed32Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[11]);
}

// ===================================================================

class SFixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SFixed64Rules::SFixed64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.SFixed64Rules)
}
SFixed64Rules::SFixed64Rules(const SFixed64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  // @@protoc_insertion_point(copy_constructor:validate.SFixed64Rules)
}

inline void SFixed64Rules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gte_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gte_));
}

SFixed64Rules::~SFixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed64Rules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SFixed64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SFixed64Rules::ArenaDtor(void* object) {
  SFixed64Rules* _this = reinterpret_cast< SFixed64Rules* >(object);
  (void)_this;
}
void SFixed64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SFixed64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SFixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gte_) -
        reinterpret_cast<char*>(&const__)) + sizeof(gte_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SFixed64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sfixed64 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // optional sfixed64 lt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_lt(&has_bits);
          lt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // optional sfixed64 lte = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_lte(&has_bits);
          lte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // optional sfixed64 gt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_gt(&has_bits);
          gt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // optional sfixed64 gte = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_gte(&has_bits);
          gte_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // repeated sfixed64 in = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sfixed64 not_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SFixed64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed64 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(1, this->_internal_const_(), target);
  }

  // optional sfixed64 lt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(2, this->_internal_lt(), target);
  }

  // optional sfixed64 lte = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(3, this->_internal_lte(), target);
  }

  // optional sfixed64 gt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(4, this->_internal_gt(), target);
  }

  // optional sfixed64 gte = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(5, this->_internal_gte(), target);
  }

  // repeated sfixed64 in = 6;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(6, this->_internal_in(i), target);
  }

  // repeated sfixed64 not_in = 7;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(7, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed64Rules)
  return target;
}

size_t SFixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.SFixed64Rules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed64 in = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sfixed64 not_in = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional sfixed64 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 lt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 lte = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 gt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 gte = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SFixed64Rules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SFixed64Rules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SFixed64Rules::GetClassData() const { return &_class_data_; }

void SFixed64Rules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<SFixed64Rules *>(to)->MergeFrom(
      static_cast<const SFixed64Rules &>(from));
}


void SFixed64Rules::MergeFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      lt_ = from.lt_;
    }
    if (cached_has_bits & 0x00000004u) {
      lte_ = from.lte_;
    }
    if (cached_has_bits & 0x00000008u) {
      gt_ = from.gt_;
    }
    if (cached_has_bits & 0x00000010u) {
      gte_ = from.gte_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed64Rules::CopyFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed64Rules::IsInitialized() const {
  return true;
}

void SFixed64Rules::InternalSwap(SFixed64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SFixed64Rules, gte_)
      + sizeof(SFixed64Rules::gte_)
      - PROTOBUF_FIELD_OFFSET(SFixed64Rules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata SFixed64Rules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[12]);
}

// ===================================================================

class BoolRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BoolRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BoolRules::BoolRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.BoolRules)
}
BoolRules::BoolRules(const BoolRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  const__ = from.const__;
  // @@protoc_insertion_point(copy_constructor:validate.BoolRules)
}

inline void BoolRules::SharedCtor() {
const__ = false;
}

BoolRules::~BoolRules() {
  // @@protoc_insertion_point(destructor:validate.BoolRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BoolRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BoolRules::ArenaDtor(void* object) {
  BoolRules* _this = reinterpret_cast< BoolRules* >(object);
  (void)_this;
}
void BoolRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BoolRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BoolRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BoolRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  const__ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoolRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BoolRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.BoolRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_const_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BoolRules)
  return target;
}

size_t BoolRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.BoolRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool const = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoolRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BoolRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoolRules::GetClassData() const { return &_class_data_; }

void BoolRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<BoolRules *>(to)->MergeFrom(
      static_cast<const BoolRules &>(from));
}


void BoolRules::MergeFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.BoolRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoolRules::CopyFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoolRules::IsInitialized() const {
  return true;
}

void BoolRules::InternalSwap(BoolRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(const__, other->const__);
}

::PROTOBUF_NAMESPACE_ID::Metadata BoolRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[13]);
}

// ===================================================================

class StringRules::_Internal {
 public:
  using HasBits = decltype(std::declval<StringRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_len_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_min_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_not_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_strict(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

StringRules::StringRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.StringRules)
}
StringRules::StringRules(const StringRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_const_()) {
    const__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_const_(), 
      GetArenaForAllocation());
  }
  pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_pattern()) {
    pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_pattern(), 
      GetArenaForAllocation());
  }
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_prefix()) {
    prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_prefix(), 
      GetArenaForAllocation());
  }
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_suffix()) {
    suffix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_suffix(), 
      GetArenaForAllocation());
  }
  contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_contains()) {
    contains_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_contains(), 
      GetArenaForAllocation());
  }
  not_contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_not_contains()) {
    not_contains_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_not_contains(), 
      GetArenaForAllocation());
  }
  ::memcpy(&min_len_, &from.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&strict_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(strict_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kEmail: {
      _internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _internal_set_uuid(from._internal_uuid());
      break;
    }
    case kWellKnownRegex: {
      _internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.StringRules)
}

inline void StringRules::SharedCtor() {
const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
not_contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&min_len_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_bytes_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(len_bytes_));
strict_ = true;
clear_has_well_known();
}

StringRules::~StringRules() {
  // @@protoc_insertion_point(destructor:validate.StringRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StringRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  const__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pattern_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  contains_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  not_contains_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_well_known()) {
    clear_well_known();
  }
}

void StringRules::ArenaDtor(void* object) {
  StringRules* _this = reinterpret_cast< StringRules* >(object);
  (void)_this;
}
void StringRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StringRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StringRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.StringRules)
  switch (well_known_case()) {
    case kEmail: {
      // No need to clear
      break;
    }
    case kHostname: {
      // No need to clear
      break;
    }
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case kUri: {
      // No need to clear
      break;
    }
    case kUriRef: {
      // No need to clear
      break;
    }
    case kAddress: {
      // No need to clear
      break;
    }
    case kUuid: {
      // No need to clear
      break;
    }
    case kWellKnownRegex: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void StringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.StringRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      contains_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      not_contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_len_) -
        reinterpret_cast<char*>(&min_len_)) + sizeof(max_len_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&min_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_bytes_) -
        reinterpret_cast<char*>(&min_bytes_)) + sizeof(len_bytes_));
    strict_ = true;
  }
  clear_well_known();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StringRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_const_();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.const");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 min_len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_min_len(&has_bits);
          min_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_len(&has_bits);
          max_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 min_bytes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_min_bytes(&has_bits);
          min_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_bytes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_max_bytes(&has_bits);
          max_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string pattern = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_pattern();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.pattern");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string prefix = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_prefix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.prefix");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string suffix = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_suffix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.suffix");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string contains = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_contains();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.contains");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string in = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string not_in = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.not_in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // bool email = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _internal_set_email(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool hostname = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _internal_set_hostname(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ip = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _internal_set_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv4 = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _internal_set_ipv4(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv6 = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _internal_set_ipv6(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool uri = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _internal_set_uri(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool uri_ref = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _internal_set_uri_ref(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len_bytes = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_len_bytes(&has_bits);
          len_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool address = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _internal_set_address(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool uuid = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string not_contains = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          auto str = _internal_mutable_not_contains();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.StringRules.not_contains");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .validate.KnownRegex well_known_regex = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::validate::KnownRegex_IsValid(val))) {
            _internal_set_well_known_regex(static_cast<::validate::KnownRegex>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(24, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool strict = 25 [default = true];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_strict(&has_bits);
          strict_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StringRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.StringRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string const = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_const_().data(), static_cast<int>(this->_internal_const_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.const");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_const_(), target);
  }

  // optional uint64 min_len = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_len(), target);
  }

  // optional uint64 min_bytes = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_min_bytes(), target);
  }

  // optional uint64 max_bytes = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_max_bytes(), target);
  }

  // optional string pattern = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern().data(), static_cast<int>(this->_internal_pattern().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.pattern");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_pattern(), target);
  }

  // optional string prefix = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prefix().data(), static_cast<int>(this->_internal_prefix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.prefix");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_prefix(), target);
  }

  // optional string suffix = 8;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_suffix().data(), static_cast<int>(this->_internal_suffix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.suffix");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_suffix(), target);
  }

  // optional string contains = 9;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contains().data(), static_cast<int>(this->_internal_contains().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.contains");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_contains(), target);
  }

  // repeated string in = 10;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.in");
    target = stream->WriteString(10, s, target);
  }

  // repeated string not_in = 11;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.not_in");
    target = stream->WriteString(11, s, target);
  }

  switch (well_known_case()) {
    case kEmail: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_email(), target);
      break;
    }
    case kHostname: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_hostname(), target);
      break;
    }
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_ipv6(), target);
      break;
    }
    case kUri: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_uri(), target);
      break;
    }
    case kUriRef: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_uri_ref(), target);
      break;
    }
    default: ;
  }
  // optional uint64 len = 19;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(19, this->_internal_len(), target);
  }

  // optional uint64 len_bytes = 20;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(20, this->_internal_len_bytes(), target);
  }

  switch (well_known_case()) {
    case kAddress: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_address(), target);
      break;
    }
    case kUuid: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_uuid(), target);
      break;
    }
    default: ;
  }
  // optional string not_contains = 23;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_contains().data(), static_cast<int>(this->_internal_not_contains().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.StringRules.not_contains");
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_not_contains(), target);
  }

  // .validate.KnownRegex well_known_regex = 24;
  if (_internal_has_well_known_regex()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      24, this->_internal_well_known_regex(), target);
  }

  // optional bool strict = 25 [default = true];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(25, this->_internal_strict(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.StringRules)
  return target;
}

size_t StringRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.StringRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(in_.size());
  for (int i = 0, n = in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      in_.Get(i));
  }

  // repeated string not_in = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(not_in_.size());
  for (int i = 0, n = not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      not_in_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_const_());
    }

    // optional string pattern = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pattern());
    }

    // optional string prefix = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prefix());
    }

    // optional string suffix = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_suffix());
    }

    // optional string contains = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contains());
    }

    // optional string not_contains = 23;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_contains());
    }

    // optional uint64 min_len = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_len());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 min_bytes = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_bytes());
    }

    // optional uint64 max_bytes = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_bytes());
    }

    // optional uint64 len = 19;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_len());
    }

    // optional uint64 len_bytes = 20;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_len_bytes());
    }

    // optional bool strict = 25 [default = true];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

  }
  switch (well_known_case()) {
    // bool email = 12;
    case kEmail: {
      total_size += 1 + 1;
      break;
    }
    // bool hostname = 13;
    case kHostname: {
      total_size += 1 + 1;
      break;
    }
    // bool ip = 14;
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv4 = 15;
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv6 = 16;
    case kIpv6: {
      total_size += 2 + 1;
      break;
    }
    // bool uri = 17;
    case kUri: {
      total_size += 2 + 1;
      break;
    }
    // bool uri_ref = 18;
    case kUriRef: {
      total_size += 2 + 1;
      break;
    }
    // bool address = 21;
    case kAddress: {
      total_size += 2 + 1;
      break;
    }
    // bool uuid = 22;
    case kUuid: {
      total_size += 2 + 1;
      break;
    }
    // .validate.KnownRegex well_known_regex = 24;
    case kWellKnownRegex: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StringRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StringRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StringRules::GetClassData() const { return &_class_data_; }

void StringRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<StringRules *>(to)->MergeFrom(
      static_cast<const StringRules &>(from));
}


void StringRules::MergeFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.StringRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_not_contains(from._internal_not_contains());
    }
    if (cached_has_bits & 0x00000040u) {
      min_len_ = from.min_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      max_len_ = from.max_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      min_bytes_ = from.min_bytes_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_bytes_ = from.max_bytes_;
    }
    if (cached_has_bits & 0x00000400u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000800u) {
      len_bytes_ = from.len_bytes_;
    }
    if (cached_has_bits & 0x00001000u) {
      strict_ = from.strict_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kEmail: {
      _internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _internal_set_uuid(from._internal_uuid());
      break;
    }
    case kWellKnownRegex: {
      _internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StringRules::CopyFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringRules::IsInitialized() const {
  return true;
}

void StringRules::InternalSwap(StringRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &const__, GetArenaForAllocation(),
      &other->const__, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &pattern_, GetArenaForAllocation(),
      &other->pattern_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &prefix_, GetArenaForAllocation(),
      &other->prefix_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &suffix_, GetArenaForAllocation(),
      &other->suffix_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &contains_, GetArenaForAllocation(),
      &other->contains_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &not_contains_, GetArenaForAllocation(),
      &other->not_contains_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StringRules, len_bytes_)
      + sizeof(StringRules::len_bytes_)
      - PROTOBUF_FIELD_OFFSET(StringRules, min_len_)>(
          reinterpret_cast<char*>(&min_len_),
          reinterpret_cast<char*>(&other->min_len_));
  swap(strict_, other->strict_);
  swap(well_known_, other->well_known_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StringRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[14]);
}

// ===================================================================

class BytesRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BytesRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

BytesRules::BytesRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.BytesRules)
}
BytesRules::BytesRules(const BytesRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_const_()) {
    const__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_const_(), 
      GetArenaForAllocation());
  }
  pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_pattern()) {
    pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_pattern(), 
      GetArenaForAllocation());
  }
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_prefix()) {
    prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_prefix(), 
      GetArenaForAllocation());
  }
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_suffix()) {
    suffix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_suffix(), 
      GetArenaForAllocation());
  }
  contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_contains()) {
    contains_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_contains(), 
      GetArenaForAllocation());
  }
  ::memcpy(&min_len_, &from.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:validate.BytesRules)
}

inline void BytesRules::SharedCtor() {
const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&min_len_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
clear_has_well_known();
}

BytesRules::~BytesRules() {
  // @@protoc_insertion_point(destructor:validate.BytesRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BytesRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  const__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pattern_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  contains_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_well_known()) {
    clear_well_known();
  }
}

void BytesRules::ArenaDtor(void* object) {
  BytesRules* _this = reinterpret_cast< BytesRules* >(object);
  (void)_this;
}
void BytesRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BytesRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BytesRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.BytesRules)
  switch (well_known_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void BytesRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BytesRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  }
  clear_well_known();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BytesRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_const_();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 min_len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_min_len(&has_bits);
          min_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_len(&has_bits);
          max_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string pattern = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_pattern();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.BytesRules.pattern");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes prefix = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_prefix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes suffix = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_suffix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes contains = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_contains();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes in = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated bytes not_in = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      // bool ip = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _internal_set_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv4 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _internal_set_ipv4(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv6 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _internal_set_ipv6(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BytesRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.BytesRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_const_(), target);
  }

  // optional uint64 min_len = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_len(), target);
  }

  // optional string pattern = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern().data(), static_cast<int>(this->_internal_pattern().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.BytesRules.pattern");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_pattern(), target);
  }

  // optional bytes prefix = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_prefix(), target);
  }

  // optional bytes suffix = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_suffix(), target);
  }

  // optional bytes contains = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_contains(), target);
  }

  // repeated bytes in = 8;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    target = stream->WriteBytes(8, s, target);
  }

  // repeated bytes not_in = 9;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    target = stream->WriteBytes(9, s, target);
  }

  switch (well_known_case()) {
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_ipv6(), target);
      break;
    }
    default: ;
  }
  // optional uint64 len = 13;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(13, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BytesRules)
  return target;
}

size_t BytesRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.BytesRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes in = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(in_.size());
  for (int i = 0, n = in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      in_.Get(i));
  }

  // repeated bytes not_in = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(not_in_.size());
  for (int i = 0, n = not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      not_in_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_const_());
    }

    // optional string pattern = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pattern());
    }

    // optional bytes prefix = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_prefix());
    }

    // optional bytes suffix = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_suffix());
    }

    // optional bytes contains = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_contains());
    }

    // optional uint64 min_len = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_len());
    }

    // optional uint64 len = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_len());
    }

  }
  switch (well_known_case()) {
    // bool ip = 10;
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv4 = 11;
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv6 = 12;
    case kIpv6: {
      total_size += 1 + 1;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BytesRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BytesRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BytesRules::GetClassData() const { return &_class_data_; }

void BytesRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<BytesRules *>(to)->MergeFrom(
      static_cast<const BytesRules &>(from));
}


void BytesRules::MergeFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.BytesRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      min_len_ = from.min_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_len_ = from.max_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BytesRules::CopyFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BytesRules::IsInitialized() const {
  return true;
}

void BytesRules::InternalSwap(BytesRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &const__, GetArenaForAllocation(),
      &other->const__, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &pattern_, GetArenaForAllocation(),
      &other->pattern_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &prefix_, GetArenaForAllocation(),
      &other->prefix_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &suffix_, GetArenaForAllocation(),
      &other->suffix_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &contains_, GetArenaForAllocation(),
      &other->contains_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BytesRules, len_)
      + sizeof(BytesRules::len_)
      - PROTOBUF_FIELD_OFFSET(BytesRules, min_len_)>(
          reinterpret_cast<char*>(&min_len_),
          reinterpret_cast<char*>(&other->min_len_));
  swap(well_known_, other->well_known_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BytesRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[15]);
}

// ===================================================================

class EnumRules::_Internal {
 public:
  using HasBits = decltype(std::declval<EnumRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_defined_only(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

EnumRules::EnumRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.EnumRules)
}
EnumRules::EnumRules(const EnumRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&defined_only_) -
    reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
  // @@protoc_insertion_point(copy_constructor:validate.EnumRules)
}

inline void EnumRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&defined_only_) -
    reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
}

EnumRules::~EnumRules() {
  // @@protoc_insertion_point(destructor:validate.EnumRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EnumRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EnumRules::ArenaDtor(void* object) {
  EnumRules* _this = reinterpret_cast< EnumRules* >(object);
  (void)_this;
}
void EnumRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EnumRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EnumRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.EnumRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&defined_only_) -
        reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnumRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 const = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool defined_only = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_defined_only(&has_bits);
          defined_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 in = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 not_in = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EnumRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.EnumRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional bool defined_only = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_defined_only(), target);
  }

  // repeated int32 in = 3;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_in(i), target);
  }

  // repeated int32 not_in = 4;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_not_in(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.EnumRules)
  return target;
}

size_t EnumRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.EnumRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 const = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_const_());
    }

    // optional bool defined_only = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnumRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EnumRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnumRules::GetClassData() const { return &_class_data_; }

void EnumRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<EnumRules *>(to)->MergeFrom(
      static_cast<const EnumRules &>(from));
}


void EnumRules::MergeFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.EnumRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      defined_only_ = from.defined_only_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnumRules::CopyFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumRules::IsInitialized() const {
  return true;
}

void EnumRules::InternalSwap(EnumRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumRules, defined_only_)
      + sizeof(EnumRules::defined_only_)
      - PROTOBUF_FIELD_OFFSET(EnumRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnumRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[16]);
}

// ===================================================================

class MessageRules::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageRules>()._has_bits_);
  static void set_has_skip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MessageRules::MessageRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.MessageRules)
}
MessageRules::MessageRules(const MessageRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&skip_, &from.skip_,
    static_cast<size_t>(reinterpret_cast<char*>(&required_) -
    reinterpret_cast<char*>(&skip_)) + sizeof(required_));
  // @@protoc_insertion_point(copy_constructor:validate.MessageRules)
}

inline void MessageRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&skip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&required_) -
    reinterpret_cast<char*>(&skip_)) + sizeof(required_));
}

MessageRules::~MessageRules() {
  // @@protoc_insertion_point(destructor:validate.MessageRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MessageRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MessageRules::ArenaDtor(void* object) {
  MessageRules* _this = reinterpret_cast< MessageRules* >(object);
  (void)_this;
}
void MessageRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MessageRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MessageRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MessageRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&skip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&required_) -
      reinterpret_cast<char*>(&skip_)) + sizeof(required_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool skip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_skip(&has_bits);
          skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool required = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_required(&has_bits);
          required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MessageRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.MessageRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool skip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_skip(), target);
  }

  // optional bool required = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_required(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MessageRules)
  return target;
}

size_t MessageRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.MessageRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool skip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool required = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MessageRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageRules::GetClassData() const { return &_class_data_; }

void MessageRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<MessageRules *>(to)->MergeFrom(
      static_cast<const MessageRules &>(from));
}


void MessageRules::MergeFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.MessageRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      skip_ = from.skip_;
    }
    if (cached_has_bits & 0x00000002u) {
      required_ = from.required_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageRules::CopyFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MessageRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageRules::IsInitialized() const {
  return true;
}

void MessageRules::InternalSwap(MessageRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageRules, required_)
      + sizeof(MessageRules::required_)
      - PROTOBUF_FIELD_OFFSET(MessageRules, skip_)>(
          reinterpret_cast<char*>(&skip_),
          reinterpret_cast<char*>(&other->skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[17]);
}

// ===================================================================

class RepeatedRules::_Internal {
 public:
  using HasBits = decltype(std::declval<RepeatedRules>()._has_bits_);
  static void set_has_min_items(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_items(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unique(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::validate::FieldRules& items(const RepeatedRules* msg);
  static void set_has_items(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::validate::FieldRules&
RepeatedRules::_Internal::items(const RepeatedRules* msg) {
  return *msg->items_;
}
RepeatedRules::RepeatedRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.RepeatedRules)
}
RepeatedRules::RepeatedRules(const RepeatedRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_items()) {
    items_ = new ::validate::FieldRules(*from.items_);
  } else {
    items_ = nullptr;
  }
  ::memcpy(&min_items_, &from.min_items_,
    static_cast<size_t>(reinterpret_cast<char*>(&unique_) -
    reinterpret_cast<char*>(&min_items_)) + sizeof(unique_));
  // @@protoc_insertion_point(copy_constructor:validate.RepeatedRules)
}

inline void RepeatedRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&items_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&unique_) -
    reinterpret_cast<char*>(&items_)) + sizeof(unique_));
}

RepeatedRules::~RepeatedRules() {
  // @@protoc_insertion_point(destructor:validate.RepeatedRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RepeatedRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete items_;
}

void RepeatedRules::ArenaDtor(void* object) {
  RepeatedRules* _this = reinterpret_cast< RepeatedRules* >(object);
  (void)_this;
}
void RepeatedRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RepeatedRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RepeatedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.RepeatedRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(items_ != nullptr);
    items_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&min_items_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unique_) -
        reinterpret_cast<char*>(&min_items_)) + sizeof(unique_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepeatedRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 min_items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_min_items(&has_bits);
          min_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_items(&has_bits);
          max_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool unique = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_unique(&has_bits);
          unique_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .validate.FieldRules items = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_items(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RepeatedRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.RepeatedRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_items = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_min_items(), target);
  }

  // optional uint64 max_items = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_items(), target);
  }

  // optional bool unique = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_unique(), target);
  }

  // optional .validate.FieldRules items = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::items(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.RepeatedRules)
  return target;
}

size_t RepeatedRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.RepeatedRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .validate.FieldRules items = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *items_);
    }

    // optional uint64 min_items = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_items());
    }

    // optional uint64 max_items = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_items());
    }

    // optional bool unique = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepeatedRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RepeatedRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepeatedRules::GetClassData() const { return &_class_data_; }

void RepeatedRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<RepeatedRules *>(to)->MergeFrom(
      static_cast<const RepeatedRules &>(from));
}


void RepeatedRules::MergeFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.RepeatedRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_items()->::validate::FieldRules::MergeFrom(from._internal_items());
    }
    if (cached_has_bits & 0x00000002u) {
      min_items_ = from.min_items_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_items_ = from.max_items_;
    }
    if (cached_has_bits & 0x00000008u) {
      unique_ = from.unique_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepeatedRules::CopyFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedRules::IsInitialized() const {
  return true;
}

void RepeatedRules::InternalSwap(RepeatedRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepeatedRules, unique_)
      + sizeof(RepeatedRules::unique_)
      - PROTOBUF_FIELD_OFFSET(RepeatedRules, items_)>(
          reinterpret_cast<char*>(&items_),
          reinterpret_cast<char*>(&other->items_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RepeatedRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[18]);
}

// ===================================================================

class MapRules::_Internal {
 public:
  using HasBits = decltype(std::declval<MapRules>()._has_bits_);
  static void set_has_min_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_no_sparse(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::validate::FieldRules& keys(const MapRules* msg);
  static void set_has_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::validate::FieldRules& values(const MapRules* msg);
  static void set_has_values(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::validate::FieldRules&
MapRules::_Internal::keys(const MapRules* msg) {
  return *msg->keys_;
}
const ::validate::FieldRules&
MapRules::_Internal::values(const MapRules* msg) {
  return *msg->values_;
}
MapRules::MapRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.MapRules)
}
MapRules::MapRules(const MapRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_keys()) {
    keys_ = new ::validate::FieldRules(*from.keys_);
  } else {
    keys_ = nullptr;
  }
  if (from._internal_has_values()) {
    values_ = new ::validate::FieldRules(*from.values_);
  } else {
    values_ = nullptr;
  }
  ::memcpy(&min_pairs_, &from.min_pairs_,
    static_cast<size_t>(reinterpret_cast<char*>(&no_sparse_) -
    reinterpret_cast<char*>(&min_pairs_)) + sizeof(no_sparse_));
  // @@protoc_insertion_point(copy_constructor:validate.MapRules)
}

inline void MapRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keys_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&no_sparse_) -
    reinterpret_cast<char*>(&keys_)) + sizeof(no_sparse_));
}

MapRules::~MapRules() {
  // @@protoc_insertion_point(destructor:validate.MapRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MapRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete keys_;
  if (this != internal_default_instance()) delete values_;
}

void MapRules::ArenaDtor(void* object) {
  MapRules* _this = reinterpret_cast< MapRules* >(object);
  (void)_this;
}
void MapRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MapRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MapRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MapRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(keys_ != nullptr);
      keys_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(values_ != nullptr);
      values_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&min_pairs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&no_sparse_) -
        reinterpret_cast<char*>(&min_pairs_)) + sizeof(no_sparse_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 min_pairs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_min_pairs(&has_bits);
          min_pairs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_pairs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_pairs(&has_bits);
          max_pairs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool no_sparse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_no_sparse(&has_bits);
          no_sparse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .validate.FieldRules keys = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_keys(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .validate.FieldRules values = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_values(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MapRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.MapRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_pairs = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_min_pairs(), target);
  }

  // optional uint64 max_pairs = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_pairs(), target);
  }

  // optional bool no_sparse = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_no_sparse(), target);
  }

  // optional .validate.FieldRules keys = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::keys(this), target, stream);
  }

  // optional .validate.FieldRules values = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::values(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MapRules)
  return target;
}

size_t MapRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.MapRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .validate.FieldRules keys = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *keys_);
    }

    // optional .validate.FieldRules values = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *values_);
    }

    // optional uint64 min_pairs = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_pairs());
    }

    // optional uint64 max_pairs = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_pairs());
    }

    // optional bool no_sparse = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MapRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MapRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MapRules::GetClassData() const { return &_class_data_; }

void MapRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<MapRules *>(to)->MergeFrom(
      static_cast<const MapRules &>(from));
}


void MapRules::MergeFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.MapRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_keys()->::validate::FieldRules::MergeFrom(from._internal_keys());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_values()->::validate::FieldRules::MergeFrom(from._internal_values());
    }
    if (cached_has_bits & 0x00000004u) {
      min_pairs_ = from.min_pairs_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_pairs_ = from.max_pairs_;
    }
    if (cached_has_bits & 0x00000010u) {
      no_sparse_ = from.no_sparse_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MapRules::CopyFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapRules::IsInitialized() const {
  return true;
}

void MapRules::InternalSwap(MapRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapRules, no_sparse_)
      + sizeof(MapRules::no_sparse_)
      - PROTOBUF_FIELD_OFFSET(MapRules, keys_)>(
          reinterpret_cast<char*>(&keys_),
          reinterpret_cast<char*>(&other->keys_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MapRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[19]);
}

// ===================================================================

class AnyRules::_Internal {
 public:
  using HasBits = decltype(std::declval<AnyRules>()._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AnyRules::AnyRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.AnyRules)
}
AnyRules::AnyRules(const AnyRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  required_ = from.required_;
  // @@protoc_insertion_point(copy_constructor:validate.AnyRules)
}

inline void AnyRules::SharedCtor() {
required_ = false;
}

AnyRules::~AnyRules() {
  // @@protoc_insertion_point(destructor:validate.AnyRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AnyRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AnyRules::ArenaDtor(void* object) {
  AnyRules* _this = reinterpret_cast< AnyRules* >(object);
  (void)_this;
}
void AnyRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnyRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AnyRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.AnyRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  required_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnyRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool required = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_required(&has_bits);
          required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string in = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.AnyRules.in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string not_in = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "validate.AnyRules.not_in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AnyRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.AnyRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_required(), target);
  }

  // repeated string in = 2;
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.in");
    target = stream->WriteString(2, s, target);
  }

  // repeated string not_in = 3;
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "validate.AnyRules.not_in");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.AnyRules)
  return target;
}

size_t AnyRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.AnyRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(in_.size());
  for (int i = 0, n = in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      in_.Get(i));
  }

  // repeated string not_in = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(not_in_.size());
  for (int i = 0, n = not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      not_in_.Get(i));
  }

  // optional bool required = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnyRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AnyRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnyRules::GetClassData() const { return &_class_data_; }

void AnyRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<AnyRules *>(to)->MergeFrom(
      static_cast<const AnyRules &>(from));
}


void AnyRules::MergeFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.AnyRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  if (from._internal_has_required()) {
    _internal_set_required(from._internal_required());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnyRules::CopyFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnyRules::IsInitialized() const {
  return true;
}

void AnyRules::InternalSwap(AnyRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  swap(required_, other->required_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnyRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[20]);
}

// ===================================================================

class DurationRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DurationRules>()._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const PROTOBUF_NAMESPACE_ID::Duration& const_(const DurationRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const PROTOBUF_NAMESPACE_ID::Duration& lt(const DurationRules* msg);
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const PROTOBUF_NAMESPACE_ID::Duration& lte(const DurationRules* msg);
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const PROTOBUF_NAMESPACE_ID::Duration& gt(const DurationRules* msg);
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const PROTOBUF_NAMESPACE_ID::Duration& gte(const DurationRules* msg);
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::const_(const DurationRules* msg) {
  return *msg->const__;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::lt(const DurationRules* msg) {
  return *msg->lt_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::lte(const DurationRules* msg) {
  return *msg->lte_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::gt(const DurationRules* msg) {
  return *msg->gt_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::gte(const DurationRules* msg) {
  return *msg->gte_;
}
void DurationRules::clear_const_() {
  if (const__ != nullptr) const__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void DurationRules::clear_lt() {
  if (lt_ != nullptr) lt_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void DurationRules::clear_lte() {
  if (lte_ != nullptr) lte_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void DurationRules::clear_gt() {
  if (gt_ != nullptr) gt_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void DurationRules::clear_gte() {
  if (gte_ != nullptr) gte_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void DurationRules::clear_in() {
  in_.Clear();
}
void DurationRules::clear_not_in() {
  not_in_.Clear();
}
DurationRules::DurationRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.DurationRules)
}
DurationRules::DurationRules(const DurationRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_const_()) {
    const__ = new PROTOBUF_NAMESPACE_ID::Duration(*from.const__);
  } else {
    const__ = nullptr;
  }
  if (from._internal_has_lt()) {
    lt_ = new PROTOBUF_NAMESPACE_ID::Duration(*from.lt_);
  } else {
    lt_ = nullptr;
  }
  if (from._internal_has_lte()) {
    lte_ = new PROTOBUF_NAMESPACE_ID::Duration(*from.lte_);
  } else {
    lte_ = nullptr;
  }
  if (from._internal_has_gt()) {
    gt_ = new PROTOBUF_NAMESPACE_ID::Duration(*from.gt_);
  } else {
    gt_ = nullptr;
  }
  if (from._internal_has_gte()) {
    gte_ = new PROTOBUF_NAMESPACE_ID::Duration(*from.gte_);
  } else {
    gte_ = nullptr;
  }
  required_ = from.required_;
  // @@protoc_insertion_point(copy_constructor:validate.DurationRules)
}

inline void DurationRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&required_) -
    reinterpret_cast<char*>(&const__)) + sizeof(required_));
}

DurationRules::~DurationRules() {
  // @@protoc_insertion_point(destructor:validate.DurationRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DurationRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete const__;
  if (this != internal_default_instance()) delete lt_;
  if (this != internal_default_instance()) delete lte_;
  if (this != internal_default_instance()) delete gt_;
  if (this != internal_default_instance()) delete gte_;
}

void DurationRules::ArenaDtor(void* object) {
  DurationRules* _this = reinterpret_cast< DurationRules* >(object);
  (void)_this;
}
void DurationRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DurationRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DurationRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DurationRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(const__ != nullptr);
      const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lt_ != nullptr);
      lt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(lte_ != nullptr);
      lte_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(gt_ != nullptr);
      gt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(gte_ != nullptr);
      gte_->Clear();
    }
  }
  required_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DurationRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool required = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_required(&has_bits);
          required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration const = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration lt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration lte = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration gt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration gte = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .google.protobuf.Duration in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_in(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .google.protobuf.Duration not_in = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_not_in(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DurationRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.DurationRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_required(), target);
  }

  // optional .google.protobuf.Duration const = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::const_(this), target, stream);
  }

  // optional .google.protobuf.Duration lt = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::lt(this), target, stream);
  }

  // optional .google.protobuf.Duration lte = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::lte(this), target, stream);
  }

  // optional .google.protobuf.Duration gt = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::gt(this), target, stream);
  }

  // optional .google.protobuf.Duration gte = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::gte(this), target, stream);
  }

  // repeated .google.protobuf.Duration in = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_in_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_in(i), target, stream);
  }

  // repeated .google.protobuf.Duration not_in = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_not_in_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_not_in(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DurationRules)
  return target;
}

size_t DurationRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.DurationRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Duration in = 7;
  total_size += 1UL * this->_internal_in_size();
  for (const auto& msg : this->in_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.protobuf.Duration not_in = 8;
  total_size += 1UL * this->_internal_not_in_size();
  for (const auto& msg : this->not_in_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .google.protobuf.Duration const = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *const__);
    }

    // optional .google.protobuf.Duration lt = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lt_);
    }

    // optional .google.protobuf.Duration lte = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lte_);
    }

    // optional .google.protobuf.Duration gt = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gt_);
    }

    // optional .google.protobuf.Duration gte = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gte_);
    }

    // optional bool required = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DurationRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DurationRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DurationRules::GetClassData() const { return &_class_data_; }

void DurationRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<DurationRules *>(to)->MergeFrom(
      static_cast<const DurationRules &>(from));
}


void DurationRules::MergeFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.DurationRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_const_()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_lt()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_lt());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_lte()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_lte());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_gt()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_gt());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_gte()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_gte());
    }
    if (cached_has_bits & 0x00000020u) {
      required_ = from.required_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DurationRules::CopyFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DurationRules::IsInitialized() const {
  return true;
}

void DurationRules::InternalSwap(DurationRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DurationRules, required_)
      + sizeof(DurationRules::required_)
      - PROTOBUF_FIELD_OFFSET(DurationRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata DurationRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[21]);
}

// ===================================================================

class TimestampRules::_Internal {
 public:
  using HasBits = decltype(std::declval<TimestampRules>()._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const PROTOBUF_NAMESPACE_ID::Timestamp& const_(const TimestampRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const PROTOBUF_NAMESPACE_ID::Timestamp& lt(const TimestampRules* msg);
  static void set_has_lt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const PROTOBUF_NAMESPACE_ID::Timestamp& lte(const TimestampRules* msg);
  static void set_has_lte(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const PROTOBUF_NAMESPACE_ID::Timestamp& gt(const TimestampRules* msg);
  static void set_has_gt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const PROTOBUF_NAMESPACE_ID::Timestamp& gte(const TimestampRules* msg);
  static void set_has_gte(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lt_now(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gt_now(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const PROTOBUF_NAMESPACE_ID::Duration& within(const TimestampRules* msg);
  static void set_has_within(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::const_(const TimestampRules* msg) {
  return *msg->const__;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::lt(const TimestampRules* msg) {
  return *msg->lt_;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::lte(const TimestampRules* msg) {
  return *msg->lte_;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::gt(const TimestampRules* msg) {
  return *msg->gt_;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::gte(const TimestampRules* msg) {
  return *msg->gte_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
TimestampRules::_Internal::within(const TimestampRules* msg) {
  return *msg->within_;
}
void TimestampRules::clear_const_() {
  if (const__ != nullptr) const__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void TimestampRules::clear_lt() {
  if (lt_ != nullptr) lt_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void TimestampRules::clear_lte() {
  if (lte_ != nullptr) lte_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void TimestampRules::clear_gt() {
  if (gt_ != nullptr) gt_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void TimestampRules::clear_gte() {
  if (gte_ != nullptr) gte_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void TimestampRules::clear_within() {
  if (within_ != nullptr) within_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
TimestampRules::TimestampRules(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:validate.TimestampRules)
}
TimestampRules::TimestampRules(const TimestampRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_const_()) {
    const__ = new PROTOBUF_NAMESPACE_ID::Timestamp(*from.const__);
  } else {
    const__ = nullptr;
  }
  if (from._internal_has_lt()) {
    lt_ = new PROTOBUF_NAMESPACE_ID::Timestamp(*from.lt_);
  } else {
    lt_ = nullptr;
  }
  if (from._internal_has_lte()) {
    lte_ = new PROTOBUF_NAMESPACE_ID::Timestamp(*from.lte_);
  } else {
    lte_ = nullptr;
  }
  if (from._internal_has_gt()) {
    gt_ = new PROTOBUF_NAMESPACE_ID::Timestamp(*from.gt_);
  } else {
    gt_ = nullptr;
  }
  if (from._internal_has_gte()) {
    gte_ = new PROTOBUF_NAMESPACE_ID::Timestamp(*from.gte_);
  } else {
    gte_ = nullptr;
  }
  if (from._internal_has_within()) {
    within_ = new PROTOBUF_NAMESPACE_ID::Duration(*from.within_);
  } else {
    within_ = nullptr;
  }
  ::memcpy(&required_, &from.required_,
    static_cast<size_t>(reinterpret_cast<char*>(&gt_now_) -
    reinterpret_cast<char*>(&required_)) + sizeof(gt_now_));
  // @@protoc_insertion_point(copy_constructor:validate.TimestampRules)
}

inline void TimestampRules::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&const__) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gt_now_) -
    reinterpret_cast<char*>(&const__)) + sizeof(gt_now_));
}

TimestampRules::~TimestampRules() {
  // @@protoc_insertion_point(destructor:validate.TimestampRules)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TimestampRules::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete const__;
  if (this != internal_default_instance()) delete lt_;
  if (this != internal_default_instance()) delete lte_;
  if (this != internal_default_instance()) delete gt_;
  if (this != internal_default_instance()) delete gte_;
  if (this != internal_default_instance()) delete within_;
}

void TimestampRules::ArenaDtor(void* object) {
  TimestampRules* _this = reinterpret_cast< TimestampRules* >(object);
  (void)_this;
}
void TimestampRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TimestampRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TimestampRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.TimestampRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(const__ != nullptr);
      const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lt_ != nullptr);
      lt_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(lte_ != nullptr);
      lte_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(gt_ != nullptr);
      gt_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(gte_ != nullptr);
      gte_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(within_ != nullptr);
      within_->Clear();
    }
  }
  ::memset(&required_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lt_now_) -
      reinterpret_cast<char*>(&required_)) + sizeof(lt_now_));
  gt_now_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimestampRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool required = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_required(&has_bits);
          required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp const = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp lt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp lte = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp gt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Timestamp gte = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lt_now = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_lt_now(&has_bits);
          lt_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool gt_now = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_gt_now(&has_bits);
          gt_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration within = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_within(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TimestampRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:validate.TimestampRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_required(), target);
  }

  // optional .google.protobuf.Timestamp const = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::const_(this), target, stream);
  }

  // optional .google.protobuf.Timestamp lt = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::lt(this), target, stream);
  }

  // optional .google.protobuf.Timestamp lte = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::lte(this), target, stream);
  }

  // optional .google.protobuf.Timestamp gt = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::gt(this), target, stream);
  }

  // optional .google.protobuf.Timestamp gte = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::gte(this), target, stream);
  }

  // optional bool lt_now = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_lt_now(), target);
  }

  // optional bool gt_now = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_gt_now(), target);
  }

  // optional .google.protobuf.Duration within = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::within(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.TimestampRules)
  return target;
}

size_t TimestampRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:validate.TimestampRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .google.protobuf.Timestamp const = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *const__);
    }

    // optional .google.protobuf.Timestamp lt = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lt_);
    }

    // optional .google.protobuf.Timestamp lte = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lte_);
    }

    // optional .google.protobuf.Timestamp gt = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gt_);
    }

    // optional .google.protobuf.Timestamp gte = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gte_);
    }

    // optional .google.protobuf.Duration within = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *within_);
    }

    // optional bool required = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool lt_now = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool gt_now = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimestampRules::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TimestampRules::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimestampRules::GetClassData() const { return &_class_data_; }

void TimestampRules::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to,
                      const ::PROTOBUF_NAMESPACE_ID::Message&from) {
  static_cast<TimestampRules *>(to)->MergeFrom(
      static_cast<const TimestampRules &>(from));
}


void TimestampRules::MergeFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:validate.TimestampRules)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_const_()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_lt()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_lt());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_lte()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_lte());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_gt()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_gt());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_gte()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_gte());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_within()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_within());
    }
    if (cached_has_bits & 0x00000040u) {
      required_ = from.required_;
    }
    if (cached_has_bits & 0x00000080u) {
      lt_now_ = from.lt_now_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_gt_now(from._internal_gt_now());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimestampRules::CopyFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimestampRules::IsInitialized() const {
  return true;
}

void TimestampRules::InternalSwap(TimestampRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimestampRules, gt_now_)
      + sizeof(TimestampRules::gt_now_)
      - PROTOBUF_FIELD_OFFSET(TimestampRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimestampRules::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_validate_2fvalidate_2eproto_getter, &descriptor_table_validate_2fvalidate_2eproto_once,
      file_level_metadata_validate_2fvalidate_2eproto[22]);
}
PROTOBUF_ATTRIBUTE_INIT_PRIORITY ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  disabled(kDisabledFieldNumber, false);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::OneofOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  required(kRequiredFieldNumber, false);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::validate::FieldRules >, 11, false >
  rules(kRulesFieldNumber, ::validate::FieldRules::default_instance());

// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::validate::FieldRules* Arena::CreateMaybeMessage< ::validate::FieldRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::FieldRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::FloatRules* Arena::CreateMaybeMessage< ::validate::FloatRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::FloatRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::DoubleRules* Arena::CreateMaybeMessage< ::validate::DoubleRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::DoubleRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Int32Rules* Arena::CreateMaybeMessage< ::validate::Int32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Int32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Int64Rules* Arena::CreateMaybeMessage< ::validate::Int64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Int64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::UInt32Rules* Arena::CreateMaybeMessage< ::validate::UInt32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::UInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::UInt64Rules* Arena::CreateMaybeMessage< ::validate::UInt64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::UInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SInt32Rules* Arena::CreateMaybeMessage< ::validate::SInt32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SInt64Rules* Arena::CreateMaybeMessage< ::validate::SInt64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Fixed32Rules* Arena::CreateMaybeMessage< ::validate::Fixed32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Fixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::Fixed64Rules* Arena::CreateMaybeMessage< ::validate::Fixed64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::Fixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SFixed32Rules* Arena::CreateMaybeMessage< ::validate::SFixed32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SFixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::SFixed64Rules* Arena::CreateMaybeMessage< ::validate::SFixed64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::SFixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::BoolRules* Arena::CreateMaybeMessage< ::validate::BoolRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::BoolRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::StringRules* Arena::CreateMaybeMessage< ::validate::StringRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::StringRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::BytesRules* Arena::CreateMaybeMessage< ::validate::BytesRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::BytesRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::EnumRules* Arena::CreateMaybeMessage< ::validate::EnumRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::EnumRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::MessageRules* Arena::CreateMaybeMessage< ::validate::MessageRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::MessageRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::RepeatedRules* Arena::CreateMaybeMessage< ::validate::RepeatedRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::RepeatedRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::MapRules* Arena::CreateMaybeMessage< ::validate::MapRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::MapRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::AnyRules* Arena::CreateMaybeMessage< ::validate::AnyRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::AnyRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::DurationRules* Arena::CreateMaybeMessage< ::validate::DurationRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::DurationRules >(arena);
}
template<> PROTOBUF_NOINLINE ::validate::TimestampRules* Arena::CreateMaybeMessage< ::validate::TimestampRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::validate::TimestampRules >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
