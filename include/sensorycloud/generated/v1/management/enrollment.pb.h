// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/management/enrollment.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2fmanagement_2fenrollment_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_v1_2fmanagement_2fenrollment_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "validate/validate.pb.h"
#include "common/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_v1_2fmanagement_2fenrollment_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2fmanagement_2fenrollment_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v1_2fmanagement_2fenrollment_2eproto;
namespace sensory {
namespace api {
namespace v1 {
namespace management {
class AppendEnrollmentGroupRequest;
struct AppendEnrollmentGroupRequestDefaultTypeInternal;
extern AppendEnrollmentGroupRequestDefaultTypeInternal _AppendEnrollmentGroupRequest_default_instance_;
class CreateEnrollmentGroupRequest;
struct CreateEnrollmentGroupRequestDefaultTypeInternal;
extern CreateEnrollmentGroupRequestDefaultTypeInternal _CreateEnrollmentGroupRequest_default_instance_;
class DeleteEnrollmentGroupRequest;
struct DeleteEnrollmentGroupRequestDefaultTypeInternal;
extern DeleteEnrollmentGroupRequestDefaultTypeInternal _DeleteEnrollmentGroupRequest_default_instance_;
class DeleteEnrollmentRequest;
struct DeleteEnrollmentRequestDefaultTypeInternal;
extern DeleteEnrollmentRequestDefaultTypeInternal _DeleteEnrollmentRequest_default_instance_;
class EnrollmentGroupResponse;
struct EnrollmentGroupResponseDefaultTypeInternal;
extern EnrollmentGroupResponseDefaultTypeInternal _EnrollmentGroupResponse_default_instance_;
class EnrollmentResponse;
struct EnrollmentResponseDefaultTypeInternal;
extern EnrollmentResponseDefaultTypeInternal _EnrollmentResponse_default_instance_;
class GetEnrollmentGroupsResponse;
struct GetEnrollmentGroupsResponseDefaultTypeInternal;
extern GetEnrollmentGroupsResponseDefaultTypeInternal _GetEnrollmentGroupsResponse_default_instance_;
class GetEnrollmentsRequest;
struct GetEnrollmentsRequestDefaultTypeInternal;
extern GetEnrollmentsRequestDefaultTypeInternal _GetEnrollmentsRequest_default_instance_;
class GetEnrollmentsResponse;
struct GetEnrollmentsResponseDefaultTypeInternal;
extern GetEnrollmentsResponseDefaultTypeInternal _GetEnrollmentsResponse_default_instance_;
class RemoveEnrollmentsRequest;
struct RemoveEnrollmentsRequestDefaultTypeInternal;
extern RemoveEnrollmentsRequestDefaultTypeInternal _RemoveEnrollmentsRequest_default_instance_;
class UpdateEnrollmentGroupRequest;
struct UpdateEnrollmentGroupRequestDefaultTypeInternal;
extern UpdateEnrollmentGroupRequestDefaultTypeInternal _UpdateEnrollmentGroupRequest_default_instance_;
class UpdateEnrollmentRequest;
struct UpdateEnrollmentRequestDefaultTypeInternal;
extern UpdateEnrollmentRequestDefaultTypeInternal _UpdateEnrollmentRequest_default_instance_;
}  // namespace management
}  // namespace v1
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::v1::management::AppendEnrollmentGroupRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::AppendEnrollmentGroupRequest>(Arena*);
template<> ::sensory::api::v1::management::CreateEnrollmentGroupRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::CreateEnrollmentGroupRequest>(Arena*);
template<> ::sensory::api::v1::management::DeleteEnrollmentGroupRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::DeleteEnrollmentGroupRequest>(Arena*);
template<> ::sensory::api::v1::management::DeleteEnrollmentRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::DeleteEnrollmentRequest>(Arena*);
template<> ::sensory::api::v1::management::EnrollmentGroupResponse* Arena::CreateMaybeMessage<::sensory::api::v1::management::EnrollmentGroupResponse>(Arena*);
template<> ::sensory::api::v1::management::EnrollmentResponse* Arena::CreateMaybeMessage<::sensory::api::v1::management::EnrollmentResponse>(Arena*);
template<> ::sensory::api::v1::management::GetEnrollmentGroupsResponse* Arena::CreateMaybeMessage<::sensory::api::v1::management::GetEnrollmentGroupsResponse>(Arena*);
template<> ::sensory::api::v1::management::GetEnrollmentsRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::GetEnrollmentsRequest>(Arena*);
template<> ::sensory::api::v1::management::GetEnrollmentsResponse* Arena::CreateMaybeMessage<::sensory::api::v1::management::GetEnrollmentsResponse>(Arena*);
template<> ::sensory::api::v1::management::RemoveEnrollmentsRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::RemoveEnrollmentsRequest>(Arena*);
template<> ::sensory::api::v1::management::UpdateEnrollmentGroupRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::UpdateEnrollmentGroupRequest>(Arena*);
template<> ::sensory::api::v1::management::UpdateEnrollmentRequest* Arena::CreateMaybeMessage<::sensory::api::v1::management::UpdateEnrollmentRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace v1 {
namespace management {

// ===================================================================

class GetEnrollmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.GetEnrollmentsRequest) */ {
 public:
  inline GetEnrollmentsRequest() : GetEnrollmentsRequest(nullptr) {}
  ~GetEnrollmentsRequest() override;
  explicit constexpr GetEnrollmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEnrollmentsRequest(const GetEnrollmentsRequest& from);
  GetEnrollmentsRequest(GetEnrollmentsRequest&& from) noexcept
    : GetEnrollmentsRequest() {
    *this = ::std::move(from);
  }

  inline GetEnrollmentsRequest& operator=(const GetEnrollmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEnrollmentsRequest& operator=(GetEnrollmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEnrollmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEnrollmentsRequest* internal_default_instance() {
    return reinterpret_cast<const GetEnrollmentsRequest*>(
               &_GetEnrollmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetEnrollmentsRequest& a, GetEnrollmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEnrollmentsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEnrollmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEnrollmentsRequest* New() const final {
    return new GetEnrollmentsRequest();
  }

  GetEnrollmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEnrollmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEnrollmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEnrollmentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEnrollmentsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.GetEnrollmentsRequest";
  }
  protected:
  explicit GetEnrollmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string userId = 1 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.GetEnrollmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class GetEnrollmentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.GetEnrollmentsResponse) */ {
 public:
  inline GetEnrollmentsResponse() : GetEnrollmentsResponse(nullptr) {}
  ~GetEnrollmentsResponse() override;
  explicit constexpr GetEnrollmentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEnrollmentsResponse(const GetEnrollmentsResponse& from);
  GetEnrollmentsResponse(GetEnrollmentsResponse&& from) noexcept
    : GetEnrollmentsResponse() {
    *this = ::std::move(from);
  }

  inline GetEnrollmentsResponse& operator=(const GetEnrollmentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEnrollmentsResponse& operator=(GetEnrollmentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEnrollmentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEnrollmentsResponse* internal_default_instance() {
    return reinterpret_cast<const GetEnrollmentsResponse*>(
               &_GetEnrollmentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetEnrollmentsResponse& a, GetEnrollmentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEnrollmentsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEnrollmentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEnrollmentsResponse* New() const final {
    return new GetEnrollmentsResponse();
  }

  GetEnrollmentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEnrollmentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEnrollmentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEnrollmentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEnrollmentsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.GetEnrollmentsResponse";
  }
  protected:
  explicit GetEnrollmentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentsFieldNumber = 1,
    kIsRequestorTrustedFieldNumber = 2,
  };
  // repeated .sensory.api.v1.management.EnrollmentResponse enrollments = 1;
  int enrollments_size() const;
  private:
  int _internal_enrollments_size() const;
  public:
  void clear_enrollments();
  ::sensory::api::v1::management::EnrollmentResponse* mutable_enrollments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >*
      mutable_enrollments();
  private:
  const ::sensory::api::v1::management::EnrollmentResponse& _internal_enrollments(int index) const;
  ::sensory::api::v1::management::EnrollmentResponse* _internal_add_enrollments();
  public:
  const ::sensory::api::v1::management::EnrollmentResponse& enrollments(int index) const;
  ::sensory::api::v1::management::EnrollmentResponse* add_enrollments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >&
      enrollments() const;

  // bool isRequestorTrusted = 2;
  void clear_isrequestortrusted();
  bool isrequestortrusted() const;
  void set_isrequestortrusted(bool value);
  private:
  bool _internal_isrequestortrusted() const;
  void _internal_set_isrequestortrusted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.GetEnrollmentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse > enrollments_;
  bool isrequestortrusted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class EnrollmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.EnrollmentResponse) */ {
 public:
  inline EnrollmentResponse() : EnrollmentResponse(nullptr) {}
  ~EnrollmentResponse() override;
  explicit constexpr EnrollmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnrollmentResponse(const EnrollmentResponse& from);
  EnrollmentResponse(EnrollmentResponse&& from) noexcept
    : EnrollmentResponse() {
    *this = ::std::move(from);
  }

  inline EnrollmentResponse& operator=(const EnrollmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnrollmentResponse& operator=(EnrollmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnrollmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnrollmentResponse* internal_default_instance() {
    return reinterpret_cast<const EnrollmentResponse*>(
               &_EnrollmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EnrollmentResponse& a, EnrollmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnrollmentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnrollmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnrollmentResponse* New() const final {
    return new EnrollmentResponse();
  }

  EnrollmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnrollmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnrollmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnrollmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnrollmentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.EnrollmentResponse";
  }
  protected:
  explicit EnrollmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 4,
    kModelNameFieldNumber = 5,
    kModelVersionFieldNumber = 7,
    kDeviceIdFieldNumber = 8,
    kUserIdFieldNumber = 9,
    kDeviceNameFieldNumber = 11,
    kReferenceIdFieldNumber = 13,
    kCreatedAtFieldNumber = 2,
    kUpdatedAtFieldNumber = 3,
    kCompressionFieldNumber = 10,
    kModelTypeFieldNumber = 6,
    kDidEnrollWithLivenessFieldNumber = 12,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string modelName = 5;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string modelVersion = 7;
  void clear_modelversion();
  const std::string& modelversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelversion();
  void set_allocated_modelversion(std::string* modelversion);
  private:
  const std::string& _internal_modelversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelversion(const std::string& value);
  std::string* _internal_mutable_modelversion();
  public:

  // string deviceId = 8;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_MUST_USE_RESULT std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string userId = 9;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceName = 11;
  void clear_devicename();
  const std::string& devicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicename();
  PROTOBUF_MUST_USE_RESULT std::string* release_devicename();
  void set_allocated_devicename(std::string* devicename);
  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(const std::string& value);
  std::string* _internal_mutable_devicename();
  public:

  // string referenceId = 13;
  void clear_referenceid();
  const std::string& referenceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referenceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referenceid();
  PROTOBUF_MUST_USE_RESULT std::string* release_referenceid();
  void set_allocated_referenceid(std::string* referenceid);
  private:
  const std::string& _internal_referenceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referenceid(const std::string& value);
  std::string* _internal_mutable_referenceid();
  public:

  // .google.protobuf.Timestamp createdAt = 2;
  bool has_createdat() const;
  private:
  bool _internal_has_createdat() const;
  public:
  void clear_createdat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& createdat() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_createdat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_createdat();
  void set_allocated_createdat(::PROTOBUF_NAMESPACE_ID::Timestamp* createdat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_createdat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_createdat();
  public:
  void unsafe_arena_set_allocated_createdat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_createdat();

  // .google.protobuf.Timestamp updatedAt = 3;
  bool has_updatedat() const;
  private:
  bool _internal_has_updatedat() const;
  public:
  void clear_updatedat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updatedat() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updatedat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updatedat();
  void set_allocated_updatedat(::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updatedat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updatedat();
  public:
  void unsafe_arena_set_allocated_updatedat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updatedat();

  // .sensory.api.common.CompressionConfiguration compression = 10;
  bool has_compression() const;
  private:
  bool _internal_has_compression() const;
  public:
  void clear_compression();
  const ::sensory::api::common::CompressionConfiguration& compression() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::CompressionConfiguration* release_compression();
  ::sensory::api::common::CompressionConfiguration* mutable_compression();
  void set_allocated_compression(::sensory::api::common::CompressionConfiguration* compression);
  private:
  const ::sensory::api::common::CompressionConfiguration& _internal_compression() const;
  ::sensory::api::common::CompressionConfiguration* _internal_mutable_compression();
  public:
  void unsafe_arena_set_allocated_compression(
      ::sensory::api::common::CompressionConfiguration* compression);
  ::sensory::api::common::CompressionConfiguration* unsafe_arena_release_compression();

  // .sensory.api.common.ModelType modelType = 6;
  void clear_modeltype();
  ::sensory::api::common::ModelType modeltype() const;
  void set_modeltype(::sensory::api::common::ModelType value);
  private:
  ::sensory::api::common::ModelType _internal_modeltype() const;
  void _internal_set_modeltype(::sensory::api::common::ModelType value);
  public:

  // bool didEnrollWithLiveness = 12;
  void clear_didenrollwithliveness();
  bool didenrollwithliveness() const;
  void set_didenrollwithliveness(bool value);
  private:
  bool _internal_didenrollwithliveness() const;
  void _internal_set_didenrollwithliveness(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.EnrollmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referenceid_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat_;
  ::sensory::api::common::CompressionConfiguration* compression_;
  int modeltype_;
  bool didenrollwithliveness_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class GetEnrollmentGroupsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.GetEnrollmentGroupsResponse) */ {
 public:
  inline GetEnrollmentGroupsResponse() : GetEnrollmentGroupsResponse(nullptr) {}
  ~GetEnrollmentGroupsResponse() override;
  explicit constexpr GetEnrollmentGroupsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEnrollmentGroupsResponse(const GetEnrollmentGroupsResponse& from);
  GetEnrollmentGroupsResponse(GetEnrollmentGroupsResponse&& from) noexcept
    : GetEnrollmentGroupsResponse() {
    *this = ::std::move(from);
  }

  inline GetEnrollmentGroupsResponse& operator=(const GetEnrollmentGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEnrollmentGroupsResponse& operator=(GetEnrollmentGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEnrollmentGroupsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEnrollmentGroupsResponse* internal_default_instance() {
    return reinterpret_cast<const GetEnrollmentGroupsResponse*>(
               &_GetEnrollmentGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetEnrollmentGroupsResponse& a, GetEnrollmentGroupsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEnrollmentGroupsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEnrollmentGroupsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEnrollmentGroupsResponse* New() const final {
    return new GetEnrollmentGroupsResponse();
  }

  GetEnrollmentGroupsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEnrollmentGroupsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEnrollmentGroupsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEnrollmentGroupsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEnrollmentGroupsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.GetEnrollmentGroupsResponse";
  }
  protected:
  explicit GetEnrollmentGroupsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentGroupsFieldNumber = 1,
  };
  // repeated .sensory.api.v1.management.EnrollmentGroupResponse enrollmentGroups = 1;
  int enrollmentgroups_size() const;
  private:
  int _internal_enrollmentgroups_size() const;
  public:
  void clear_enrollmentgroups();
  ::sensory::api::v1::management::EnrollmentGroupResponse* mutable_enrollmentgroups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentGroupResponse >*
      mutable_enrollmentgroups();
  private:
  const ::sensory::api::v1::management::EnrollmentGroupResponse& _internal_enrollmentgroups(int index) const;
  ::sensory::api::v1::management::EnrollmentGroupResponse* _internal_add_enrollmentgroups();
  public:
  const ::sensory::api::v1::management::EnrollmentGroupResponse& enrollmentgroups(int index) const;
  ::sensory::api::v1::management::EnrollmentGroupResponse* add_enrollmentgroups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentGroupResponse >&
      enrollmentgroups() const;

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.GetEnrollmentGroupsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentGroupResponse > enrollmentgroups_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class EnrollmentGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.EnrollmentGroupResponse) */ {
 public:
  inline EnrollmentGroupResponse() : EnrollmentGroupResponse(nullptr) {}
  ~EnrollmentGroupResponse() override;
  explicit constexpr EnrollmentGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnrollmentGroupResponse(const EnrollmentGroupResponse& from);
  EnrollmentGroupResponse(EnrollmentGroupResponse&& from) noexcept
    : EnrollmentGroupResponse() {
    *this = ::std::move(from);
  }

  inline EnrollmentGroupResponse& operator=(const EnrollmentGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnrollmentGroupResponse& operator=(EnrollmentGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnrollmentGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnrollmentGroupResponse* internal_default_instance() {
    return reinterpret_cast<const EnrollmentGroupResponse*>(
               &_EnrollmentGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EnrollmentGroupResponse& a, EnrollmentGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnrollmentGroupResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnrollmentGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnrollmentGroupResponse* New() const final {
    return new EnrollmentGroupResponse();
  }

  EnrollmentGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnrollmentGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnrollmentGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnrollmentGroupResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnrollmentGroupResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.EnrollmentGroupResponse";
  }
  protected:
  explicit EnrollmentGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentsFieldNumber = 10,
    kIdFieldNumber = 1,
    kNameFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kModelNameFieldNumber = 6,
    kModelVersionFieldNumber = 8,
    kUserIdFieldNumber = 9,
    kCreatedAtFieldNumber = 2,
    kUpdatedAtFieldNumber = 3,
    kModelTypeFieldNumber = 7,
  };
  // repeated .sensory.api.v1.management.EnrollmentResponse enrollments = 10;
  int enrollments_size() const;
  private:
  int _internal_enrollments_size() const;
  public:
  void clear_enrollments();
  ::sensory::api::v1::management::EnrollmentResponse* mutable_enrollments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >*
      mutable_enrollments();
  private:
  const ::sensory::api::v1::management::EnrollmentResponse& _internal_enrollments(int index) const;
  ::sensory::api::v1::management::EnrollmentResponse* _internal_add_enrollments();
  public:
  const ::sensory::api::v1::management::EnrollmentResponse& enrollments(int index) const;
  ::sensory::api::v1::management::EnrollmentResponse* add_enrollments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >&
      enrollments() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string modelName = 6;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string modelVersion = 8;
  void clear_modelversion();
  const std::string& modelversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelversion();
  void set_allocated_modelversion(std::string* modelversion);
  private:
  const std::string& _internal_modelversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelversion(const std::string& value);
  std::string* _internal_mutable_modelversion();
  public:

  // string userId = 9;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .google.protobuf.Timestamp createdAt = 2;
  bool has_createdat() const;
  private:
  bool _internal_has_createdat() const;
  public:
  void clear_createdat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& createdat() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_createdat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_createdat();
  void set_allocated_createdat(::PROTOBUF_NAMESPACE_ID::Timestamp* createdat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_createdat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_createdat();
  public:
  void unsafe_arena_set_allocated_createdat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_createdat();

  // .google.protobuf.Timestamp updatedAt = 3;
  bool has_updatedat() const;
  private:
  bool _internal_has_updatedat() const;
  public:
  void clear_updatedat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updatedat() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updatedat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updatedat();
  void set_allocated_updatedat(::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updatedat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updatedat();
  public:
  void unsafe_arena_set_allocated_updatedat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updatedat();

  // .sensory.api.common.ModelType modelType = 7;
  void clear_modeltype();
  ::sensory::api::common::ModelType modeltype() const;
  void set_modeltype(::sensory::api::common::ModelType value);
  private:
  ::sensory::api::common::ModelType _internal_modeltype() const;
  void _internal_set_modeltype(::sensory::api::common::ModelType value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.EnrollmentGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse > enrollments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat_;
  int modeltype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.CreateEnrollmentGroupRequest) */ {
 public:
  inline CreateEnrollmentGroupRequest() : CreateEnrollmentGroupRequest(nullptr) {}
  ~CreateEnrollmentGroupRequest() override;
  explicit constexpr CreateEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentGroupRequest(const CreateEnrollmentGroupRequest& from);
  CreateEnrollmentGroupRequest(CreateEnrollmentGroupRequest&& from) noexcept
    : CreateEnrollmentGroupRequest() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentGroupRequest& operator=(const CreateEnrollmentGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentGroupRequest& operator=(CreateEnrollmentGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateEnrollmentGroupRequest* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentGroupRequest*>(
               &_CreateEnrollmentGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateEnrollmentGroupRequest& a, CreateEnrollmentGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentGroupRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentGroupRequest* New() const final {
    return new CreateEnrollmentGroupRequest();
  }

  CreateEnrollmentGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentGroupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.CreateEnrollmentGroupRequest";
  }
  protected:
  explicit CreateEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdsFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kModelNameFieldNumber = 4,
    kUserIdFieldNumber = 5,
  };
  // repeated string enrollmentIds = 6;
  int enrollmentids_size() const;
  private:
  int _internal_enrollmentids_size() const;
  public:
  void clear_enrollmentids();
  const std::string& enrollmentids(int index) const;
  std::string* mutable_enrollmentids(int index);
  void set_enrollmentids(int index, const std::string& value);
  void set_enrollmentids(int index, std::string&& value);
  void set_enrollmentids(int index, const char* value);
  void set_enrollmentids(int index, const char* value, size_t size);
  std::string* add_enrollmentids();
  void add_enrollmentids(const std::string& value);
  void add_enrollmentids(std::string&& value);
  void add_enrollmentids(const char* value);
  void add_enrollmentids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enrollmentids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enrollmentids();
  private:
  const std::string& _internal_enrollmentids(int index) const;
  std::string* _internal_add_enrollmentids();
  public:

  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [(.validate.rules) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3 [(.validate.rules) = {
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string modelName = 4 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string userId = 5 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.CreateEnrollmentGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enrollmentids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class AppendEnrollmentGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.AppendEnrollmentGroupRequest) */ {
 public:
  inline AppendEnrollmentGroupRequest() : AppendEnrollmentGroupRequest(nullptr) {}
  ~AppendEnrollmentGroupRequest() override;
  explicit constexpr AppendEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEnrollmentGroupRequest(const AppendEnrollmentGroupRequest& from);
  AppendEnrollmentGroupRequest(AppendEnrollmentGroupRequest&& from) noexcept
    : AppendEnrollmentGroupRequest() {
    *this = ::std::move(from);
  }

  inline AppendEnrollmentGroupRequest& operator=(const AppendEnrollmentGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEnrollmentGroupRequest& operator=(AppendEnrollmentGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEnrollmentGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEnrollmentGroupRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEnrollmentGroupRequest*>(
               &_AppendEnrollmentGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AppendEnrollmentGroupRequest& a, AppendEnrollmentGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEnrollmentGroupRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEnrollmentGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEnrollmentGroupRequest* New() const final {
    return new AppendEnrollmentGroupRequest();
  }

  AppendEnrollmentGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEnrollmentGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEnrollmentGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEnrollmentGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEnrollmentGroupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.AppendEnrollmentGroupRequest";
  }
  protected:
  explicit AppendEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdsFieldNumber = 2,
    kGroupIdFieldNumber = 1,
  };
  // repeated string enrollmentIds = 2;
  int enrollmentids_size() const;
  private:
  int _internal_enrollmentids_size() const;
  public:
  void clear_enrollmentids();
  const std::string& enrollmentids(int index) const;
  std::string* mutable_enrollmentids(int index);
  void set_enrollmentids(int index, const std::string& value);
  void set_enrollmentids(int index, std::string&& value);
  void set_enrollmentids(int index, const char* value);
  void set_enrollmentids(int index, const char* value, size_t size);
  std::string* add_enrollmentids();
  void add_enrollmentids(const std::string& value);
  void add_enrollmentids(std::string&& value);
  void add_enrollmentids(const char* value);
  void add_enrollmentids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enrollmentids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enrollmentids();
  private:
  const std::string& _internal_enrollmentids(int index) const;
  std::string* _internal_add_enrollmentids();
  public:

  // string groupId = 1 [(.validate.rules) = {
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_MUST_USE_RESULT std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.AppendEnrollmentGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enrollmentids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class DeleteEnrollmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.DeleteEnrollmentRequest) */ {
 public:
  inline DeleteEnrollmentRequest() : DeleteEnrollmentRequest(nullptr) {}
  ~DeleteEnrollmentRequest() override;
  explicit constexpr DeleteEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteEnrollmentRequest(const DeleteEnrollmentRequest& from);
  DeleteEnrollmentRequest(DeleteEnrollmentRequest&& from) noexcept
    : DeleteEnrollmentRequest() {
    *this = ::std::move(from);
  }

  inline DeleteEnrollmentRequest& operator=(const DeleteEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteEnrollmentRequest& operator=(DeleteEnrollmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteEnrollmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteEnrollmentRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteEnrollmentRequest*>(
               &_DeleteEnrollmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteEnrollmentRequest& a, DeleteEnrollmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteEnrollmentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteEnrollmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteEnrollmentRequest* New() const final {
    return new DeleteEnrollmentRequest();
  }

  DeleteEnrollmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteEnrollmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteEnrollmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteEnrollmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteEnrollmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.DeleteEnrollmentRequest";
  }
  protected:
  explicit DeleteEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.DeleteEnrollmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class DeleteEnrollmentGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.DeleteEnrollmentGroupRequest) */ {
 public:
  inline DeleteEnrollmentGroupRequest() : DeleteEnrollmentGroupRequest(nullptr) {}
  ~DeleteEnrollmentGroupRequest() override;
  explicit constexpr DeleteEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteEnrollmentGroupRequest(const DeleteEnrollmentGroupRequest& from);
  DeleteEnrollmentGroupRequest(DeleteEnrollmentGroupRequest&& from) noexcept
    : DeleteEnrollmentGroupRequest() {
    *this = ::std::move(from);
  }

  inline DeleteEnrollmentGroupRequest& operator=(const DeleteEnrollmentGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteEnrollmentGroupRequest& operator=(DeleteEnrollmentGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteEnrollmentGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteEnrollmentGroupRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteEnrollmentGroupRequest*>(
               &_DeleteEnrollmentGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteEnrollmentGroupRequest& a, DeleteEnrollmentGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteEnrollmentGroupRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteEnrollmentGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteEnrollmentGroupRequest* New() const final {
    return new DeleteEnrollmentGroupRequest();
  }

  DeleteEnrollmentGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteEnrollmentGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteEnrollmentGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteEnrollmentGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteEnrollmentGroupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.DeleteEnrollmentGroupRequest";
  }
  protected:
  explicit DeleteEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.DeleteEnrollmentGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class UpdateEnrollmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.UpdateEnrollmentRequest) */ {
 public:
  inline UpdateEnrollmentRequest() : UpdateEnrollmentRequest(nullptr) {}
  ~UpdateEnrollmentRequest() override;
  explicit constexpr UpdateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEnrollmentRequest(const UpdateEnrollmentRequest& from);
  UpdateEnrollmentRequest(UpdateEnrollmentRequest&& from) noexcept
    : UpdateEnrollmentRequest() {
    *this = ::std::move(from);
  }

  inline UpdateEnrollmentRequest& operator=(const UpdateEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEnrollmentRequest& operator=(UpdateEnrollmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEnrollmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEnrollmentRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateEnrollmentRequest*>(
               &_UpdateEnrollmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateEnrollmentRequest& a, UpdateEnrollmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEnrollmentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEnrollmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateEnrollmentRequest* New() const final {
    return new UpdateEnrollmentRequest();
  }

  UpdateEnrollmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateEnrollmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateEnrollmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateEnrollmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateEnrollmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.UpdateEnrollmentRequest";
  }
  protected:
  explicit UpdateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 2 [(.validate.rules) = {
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.UpdateEnrollmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class UpdateEnrollmentGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.UpdateEnrollmentGroupRequest) */ {
 public:
  inline UpdateEnrollmentGroupRequest() : UpdateEnrollmentGroupRequest(nullptr) {}
  ~UpdateEnrollmentGroupRequest() override;
  explicit constexpr UpdateEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEnrollmentGroupRequest(const UpdateEnrollmentGroupRequest& from);
  UpdateEnrollmentGroupRequest(UpdateEnrollmentGroupRequest&& from) noexcept
    : UpdateEnrollmentGroupRequest() {
    *this = ::std::move(from);
  }

  inline UpdateEnrollmentGroupRequest& operator=(const UpdateEnrollmentGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEnrollmentGroupRequest& operator=(UpdateEnrollmentGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEnrollmentGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEnrollmentGroupRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateEnrollmentGroupRequest*>(
               &_UpdateEnrollmentGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateEnrollmentGroupRequest& a, UpdateEnrollmentGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEnrollmentGroupRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEnrollmentGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateEnrollmentGroupRequest* New() const final {
    return new UpdateEnrollmentGroupRequest();
  }

  UpdateEnrollmentGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateEnrollmentGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateEnrollmentGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateEnrollmentGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateEnrollmentGroupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.UpdateEnrollmentGroupRequest";
  }
  protected:
  explicit UpdateEnrollmentGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [(.validate.rules) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.UpdateEnrollmentGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// -------------------------------------------------------------------

class RemoveEnrollmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.management.RemoveEnrollmentsRequest) */ {
 public:
  inline RemoveEnrollmentsRequest() : RemoveEnrollmentsRequest(nullptr) {}
  ~RemoveEnrollmentsRequest() override;
  explicit constexpr RemoveEnrollmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveEnrollmentsRequest(const RemoveEnrollmentsRequest& from);
  RemoveEnrollmentsRequest(RemoveEnrollmentsRequest&& from) noexcept
    : RemoveEnrollmentsRequest() {
    *this = ::std::move(from);
  }

  inline RemoveEnrollmentsRequest& operator=(const RemoveEnrollmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveEnrollmentsRequest& operator=(RemoveEnrollmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveEnrollmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveEnrollmentsRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveEnrollmentsRequest*>(
               &_RemoveEnrollmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RemoveEnrollmentsRequest& a, RemoveEnrollmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveEnrollmentsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveEnrollmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveEnrollmentsRequest* New() const final {
    return new RemoveEnrollmentsRequest();
  }

  RemoveEnrollmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveEnrollmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveEnrollmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveEnrollmentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveEnrollmentsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.management.RemoveEnrollmentsRequest";
  }
  protected:
  explicit RemoveEnrollmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdsFieldNumber = 2,
    kGroupIdFieldNumber = 1,
  };
  // repeated string enrollmentIds = 2 [(.validate.rules) = {
  int enrollmentids_size() const;
  private:
  int _internal_enrollmentids_size() const;
  public:
  void clear_enrollmentids();
  const std::string& enrollmentids(int index) const;
  std::string* mutable_enrollmentids(int index);
  void set_enrollmentids(int index, const std::string& value);
  void set_enrollmentids(int index, std::string&& value);
  void set_enrollmentids(int index, const char* value);
  void set_enrollmentids(int index, const char* value, size_t size);
  std::string* add_enrollmentids();
  void add_enrollmentids(const std::string& value);
  void add_enrollmentids(std::string&& value);
  void add_enrollmentids(const char* value);
  void add_enrollmentids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enrollmentids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enrollmentids();
  private:
  const std::string& _internal_enrollmentids(int index) const;
  std::string* _internal_add_enrollmentids();
  public:

  // string groupId = 1 [(.validate.rules) = {
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_MUST_USE_RESULT std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.management.RemoveEnrollmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enrollmentids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2fmanagement_2fenrollment_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetEnrollmentsRequest

// string userId = 1 [(.validate.rules) = {
inline void GetEnrollmentsRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& GetEnrollmentsRequest::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.GetEnrollmentsRequest.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEnrollmentsRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.GetEnrollmentsRequest.userId)
}
inline std::string* GetEnrollmentsRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.GetEnrollmentsRequest.userId)
  return _s;
}
inline const std::string& GetEnrollmentsRequest::_internal_userid() const {
  return userid_.Get();
}
inline void GetEnrollmentsRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEnrollmentsRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEnrollmentsRequest::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.GetEnrollmentsRequest.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEnrollmentsRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.GetEnrollmentsRequest.userId)
}

// -------------------------------------------------------------------

// GetEnrollmentsResponse

// repeated .sensory.api.v1.management.EnrollmentResponse enrollments = 1;
inline int GetEnrollmentsResponse::_internal_enrollments_size() const {
  return enrollments_.size();
}
inline int GetEnrollmentsResponse::enrollments_size() const {
  return _internal_enrollments_size();
}
inline void GetEnrollmentsResponse::clear_enrollments() {
  enrollments_.Clear();
}
inline ::sensory::api::v1::management::EnrollmentResponse* GetEnrollmentsResponse::mutable_enrollments(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.GetEnrollmentsResponse.enrollments)
  return enrollments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >*
GetEnrollmentsResponse::mutable_enrollments() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.management.GetEnrollmentsResponse.enrollments)
  return &enrollments_;
}
inline const ::sensory::api::v1::management::EnrollmentResponse& GetEnrollmentsResponse::_internal_enrollments(int index) const {
  return enrollments_.Get(index);
}
inline const ::sensory::api::v1::management::EnrollmentResponse& GetEnrollmentsResponse::enrollments(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.GetEnrollmentsResponse.enrollments)
  return _internal_enrollments(index);
}
inline ::sensory::api::v1::management::EnrollmentResponse* GetEnrollmentsResponse::_internal_add_enrollments() {
  return enrollments_.Add();
}
inline ::sensory::api::v1::management::EnrollmentResponse* GetEnrollmentsResponse::add_enrollments() {
  ::sensory::api::v1::management::EnrollmentResponse* _add = _internal_add_enrollments();
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.GetEnrollmentsResponse.enrollments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >&
GetEnrollmentsResponse::enrollments() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.management.GetEnrollmentsResponse.enrollments)
  return enrollments_;
}

// bool isRequestorTrusted = 2;
inline void GetEnrollmentsResponse::clear_isrequestortrusted() {
  isrequestortrusted_ = false;
}
inline bool GetEnrollmentsResponse::_internal_isrequestortrusted() const {
  return isrequestortrusted_;
}
inline bool GetEnrollmentsResponse::isrequestortrusted() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.GetEnrollmentsResponse.isRequestorTrusted)
  return _internal_isrequestortrusted();
}
inline void GetEnrollmentsResponse::_internal_set_isrequestortrusted(bool value) {
  
  isrequestortrusted_ = value;
}
inline void GetEnrollmentsResponse::set_isrequestortrusted(bool value) {
  _internal_set_isrequestortrusted(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.GetEnrollmentsResponse.isRequestorTrusted)
}

// -------------------------------------------------------------------

// EnrollmentResponse

// string id = 1;
inline void EnrollmentResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.id)
}
inline std::string* EnrollmentResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.id)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_id() const {
  return id_.Get();
}
inline void EnrollmentResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.id)
}

// .google.protobuf.Timestamp createdAt = 2;
inline bool EnrollmentResponse::_internal_has_createdat() const {
  return this != internal_default_instance() && createdat_ != nullptr;
}
inline bool EnrollmentResponse::has_createdat() const {
  return _internal_has_createdat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentResponse::_internal_createdat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = createdat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentResponse::createdat() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.createdAt)
  return _internal_createdat();
}
inline void EnrollmentResponse::unsafe_arena_set_allocated_createdat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat_);
  }
  createdat_ = createdat;
  if (createdat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.management.EnrollmentResponse.createdAt)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::release_createdat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = createdat_;
  createdat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::unsafe_arena_release_createdat() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.createdAt)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = createdat_;
  createdat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::_internal_mutable_createdat() {
  
  if (createdat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    createdat_ = p;
  }
  return createdat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::mutable_createdat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_createdat();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.createdAt)
  return _msg;
}
inline void EnrollmentResponse::set_allocated_createdat(::PROTOBUF_NAMESPACE_ID::Timestamp* createdat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat_);
  }
  if (createdat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat));
    if (message_arena != submessage_arena) {
      createdat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createdat, submessage_arena);
    }
    
  } else {
    
  }
  createdat_ = createdat;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.createdAt)
}

// .google.protobuf.Timestamp updatedAt = 3;
inline bool EnrollmentResponse::_internal_has_updatedat() const {
  return this != internal_default_instance() && updatedat_ != nullptr;
}
inline bool EnrollmentResponse::has_updatedat() const {
  return _internal_has_updatedat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentResponse::_internal_updatedat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updatedat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentResponse::updatedat() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.updatedAt)
  return _internal_updatedat();
}
inline void EnrollmentResponse::unsafe_arena_set_allocated_updatedat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat_);
  }
  updatedat_ = updatedat;
  if (updatedat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.management.EnrollmentResponse.updatedAt)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::release_updatedat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updatedat_;
  updatedat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::unsafe_arena_release_updatedat() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.updatedAt)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updatedat_;
  updatedat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::_internal_mutable_updatedat() {
  
  if (updatedat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updatedat_ = p;
  }
  return updatedat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentResponse::mutable_updatedat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updatedat();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.updatedAt)
  return _msg;
}
inline void EnrollmentResponse::set_allocated_updatedat(::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat_);
  }
  if (updatedat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat));
    if (message_arena != submessage_arena) {
      updatedat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updatedat, submessage_arena);
    }
    
  } else {
    
  }
  updatedat_ = updatedat;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.updatedAt)
}

// string description = 4;
inline void EnrollmentResponse::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.description)
}
inline std::string* EnrollmentResponse::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.description)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_description() const {
  return description_.Get();
}
inline void EnrollmentResponse::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.description)
}

// string modelName = 5;
inline void EnrollmentResponse::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.modelName)
}
inline std::string* EnrollmentResponse::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.modelName)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_modelname() const {
  return modelname_.Get();
}
inline void EnrollmentResponse::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.modelName)
}

// .sensory.api.common.ModelType modelType = 6;
inline void EnrollmentResponse::clear_modeltype() {
  modeltype_ = 0;
}
inline ::sensory::api::common::ModelType EnrollmentResponse::_internal_modeltype() const {
  return static_cast< ::sensory::api::common::ModelType >(modeltype_);
}
inline ::sensory::api::common::ModelType EnrollmentResponse::modeltype() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.modelType)
  return _internal_modeltype();
}
inline void EnrollmentResponse::_internal_set_modeltype(::sensory::api::common::ModelType value) {
  
  modeltype_ = value;
}
inline void EnrollmentResponse::set_modeltype(::sensory::api::common::ModelType value) {
  _internal_set_modeltype(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.modelType)
}

// string modelVersion = 7;
inline void EnrollmentResponse::clear_modelversion() {
  modelversion_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::modelversion() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.modelVersion)
  return _internal_modelversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_modelversion(ArgT0&& arg0, ArgT... args) {
 
 modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.modelVersion)
}
inline std::string* EnrollmentResponse::mutable_modelversion() {
  std::string* _s = _internal_mutable_modelversion();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.modelVersion)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_modelversion() const {
  return modelversion_.Get();
}
inline void EnrollmentResponse::_internal_set_modelversion(const std::string& value) {
  
  modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_modelversion() {
  
  return modelversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_modelversion() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.modelVersion)
  return modelversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_modelversion(std::string* modelversion) {
  if (modelversion != nullptr) {
    
  } else {
    
  }
  modelversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.modelVersion)
}

// string deviceId = 8;
inline void EnrollmentResponse::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::deviceid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.deviceId)
}
inline std::string* EnrollmentResponse::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.deviceId)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void EnrollmentResponse::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_deviceid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.deviceId)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.deviceId)
}

// string userId = 9;
inline void EnrollmentResponse::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.userId)
}
inline std::string* EnrollmentResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.userId)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_userid() const {
  return userid_.Get();
}
inline void EnrollmentResponse::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.userId)
}

// .sensory.api.common.CompressionConfiguration compression = 10;
inline bool EnrollmentResponse::_internal_has_compression() const {
  return this != internal_default_instance() && compression_ != nullptr;
}
inline bool EnrollmentResponse::has_compression() const {
  return _internal_has_compression();
}
inline const ::sensory::api::common::CompressionConfiguration& EnrollmentResponse::_internal_compression() const {
  const ::sensory::api::common::CompressionConfiguration* p = compression_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::CompressionConfiguration&>(
      ::sensory::api::common::_CompressionConfiguration_default_instance_);
}
inline const ::sensory::api::common::CompressionConfiguration& EnrollmentResponse::compression() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.compression)
  return _internal_compression();
}
inline void EnrollmentResponse::unsafe_arena_set_allocated_compression(
    ::sensory::api::common::CompressionConfiguration* compression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression_);
  }
  compression_ = compression;
  if (compression) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.management.EnrollmentResponse.compression)
}
inline ::sensory::api::common::CompressionConfiguration* EnrollmentResponse::release_compression() {
  
  ::sensory::api::common::CompressionConfiguration* temp = compression_;
  compression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::CompressionConfiguration* EnrollmentResponse::unsafe_arena_release_compression() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.compression)
  
  ::sensory::api::common::CompressionConfiguration* temp = compression_;
  compression_ = nullptr;
  return temp;
}
inline ::sensory::api::common::CompressionConfiguration* EnrollmentResponse::_internal_mutable_compression() {
  
  if (compression_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::CompressionConfiguration>(GetArenaForAllocation());
    compression_ = p;
  }
  return compression_;
}
inline ::sensory::api::common::CompressionConfiguration* EnrollmentResponse::mutable_compression() {
  ::sensory::api::common::CompressionConfiguration* _msg = _internal_mutable_compression();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.compression)
  return _msg;
}
inline void EnrollmentResponse::set_allocated_compression(::sensory::api::common::CompressionConfiguration* compression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression_);
  }
  if (compression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compression));
    if (message_arena != submessage_arena) {
      compression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compression, submessage_arena);
    }
    
  } else {
    
  }
  compression_ = compression;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.compression)
}

// string deviceName = 11;
inline void EnrollmentResponse::clear_devicename() {
  devicename_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::devicename() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.deviceName)
  return _internal_devicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_devicename(ArgT0&& arg0, ArgT... args) {
 
 devicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.deviceName)
}
inline std::string* EnrollmentResponse::mutable_devicename() {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.deviceName)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_devicename() const {
  return devicename_.Get();
}
inline void EnrollmentResponse::_internal_set_devicename(const std::string& value) {
  
  devicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_devicename() {
  
  return devicename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_devicename() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.deviceName)
  return devicename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_devicename(std::string* devicename) {
  if (devicename != nullptr) {
    
  } else {
    
  }
  devicename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devicename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.deviceName)
}

// bool didEnrollWithLiveness = 12;
inline void EnrollmentResponse::clear_didenrollwithliveness() {
  didenrollwithliveness_ = false;
}
inline bool EnrollmentResponse::_internal_didenrollwithliveness() const {
  return didenrollwithliveness_;
}
inline bool EnrollmentResponse::didenrollwithliveness() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.didEnrollWithLiveness)
  return _internal_didenrollwithliveness();
}
inline void EnrollmentResponse::_internal_set_didenrollwithliveness(bool value) {
  
  didenrollwithliveness_ = value;
}
inline void EnrollmentResponse::set_didenrollwithliveness(bool value) {
  _internal_set_didenrollwithliveness(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.didEnrollWithLiveness)
}

// string referenceId = 13;
inline void EnrollmentResponse::clear_referenceid() {
  referenceid_.ClearToEmpty();
}
inline const std::string& EnrollmentResponse::referenceid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentResponse.referenceId)
  return _internal_referenceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentResponse::set_referenceid(ArgT0&& arg0, ArgT... args) {
 
 referenceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentResponse.referenceId)
}
inline std::string* EnrollmentResponse::mutable_referenceid() {
  std::string* _s = _internal_mutable_referenceid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentResponse.referenceId)
  return _s;
}
inline const std::string& EnrollmentResponse::_internal_referenceid() const {
  return referenceid_.Get();
}
inline void EnrollmentResponse::_internal_set_referenceid(const std::string& value) {
  
  referenceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::_internal_mutable_referenceid() {
  
  return referenceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentResponse::release_referenceid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentResponse.referenceId)
  return referenceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentResponse::set_allocated_referenceid(std::string* referenceid) {
  if (referenceid != nullptr) {
    
  } else {
    
  }
  referenceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referenceid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentResponse.referenceId)
}

// -------------------------------------------------------------------

// GetEnrollmentGroupsResponse

// repeated .sensory.api.v1.management.EnrollmentGroupResponse enrollmentGroups = 1;
inline int GetEnrollmentGroupsResponse::_internal_enrollmentgroups_size() const {
  return enrollmentgroups_.size();
}
inline int GetEnrollmentGroupsResponse::enrollmentgroups_size() const {
  return _internal_enrollmentgroups_size();
}
inline void GetEnrollmentGroupsResponse::clear_enrollmentgroups() {
  enrollmentgroups_.Clear();
}
inline ::sensory::api::v1::management::EnrollmentGroupResponse* GetEnrollmentGroupsResponse::mutable_enrollmentgroups(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.GetEnrollmentGroupsResponse.enrollmentGroups)
  return enrollmentgroups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentGroupResponse >*
GetEnrollmentGroupsResponse::mutable_enrollmentgroups() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.management.GetEnrollmentGroupsResponse.enrollmentGroups)
  return &enrollmentgroups_;
}
inline const ::sensory::api::v1::management::EnrollmentGroupResponse& GetEnrollmentGroupsResponse::_internal_enrollmentgroups(int index) const {
  return enrollmentgroups_.Get(index);
}
inline const ::sensory::api::v1::management::EnrollmentGroupResponse& GetEnrollmentGroupsResponse::enrollmentgroups(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.GetEnrollmentGroupsResponse.enrollmentGroups)
  return _internal_enrollmentgroups(index);
}
inline ::sensory::api::v1::management::EnrollmentGroupResponse* GetEnrollmentGroupsResponse::_internal_add_enrollmentgroups() {
  return enrollmentgroups_.Add();
}
inline ::sensory::api::v1::management::EnrollmentGroupResponse* GetEnrollmentGroupsResponse::add_enrollmentgroups() {
  ::sensory::api::v1::management::EnrollmentGroupResponse* _add = _internal_add_enrollmentgroups();
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.GetEnrollmentGroupsResponse.enrollmentGroups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentGroupResponse >&
GetEnrollmentGroupsResponse::enrollmentgroups() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.management.GetEnrollmentGroupsResponse.enrollmentGroups)
  return enrollmentgroups_;
}

// -------------------------------------------------------------------

// EnrollmentGroupResponse

// string id = 1;
inline void EnrollmentGroupResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& EnrollmentGroupResponse::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentGroupResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentGroupResponse.id)
}
inline std::string* EnrollmentGroupResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.id)
  return _s;
}
inline const std::string& EnrollmentGroupResponse::_internal_id() const {
  return id_.Get();
}
inline void EnrollmentGroupResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentGroupResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.id)
}

// .google.protobuf.Timestamp createdAt = 2;
inline bool EnrollmentGroupResponse::_internal_has_createdat() const {
  return this != internal_default_instance() && createdat_ != nullptr;
}
inline bool EnrollmentGroupResponse::has_createdat() const {
  return _internal_has_createdat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentGroupResponse::_internal_createdat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = createdat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentGroupResponse::createdat() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.createdAt)
  return _internal_createdat();
}
inline void EnrollmentGroupResponse::unsafe_arena_set_allocated_createdat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* createdat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat_);
  }
  createdat_ = createdat;
  if (createdat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.createdAt)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::release_createdat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = createdat_;
  createdat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::unsafe_arena_release_createdat() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.createdAt)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = createdat_;
  createdat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::_internal_mutable_createdat() {
  
  if (createdat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    createdat_ = p;
  }
  return createdat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::mutable_createdat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_createdat();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.createdAt)
  return _msg;
}
inline void EnrollmentGroupResponse::set_allocated_createdat(::PROTOBUF_NAMESPACE_ID::Timestamp* createdat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat_);
  }
  if (createdat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createdat));
    if (message_arena != submessage_arena) {
      createdat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createdat, submessage_arena);
    }
    
  } else {
    
  }
  createdat_ = createdat;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.createdAt)
}

// .google.protobuf.Timestamp updatedAt = 3;
inline bool EnrollmentGroupResponse::_internal_has_updatedat() const {
  return this != internal_default_instance() && updatedat_ != nullptr;
}
inline bool EnrollmentGroupResponse::has_updatedat() const {
  return _internal_has_updatedat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentGroupResponse::_internal_updatedat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = updatedat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EnrollmentGroupResponse::updatedat() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.updatedAt)
  return _internal_updatedat();
}
inline void EnrollmentGroupResponse::unsafe_arena_set_allocated_updatedat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat_);
  }
  updatedat_ = updatedat;
  if (updatedat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.updatedAt)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::release_updatedat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updatedat_;
  updatedat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::unsafe_arena_release_updatedat() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.updatedAt)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = updatedat_;
  updatedat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::_internal_mutable_updatedat() {
  
  if (updatedat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updatedat_ = p;
  }
  return updatedat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EnrollmentGroupResponse::mutable_updatedat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updatedat();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.updatedAt)
  return _msg;
}
inline void EnrollmentGroupResponse::set_allocated_updatedat(::PROTOBUF_NAMESPACE_ID::Timestamp* updatedat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat_);
  }
  if (updatedat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedat));
    if (message_arena != submessage_arena) {
      updatedat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updatedat, submessage_arena);
    }
    
  } else {
    
  }
  updatedat_ = updatedat;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.updatedAt)
}

// string name = 4;
inline void EnrollmentGroupResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& EnrollmentGroupResponse::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentGroupResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentGroupResponse.name)
}
inline std::string* EnrollmentGroupResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.name)
  return _s;
}
inline const std::string& EnrollmentGroupResponse::_internal_name() const {
  return name_.Get();
}
inline void EnrollmentGroupResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentGroupResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.name)
}

// string description = 5;
inline void EnrollmentGroupResponse::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& EnrollmentGroupResponse::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentGroupResponse::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentGroupResponse.description)
}
inline std::string* EnrollmentGroupResponse::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.description)
  return _s;
}
inline const std::string& EnrollmentGroupResponse::_internal_description() const {
  return description_.Get();
}
inline void EnrollmentGroupResponse::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentGroupResponse::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.description)
}

// string modelName = 6;
inline void EnrollmentGroupResponse::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& EnrollmentGroupResponse::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentGroupResponse::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentGroupResponse.modelName)
}
inline std::string* EnrollmentGroupResponse::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.modelName)
  return _s;
}
inline const std::string& EnrollmentGroupResponse::_internal_modelname() const {
  return modelname_.Get();
}
inline void EnrollmentGroupResponse::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentGroupResponse::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.modelName)
}

// .sensory.api.common.ModelType modelType = 7;
inline void EnrollmentGroupResponse::clear_modeltype() {
  modeltype_ = 0;
}
inline ::sensory::api::common::ModelType EnrollmentGroupResponse::_internal_modeltype() const {
  return static_cast< ::sensory::api::common::ModelType >(modeltype_);
}
inline ::sensory::api::common::ModelType EnrollmentGroupResponse::modeltype() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.modelType)
  return _internal_modeltype();
}
inline void EnrollmentGroupResponse::_internal_set_modeltype(::sensory::api::common::ModelType value) {
  
  modeltype_ = value;
}
inline void EnrollmentGroupResponse::set_modeltype(::sensory::api::common::ModelType value) {
  _internal_set_modeltype(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentGroupResponse.modelType)
}

// string modelVersion = 8;
inline void EnrollmentGroupResponse::clear_modelversion() {
  modelversion_.ClearToEmpty();
}
inline const std::string& EnrollmentGroupResponse::modelversion() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.modelVersion)
  return _internal_modelversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentGroupResponse::set_modelversion(ArgT0&& arg0, ArgT... args) {
 
 modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentGroupResponse.modelVersion)
}
inline std::string* EnrollmentGroupResponse::mutable_modelversion() {
  std::string* _s = _internal_mutable_modelversion();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.modelVersion)
  return _s;
}
inline const std::string& EnrollmentGroupResponse::_internal_modelversion() const {
  return modelversion_.Get();
}
inline void EnrollmentGroupResponse::_internal_set_modelversion(const std::string& value) {
  
  modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::_internal_mutable_modelversion() {
  
  return modelversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::release_modelversion() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.modelVersion)
  return modelversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentGroupResponse::set_allocated_modelversion(std::string* modelversion) {
  if (modelversion != nullptr) {
    
  } else {
    
  }
  modelversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.modelVersion)
}

// string userId = 9;
inline void EnrollmentGroupResponse::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& EnrollmentGroupResponse::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnrollmentGroupResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.EnrollmentGroupResponse.userId)
}
inline std::string* EnrollmentGroupResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.userId)
  return _s;
}
inline const std::string& EnrollmentGroupResponse::_internal_userid() const {
  return userid_.Get();
}
inline void EnrollmentGroupResponse::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnrollmentGroupResponse::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.EnrollmentGroupResponse.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnrollmentGroupResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.EnrollmentGroupResponse.userId)
}

// repeated .sensory.api.v1.management.EnrollmentResponse enrollments = 10;
inline int EnrollmentGroupResponse::_internal_enrollments_size() const {
  return enrollments_.size();
}
inline int EnrollmentGroupResponse::enrollments_size() const {
  return _internal_enrollments_size();
}
inline void EnrollmentGroupResponse::clear_enrollments() {
  enrollments_.Clear();
}
inline ::sensory::api::v1::management::EnrollmentResponse* EnrollmentGroupResponse::mutable_enrollments(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.EnrollmentGroupResponse.enrollments)
  return enrollments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >*
EnrollmentGroupResponse::mutable_enrollments() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.management.EnrollmentGroupResponse.enrollments)
  return &enrollments_;
}
inline const ::sensory::api::v1::management::EnrollmentResponse& EnrollmentGroupResponse::_internal_enrollments(int index) const {
  return enrollments_.Get(index);
}
inline const ::sensory::api::v1::management::EnrollmentResponse& EnrollmentGroupResponse::enrollments(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.EnrollmentGroupResponse.enrollments)
  return _internal_enrollments(index);
}
inline ::sensory::api::v1::management::EnrollmentResponse* EnrollmentGroupResponse::_internal_add_enrollments() {
  return enrollments_.Add();
}
inline ::sensory::api::v1::management::EnrollmentResponse* EnrollmentGroupResponse::add_enrollments() {
  ::sensory::api::v1::management::EnrollmentResponse* _add = _internal_add_enrollments();
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.EnrollmentGroupResponse.enrollments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::management::EnrollmentResponse >&
EnrollmentGroupResponse::enrollments() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.management.EnrollmentGroupResponse.enrollments)
  return enrollments_;
}

// -------------------------------------------------------------------

// CreateEnrollmentGroupRequest

// string id = 1 [(.validate.rules) = {
inline void CreateEnrollmentGroupRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentGroupRequest::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.CreateEnrollmentGroupRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentGroupRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.CreateEnrollmentGroupRequest.id)
}
inline std::string* CreateEnrollmentGroupRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.CreateEnrollmentGroupRequest.id)
  return _s;
}
inline const std::string& CreateEnrollmentGroupRequest::_internal_id() const {
  return id_.Get();
}
inline void CreateEnrollmentGroupRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.CreateEnrollmentGroupRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentGroupRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.CreateEnrollmentGroupRequest.id)
}

// string name = 2 [(.validate.rules) = {
inline void CreateEnrollmentGroupRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentGroupRequest::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.CreateEnrollmentGroupRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentGroupRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.CreateEnrollmentGroupRequest.name)
}
inline std::string* CreateEnrollmentGroupRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.CreateEnrollmentGroupRequest.name)
  return _s;
}
inline const std::string& CreateEnrollmentGroupRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateEnrollmentGroupRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.CreateEnrollmentGroupRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentGroupRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.CreateEnrollmentGroupRequest.name)
}

// string description = 3 [(.validate.rules) = {
inline void CreateEnrollmentGroupRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentGroupRequest::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.CreateEnrollmentGroupRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentGroupRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.CreateEnrollmentGroupRequest.description)
}
inline std::string* CreateEnrollmentGroupRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.CreateEnrollmentGroupRequest.description)
  return _s;
}
inline const std::string& CreateEnrollmentGroupRequest::_internal_description() const {
  return description_.Get();
}
inline void CreateEnrollmentGroupRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.CreateEnrollmentGroupRequest.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentGroupRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.CreateEnrollmentGroupRequest.description)
}

// string modelName = 4 [(.validate.rules) = {
inline void CreateEnrollmentGroupRequest::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentGroupRequest::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.CreateEnrollmentGroupRequest.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentGroupRequest::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.CreateEnrollmentGroupRequest.modelName)
}
inline std::string* CreateEnrollmentGroupRequest::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.CreateEnrollmentGroupRequest.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentGroupRequest::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentGroupRequest::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.CreateEnrollmentGroupRequest.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentGroupRequest::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.CreateEnrollmentGroupRequest.modelName)
}

// string userId = 5 [(.validate.rules) = {
inline void CreateEnrollmentGroupRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentGroupRequest::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.CreateEnrollmentGroupRequest.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentGroupRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.CreateEnrollmentGroupRequest.userId)
}
inline std::string* CreateEnrollmentGroupRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.CreateEnrollmentGroupRequest.userId)
  return _s;
}
inline const std::string& CreateEnrollmentGroupRequest::_internal_userid() const {
  return userid_.Get();
}
inline void CreateEnrollmentGroupRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentGroupRequest::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.CreateEnrollmentGroupRequest.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentGroupRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.CreateEnrollmentGroupRequest.userId)
}

// repeated string enrollmentIds = 6;
inline int CreateEnrollmentGroupRequest::_internal_enrollmentids_size() const {
  return enrollmentids_.size();
}
inline int CreateEnrollmentGroupRequest::enrollmentids_size() const {
  return _internal_enrollmentids_size();
}
inline void CreateEnrollmentGroupRequest::clear_enrollmentids() {
  enrollmentids_.Clear();
}
inline std::string* CreateEnrollmentGroupRequest::add_enrollmentids() {
  std::string* _s = _internal_add_enrollmentids();
  // @@protoc_insertion_point(field_add_mutable:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
  return _s;
}
inline const std::string& CreateEnrollmentGroupRequest::_internal_enrollmentids(int index) const {
  return enrollmentids_.Get(index);
}
inline const std::string& CreateEnrollmentGroupRequest::enrollmentids(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
  return _internal_enrollmentids(index);
}
inline std::string* CreateEnrollmentGroupRequest::mutable_enrollmentids(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
  return enrollmentids_.Mutable(index);
}
inline void CreateEnrollmentGroupRequest::set_enrollmentids(int index, const std::string& value) {
  enrollmentids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline void CreateEnrollmentGroupRequest::set_enrollmentids(int index, std::string&& value) {
  enrollmentids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline void CreateEnrollmentGroupRequest::set_enrollmentids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enrollmentids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline void CreateEnrollmentGroupRequest::set_enrollmentids(int index, const char* value, size_t size) {
  enrollmentids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline std::string* CreateEnrollmentGroupRequest::_internal_add_enrollmentids() {
  return enrollmentids_.Add();
}
inline void CreateEnrollmentGroupRequest::add_enrollmentids(const std::string& value) {
  enrollmentids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline void CreateEnrollmentGroupRequest::add_enrollmentids(std::string&& value) {
  enrollmentids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline void CreateEnrollmentGroupRequest::add_enrollmentids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enrollmentids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline void CreateEnrollmentGroupRequest::add_enrollmentids(const char* value, size_t size) {
  enrollmentids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateEnrollmentGroupRequest::enrollmentids() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
  return enrollmentids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateEnrollmentGroupRequest::mutable_enrollmentids() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.management.CreateEnrollmentGroupRequest.enrollmentIds)
  return &enrollmentids_;
}

// -------------------------------------------------------------------

// AppendEnrollmentGroupRequest

// string groupId = 1 [(.validate.rules) = {
inline void AppendEnrollmentGroupRequest::clear_groupid() {
  groupid_.ClearToEmpty();
}
inline const std::string& AppendEnrollmentGroupRequest::groupid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.AppendEnrollmentGroupRequest.groupId)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppendEnrollmentGroupRequest::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.AppendEnrollmentGroupRequest.groupId)
}
inline std::string* AppendEnrollmentGroupRequest::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.AppendEnrollmentGroupRequest.groupId)
  return _s;
}
inline const std::string& AppendEnrollmentGroupRequest::_internal_groupid() const {
  return groupid_.Get();
}
inline void AppendEnrollmentGroupRequest::_internal_set_groupid(const std::string& value) {
  
  groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppendEnrollmentGroupRequest::_internal_mutable_groupid() {
  
  return groupid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppendEnrollmentGroupRequest::release_groupid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.AppendEnrollmentGroupRequest.groupId)
  return groupid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppendEnrollmentGroupRequest::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  groupid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.AppendEnrollmentGroupRequest.groupId)
}

// repeated string enrollmentIds = 2;
inline int AppendEnrollmentGroupRequest::_internal_enrollmentids_size() const {
  return enrollmentids_.size();
}
inline int AppendEnrollmentGroupRequest::enrollmentids_size() const {
  return _internal_enrollmentids_size();
}
inline void AppendEnrollmentGroupRequest::clear_enrollmentids() {
  enrollmentids_.Clear();
}
inline std::string* AppendEnrollmentGroupRequest::add_enrollmentids() {
  std::string* _s = _internal_add_enrollmentids();
  // @@protoc_insertion_point(field_add_mutable:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
  return _s;
}
inline const std::string& AppendEnrollmentGroupRequest::_internal_enrollmentids(int index) const {
  return enrollmentids_.Get(index);
}
inline const std::string& AppendEnrollmentGroupRequest::enrollmentids(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
  return _internal_enrollmentids(index);
}
inline std::string* AppendEnrollmentGroupRequest::mutable_enrollmentids(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
  return enrollmentids_.Mutable(index);
}
inline void AppendEnrollmentGroupRequest::set_enrollmentids(int index, const std::string& value) {
  enrollmentids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline void AppendEnrollmentGroupRequest::set_enrollmentids(int index, std::string&& value) {
  enrollmentids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline void AppendEnrollmentGroupRequest::set_enrollmentids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enrollmentids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline void AppendEnrollmentGroupRequest::set_enrollmentids(int index, const char* value, size_t size) {
  enrollmentids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline std::string* AppendEnrollmentGroupRequest::_internal_add_enrollmentids() {
  return enrollmentids_.Add();
}
inline void AppendEnrollmentGroupRequest::add_enrollmentids(const std::string& value) {
  enrollmentids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline void AppendEnrollmentGroupRequest::add_enrollmentids(std::string&& value) {
  enrollmentids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline void AppendEnrollmentGroupRequest::add_enrollmentids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enrollmentids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline void AppendEnrollmentGroupRequest::add_enrollmentids(const char* value, size_t size) {
  enrollmentids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppendEnrollmentGroupRequest::enrollmentids() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
  return enrollmentids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppendEnrollmentGroupRequest::mutable_enrollmentids() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.management.AppendEnrollmentGroupRequest.enrollmentIds)
  return &enrollmentids_;
}

// -------------------------------------------------------------------

// DeleteEnrollmentRequest

// string id = 1 [(.validate.rules) = {
inline void DeleteEnrollmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteEnrollmentRequest::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.DeleteEnrollmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteEnrollmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.DeleteEnrollmentRequest.id)
}
inline std::string* DeleteEnrollmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.DeleteEnrollmentRequest.id)
  return _s;
}
inline const std::string& DeleteEnrollmentRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteEnrollmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteEnrollmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteEnrollmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.DeleteEnrollmentRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteEnrollmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.DeleteEnrollmentRequest.id)
}

// -------------------------------------------------------------------

// DeleteEnrollmentGroupRequest

// string id = 1 [(.validate.rules) = {
inline void DeleteEnrollmentGroupRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteEnrollmentGroupRequest::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.DeleteEnrollmentGroupRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteEnrollmentGroupRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.DeleteEnrollmentGroupRequest.id)
}
inline std::string* DeleteEnrollmentGroupRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.DeleteEnrollmentGroupRequest.id)
  return _s;
}
inline const std::string& DeleteEnrollmentGroupRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteEnrollmentGroupRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteEnrollmentGroupRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteEnrollmentGroupRequest::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.DeleteEnrollmentGroupRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteEnrollmentGroupRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.DeleteEnrollmentGroupRequest.id)
}

// -------------------------------------------------------------------

// UpdateEnrollmentRequest

// string id = 1 [(.validate.rules) = {
inline void UpdateEnrollmentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateEnrollmentRequest::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.UpdateEnrollmentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateEnrollmentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.UpdateEnrollmentRequest.id)
}
inline std::string* UpdateEnrollmentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.UpdateEnrollmentRequest.id)
  return _s;
}
inline const std::string& UpdateEnrollmentRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateEnrollmentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentRequest::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.UpdateEnrollmentRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateEnrollmentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.UpdateEnrollmentRequest.id)
}

// string description = 2 [(.validate.rules) = {
inline void UpdateEnrollmentRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& UpdateEnrollmentRequest::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.UpdateEnrollmentRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateEnrollmentRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.UpdateEnrollmentRequest.description)
}
inline std::string* UpdateEnrollmentRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.UpdateEnrollmentRequest.description)
  return _s;
}
inline const std::string& UpdateEnrollmentRequest::_internal_description() const {
  return description_.Get();
}
inline void UpdateEnrollmentRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentRequest::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentRequest::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.UpdateEnrollmentRequest.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateEnrollmentRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.UpdateEnrollmentRequest.description)
}

// -------------------------------------------------------------------

// UpdateEnrollmentGroupRequest

// string id = 1 [(.validate.rules) = {
inline void UpdateEnrollmentGroupRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateEnrollmentGroupRequest::id() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.UpdateEnrollmentGroupRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateEnrollmentGroupRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.UpdateEnrollmentGroupRequest.id)
}
inline std::string* UpdateEnrollmentGroupRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.UpdateEnrollmentGroupRequest.id)
  return _s;
}
inline const std::string& UpdateEnrollmentGroupRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateEnrollmentGroupRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentGroupRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentGroupRequest::release_id() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.UpdateEnrollmentGroupRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateEnrollmentGroupRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.UpdateEnrollmentGroupRequest.id)
}

// string name = 2 [(.validate.rules) = {
inline void UpdateEnrollmentGroupRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdateEnrollmentGroupRequest::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.UpdateEnrollmentGroupRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateEnrollmentGroupRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.UpdateEnrollmentGroupRequest.name)
}
inline std::string* UpdateEnrollmentGroupRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.UpdateEnrollmentGroupRequest.name)
  return _s;
}
inline const std::string& UpdateEnrollmentGroupRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdateEnrollmentGroupRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentGroupRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateEnrollmentGroupRequest::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.UpdateEnrollmentGroupRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateEnrollmentGroupRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.UpdateEnrollmentGroupRequest.name)
}

// -------------------------------------------------------------------

// RemoveEnrollmentsRequest

// string groupId = 1 [(.validate.rules) = {
inline void RemoveEnrollmentsRequest::clear_groupid() {
  groupid_.ClearToEmpty();
}
inline const std::string& RemoveEnrollmentsRequest::groupid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.RemoveEnrollmentsRequest.groupId)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveEnrollmentsRequest::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.RemoveEnrollmentsRequest.groupId)
}
inline std::string* RemoveEnrollmentsRequest::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.RemoveEnrollmentsRequest.groupId)
  return _s;
}
inline const std::string& RemoveEnrollmentsRequest::_internal_groupid() const {
  return groupid_.Get();
}
inline void RemoveEnrollmentsRequest::_internal_set_groupid(const std::string& value) {
  
  groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveEnrollmentsRequest::_internal_mutable_groupid() {
  
  return groupid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveEnrollmentsRequest::release_groupid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.management.RemoveEnrollmentsRequest.groupId)
  return groupid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveEnrollmentsRequest::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  groupid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.management.RemoveEnrollmentsRequest.groupId)
}

// repeated string enrollmentIds = 2 [(.validate.rules) = {
inline int RemoveEnrollmentsRequest::_internal_enrollmentids_size() const {
  return enrollmentids_.size();
}
inline int RemoveEnrollmentsRequest::enrollmentids_size() const {
  return _internal_enrollmentids_size();
}
inline void RemoveEnrollmentsRequest::clear_enrollmentids() {
  enrollmentids_.Clear();
}
inline std::string* RemoveEnrollmentsRequest::add_enrollmentids() {
  std::string* _s = _internal_add_enrollmentids();
  // @@protoc_insertion_point(field_add_mutable:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
  return _s;
}
inline const std::string& RemoveEnrollmentsRequest::_internal_enrollmentids(int index) const {
  return enrollmentids_.Get(index);
}
inline const std::string& RemoveEnrollmentsRequest::enrollmentids(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
  return _internal_enrollmentids(index);
}
inline std::string* RemoveEnrollmentsRequest::mutable_enrollmentids(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
  return enrollmentids_.Mutable(index);
}
inline void RemoveEnrollmentsRequest::set_enrollmentids(int index, const std::string& value) {
  enrollmentids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline void RemoveEnrollmentsRequest::set_enrollmentids(int index, std::string&& value) {
  enrollmentids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline void RemoveEnrollmentsRequest::set_enrollmentids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enrollmentids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline void RemoveEnrollmentsRequest::set_enrollmentids(int index, const char* value, size_t size) {
  enrollmentids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline std::string* RemoveEnrollmentsRequest::_internal_add_enrollmentids() {
  return enrollmentids_.Add();
}
inline void RemoveEnrollmentsRequest::add_enrollmentids(const std::string& value) {
  enrollmentids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline void RemoveEnrollmentsRequest::add_enrollmentids(std::string&& value) {
  enrollmentids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline void RemoveEnrollmentsRequest::add_enrollmentids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enrollmentids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline void RemoveEnrollmentsRequest::add_enrollmentids(const char* value, size_t size) {
  enrollmentids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RemoveEnrollmentsRequest::enrollmentids() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
  return enrollmentids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RemoveEnrollmentsRequest::mutable_enrollmentids() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.management.RemoveEnrollmentsRequest.enrollmentIds)
  return &enrollmentids_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace management
}  // namespace v1
}  // namespace api
}  // namespace sensory

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_v1_2fmanagement_2fenrollment_2eproto
