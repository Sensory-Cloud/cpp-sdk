// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/file/file.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2ffile_2ffile_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_v1_2ffile_2ffile_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_v1_2ffile_2ffile_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2ffile_2ffile_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v1_2ffile_2ffile_2eproto;
namespace sensory {
namespace api {
namespace v1 {
namespace file {
class FileCatalog;
struct FileCatalogDefaultTypeInternal;
extern FileCatalogDefaultTypeInternal _FileCatalog_default_instance_;
class FileCatalogRequest;
struct FileCatalogRequestDefaultTypeInternal;
extern FileCatalogRequestDefaultTypeInternal _FileCatalogRequest_default_instance_;
class FileCatalogResponse;
struct FileCatalogResponseDefaultTypeInternal;
extern FileCatalogResponseDefaultTypeInternal _FileCatalogResponse_default_instance_;
class FileChunk;
struct FileChunkDefaultTypeInternal;
extern FileChunkDefaultTypeInternal _FileChunk_default_instance_;
class FileCompleteCatalogRequest;
struct FileCompleteCatalogRequestDefaultTypeInternal;
extern FileCompleteCatalogRequestDefaultTypeInternal _FileCompleteCatalogRequest_default_instance_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FileRequest;
struct FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
class FileResponse;
struct FileResponseDefaultTypeInternal;
extern FileResponseDefaultTypeInternal _FileResponse_default_instance_;
class VersionedFileCategory;
struct VersionedFileCategoryDefaultTypeInternal;
extern VersionedFileCategoryDefaultTypeInternal _VersionedFileCategory_default_instance_;
}  // namespace file
}  // namespace v1
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::v1::file::FileCatalog* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileCatalog>(Arena*);
template<> ::sensory::api::v1::file::FileCatalogRequest* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileCatalogRequest>(Arena*);
template<> ::sensory::api::v1::file::FileCatalogResponse* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileCatalogResponse>(Arena*);
template<> ::sensory::api::v1::file::FileChunk* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileChunk>(Arena*);
template<> ::sensory::api::v1::file::FileCompleteCatalogRequest* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileCompleteCatalogRequest>(Arena*);
template<> ::sensory::api::v1::file::FileInfo* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileInfo>(Arena*);
template<> ::sensory::api::v1::file::FileRequest* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileRequest>(Arena*);
template<> ::sensory::api::v1::file::FileResponse* Arena::CreateMaybeMessage<::sensory::api::v1::file::FileResponse>(Arena*);
template<> ::sensory::api::v1::file::VersionedFileCategory* Arena::CreateMaybeMessage<::sensory::api::v1::file::VersionedFileCategory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace v1 {
namespace file {

enum FileCategory : int {
  TSSV_MODEL = 0,
  FENRIR_MODEL = 1,
  TNL_MODEL = 2,
  UNKNOWN = 100,
  FileCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FileCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FileCategory_IsValid(int value);
constexpr FileCategory FileCategory_MIN = TSSV_MODEL;
constexpr FileCategory FileCategory_MAX = UNKNOWN;
constexpr int FileCategory_ARRAYSIZE = FileCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileCategory_descriptor();
template<typename T>
inline const std::string& FileCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileCategory_descriptor(), enum_t_value);
}
inline bool FileCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileCategory>(
    FileCategory_descriptor(), name, value);
}
// ===================================================================

class FileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileRequest) */ {
 public:
  inline FileRequest() : FileRequest(nullptr) {}
  ~FileRequest() override;
  explicit constexpr FileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRequest(const FileRequest& from);
  FileRequest(FileRequest&& from) noexcept
    : FileRequest() {
    *this = ::std::move(from);
  }

  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRequest& operator=(FileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRequest* internal_default_instance() {
    return reinterpret_cast<const FileRequest*>(
               &_FileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FileRequest& a, FileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileRequest* New() const final {
    return new FileRequest();
  }

  FileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileRequest";
  }
  protected:
  explicit FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 1,
    kCategoryFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // string file = 1 [(.validate.rules) = {
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_MUST_USE_RESULT std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // .sensory.api.v1.file.VersionedFileCategory category = 2;
  bool has_category() const;
  private:
  bool _internal_has_category() const;
  public:
  void clear_category();
  const ::sensory::api::v1::file::VersionedFileCategory& category() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::file::VersionedFileCategory* release_category();
  ::sensory::api::v1::file::VersionedFileCategory* mutable_category();
  void set_allocated_category(::sensory::api::v1::file::VersionedFileCategory* category);
  private:
  const ::sensory::api::v1::file::VersionedFileCategory& _internal_category() const;
  ::sensory::api::v1::file::VersionedFileCategory* _internal_mutable_category();
  public:
  void unsafe_arena_set_allocated_category(
      ::sensory::api::v1::file::VersionedFileCategory* category);
  ::sensory::api::v1::file::VersionedFileCategory* unsafe_arena_release_category();

  // int64 offset = 3;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  ::sensory::api::v1::file::VersionedFileCategory* category_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class FileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileResponse) */ {
 public:
  inline FileResponse() : FileResponse(nullptr) {}
  ~FileResponse() override;
  explicit constexpr FileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileResponse(const FileResponse& from);
  FileResponse(FileResponse&& from) noexcept
    : FileResponse() {
    *this = ::std::move(from);
  }

  inline FileResponse& operator=(const FileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileResponse& operator=(FileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingResponseCase {
    kInfo = 1,
    kChunk = 2,
    STREAMINGRESPONSE_NOT_SET = 0,
  };

  static inline const FileResponse* internal_default_instance() {
    return reinterpret_cast<const FileResponse*>(
               &_FileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FileResponse& a, FileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FileResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileResponse* New() const final {
    return new FileResponse();
  }

  FileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileResponse";
  }
  protected:
  explicit FileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompleteFieldNumber = 3,
    kInfoFieldNumber = 1,
    kChunkFieldNumber = 2,
  };
  // bool complete = 3;
  void clear_complete();
  bool complete() const;
  void set_complete(bool value);
  private:
  bool _internal_complete() const;
  void _internal_set_complete(bool value);
  public:

  // .sensory.api.v1.file.FileInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::sensory::api::v1::file::FileInfo& info() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::file::FileInfo* release_info();
  ::sensory::api::v1::file::FileInfo* mutable_info();
  void set_allocated_info(::sensory::api::v1::file::FileInfo* info);
  private:
  const ::sensory::api::v1::file::FileInfo& _internal_info() const;
  ::sensory::api::v1::file::FileInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::sensory::api::v1::file::FileInfo* info);
  ::sensory::api::v1::file::FileInfo* unsafe_arena_release_info();

  // .sensory.api.v1.file.FileChunk chunk = 2;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::sensory::api::v1::file::FileChunk& chunk() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::file::FileChunk* release_chunk();
  ::sensory::api::v1::file::FileChunk* mutable_chunk();
  void set_allocated_chunk(::sensory::api::v1::file::FileChunk* chunk);
  private:
  const ::sensory::api::v1::file::FileChunk& _internal_chunk() const;
  ::sensory::api::v1::file::FileChunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::sensory::api::v1::file::FileChunk* chunk);
  ::sensory::api::v1::file::FileChunk* unsafe_arena_release_chunk();

  void clear_streamingResponse();
  StreamingResponseCase streamingResponse_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileResponse)
 private:
  class _Internal;
  void set_has_info();
  void set_has_chunk();

  inline bool has_streamingResponse() const;
  inline void clear_has_streamingResponse();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool complete_;
  union StreamingResponseUnion {
    constexpr StreamingResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::file::FileInfo* info_;
    ::sensory::api::v1::file::FileChunk* chunk_;
  } streamingResponse_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class FileCatalogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileCatalogRequest) */ {
 public:
  inline FileCatalogRequest() : FileCatalogRequest(nullptr) {}
  ~FileCatalogRequest() override;
  explicit constexpr FileCatalogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileCatalogRequest(const FileCatalogRequest& from);
  FileCatalogRequest(FileCatalogRequest&& from) noexcept
    : FileCatalogRequest() {
    *this = ::std::move(from);
  }

  inline FileCatalogRequest& operator=(const FileCatalogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileCatalogRequest& operator=(FileCatalogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileCatalogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileCatalogRequest* internal_default_instance() {
    return reinterpret_cast<const FileCatalogRequest*>(
               &_FileCatalogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileCatalogRequest& a, FileCatalogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileCatalogRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileCatalogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileCatalogRequest* New() const final {
    return new FileCatalogRequest();
  }

  FileCatalogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileCatalogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileCatalogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileCatalogRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCatalogRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileCatalogRequest";
  }
  protected:
  explicit FileCatalogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 1,
  };
  // repeated .sensory.api.v1.file.VersionedFileCategory categories = 1 [(.validate.rules) = {
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  ::sensory::api::v1::file::VersionedFileCategory* mutable_categories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::VersionedFileCategory >*
      mutable_categories();
  private:
  const ::sensory::api::v1::file::VersionedFileCategory& _internal_categories(int index) const;
  ::sensory::api::v1::file::VersionedFileCategory* _internal_add_categories();
  public:
  const ::sensory::api::v1::file::VersionedFileCategory& categories(int index) const;
  ::sensory::api::v1::file::VersionedFileCategory* add_categories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::VersionedFileCategory >&
      categories() const;

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileCatalogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::VersionedFileCategory > categories_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class FileCompleteCatalogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileCompleteCatalogRequest) */ {
 public:
  inline FileCompleteCatalogRequest() : FileCompleteCatalogRequest(nullptr) {}
  ~FileCompleteCatalogRequest() override;
  explicit constexpr FileCompleteCatalogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileCompleteCatalogRequest(const FileCompleteCatalogRequest& from);
  FileCompleteCatalogRequest(FileCompleteCatalogRequest&& from) noexcept
    : FileCompleteCatalogRequest() {
    *this = ::std::move(from);
  }

  inline FileCompleteCatalogRequest& operator=(const FileCompleteCatalogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileCompleteCatalogRequest& operator=(FileCompleteCatalogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileCompleteCatalogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileCompleteCatalogRequest* internal_default_instance() {
    return reinterpret_cast<const FileCompleteCatalogRequest*>(
               &_FileCompleteCatalogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileCompleteCatalogRequest& a, FileCompleteCatalogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileCompleteCatalogRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileCompleteCatalogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileCompleteCatalogRequest* New() const final {
    return new FileCompleteCatalogRequest();
  }

  FileCompleteCatalogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileCompleteCatalogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileCompleteCatalogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileCompleteCatalogRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCompleteCatalogRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileCompleteCatalogRequest";
  }
  protected:
  explicit FileCompleteCatalogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileCompleteCatalogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class FileCatalogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileCatalogResponse) */ {
 public:
  inline FileCatalogResponse() : FileCatalogResponse(nullptr) {}
  ~FileCatalogResponse() override;
  explicit constexpr FileCatalogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileCatalogResponse(const FileCatalogResponse& from);
  FileCatalogResponse(FileCatalogResponse&& from) noexcept
    : FileCatalogResponse() {
    *this = ::std::move(from);
  }

  inline FileCatalogResponse& operator=(const FileCatalogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileCatalogResponse& operator=(FileCatalogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileCatalogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileCatalogResponse* internal_default_instance() {
    return reinterpret_cast<const FileCatalogResponse*>(
               &_FileCatalogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileCatalogResponse& a, FileCatalogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FileCatalogResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileCatalogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileCatalogResponse* New() const final {
    return new FileCatalogResponse();
  }

  FileCatalogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileCatalogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileCatalogResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileCatalogResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCatalogResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileCatalogResponse";
  }
  protected:
  explicit FileCatalogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogFieldNumber = 1,
  };
  // repeated .sensory.api.v1.file.FileCatalog catalog = 1;
  int catalog_size() const;
  private:
  int _internal_catalog_size() const;
  public:
  void clear_catalog();
  ::sensory::api::v1::file::FileCatalog* mutable_catalog(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileCatalog >*
      mutable_catalog();
  private:
  const ::sensory::api::v1::file::FileCatalog& _internal_catalog(int index) const;
  ::sensory::api::v1::file::FileCatalog* _internal_add_catalog();
  public:
  const ::sensory::api::v1::file::FileCatalog& catalog(int index) const;
  ::sensory::api::v1::file::FileCatalog* add_catalog();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileCatalog >&
      catalog() const;

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileCatalogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileCatalog > catalog_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class FileChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileChunk) */ {
 public:
  inline FileChunk() : FileChunk(nullptr) {}
  ~FileChunk() override;
  explicit constexpr FileChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileChunk(const FileChunk& from);
  FileChunk(FileChunk&& from) noexcept
    : FileChunk() {
    *this = ::std::move(from);
  }

  inline FileChunk& operator=(const FileChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileChunk& operator=(FileChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileChunk* internal_default_instance() {
    return reinterpret_cast<const FileChunk*>(
               &_FileChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FileChunk& a, FileChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(FileChunk* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileChunk* New() const final {
    return new FileChunk();
  }

  FileChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileChunk";
  }
  protected:
  explicit FileChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // bytes bytes = 1;
  void clear_bytes();
  const std::string& bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytes();
  PROTOBUF_MUST_USE_RESULT std::string* release_bytes();
  void set_allocated_bytes(std::string* bytes);
  private:
  const std::string& _internal_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes(const std::string& value);
  std::string* _internal_mutable_bytes();
  public:

  // int64 offset = 2;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class FileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() override;
  explicit constexpr FileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const final {
    return new FileInfo();
  }

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileInfo";
  }
  protected:
  explicit FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 1,
    kAbsolutePathFieldNumber = 2,
    kContentTypeFieldNumber = 4,
    kHashFieldNumber = 5,
    kSizeFieldNumber = 3,
  };
  // string file = 1;
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_MUST_USE_RESULT std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // string absolutePath = 2;
  void clear_absolutepath();
  const std::string& absolutepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_absolutepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_absolutepath();
  PROTOBUF_MUST_USE_RESULT std::string* release_absolutepath();
  void set_allocated_absolutepath(std::string* absolutepath);
  private:
  const std::string& _internal_absolutepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_absolutepath(const std::string& value);
  std::string* _internal_mutable_absolutepath();
  public:

  // string contentType = 4;
  void clear_contenttype();
  const std::string& contenttype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contenttype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contenttype();
  PROTOBUF_MUST_USE_RESULT std::string* release_contenttype();
  void set_allocated_contenttype(std::string* contenttype);
  private:
  const std::string& _internal_contenttype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contenttype(const std::string& value);
  std::string* _internal_mutable_contenttype();
  public:

  // string hash = 5;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // int64 size = 3;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr absolutepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contenttype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class FileCatalog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.FileCatalog) */ {
 public:
  inline FileCatalog() : FileCatalog(nullptr) {}
  ~FileCatalog() override;
  explicit constexpr FileCatalog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileCatalog(const FileCatalog& from);
  FileCatalog(FileCatalog&& from) noexcept
    : FileCatalog() {
    *this = ::std::move(from);
  }

  inline FileCatalog& operator=(const FileCatalog& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileCatalog& operator=(FileCatalog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileCatalog& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileCatalog* internal_default_instance() {
    return reinterpret_cast<const FileCatalog*>(
               &_FileCatalog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FileCatalog& a, FileCatalog& b) {
    a.Swap(&b);
  }
  inline void Swap(FileCatalog* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileCatalog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileCatalog* New() const final {
    return new FileCatalog();
  }

  FileCatalog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileCatalog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileCatalog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileCatalog& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCatalog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.FileCatalog";
  }
  protected:
  explicit FileCatalog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
    kCategoryFieldNumber = 2,
  };
  // repeated .sensory.api.v1.file.FileInfo files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::sensory::api::v1::file::FileInfo* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileInfo >*
      mutable_files();
  private:
  const ::sensory::api::v1::file::FileInfo& _internal_files(int index) const;
  ::sensory::api::v1::file::FileInfo* _internal_add_files();
  public:
  const ::sensory::api::v1::file::FileInfo& files(int index) const;
  ::sensory::api::v1::file::FileInfo* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileInfo >&
      files() const;

  // .sensory.api.v1.file.VersionedFileCategory category = 2;
  bool has_category() const;
  private:
  bool _internal_has_category() const;
  public:
  void clear_category();
  const ::sensory::api::v1::file::VersionedFileCategory& category() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::file::VersionedFileCategory* release_category();
  ::sensory::api::v1::file::VersionedFileCategory* mutable_category();
  void set_allocated_category(::sensory::api::v1::file::VersionedFileCategory* category);
  private:
  const ::sensory::api::v1::file::VersionedFileCategory& _internal_category() const;
  ::sensory::api::v1::file::VersionedFileCategory* _internal_mutable_category();
  public:
  void unsafe_arena_set_allocated_category(
      ::sensory::api::v1::file::VersionedFileCategory* category);
  ::sensory::api::v1::file::VersionedFileCategory* unsafe_arena_release_category();

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.FileCatalog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileInfo > files_;
  ::sensory::api::v1::file::VersionedFileCategory* category_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// -------------------------------------------------------------------

class VersionedFileCategory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.file.VersionedFileCategory) */ {
 public:
  inline VersionedFileCategory() : VersionedFileCategory(nullptr) {}
  ~VersionedFileCategory() override;
  explicit constexpr VersionedFileCategory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionedFileCategory(const VersionedFileCategory& from);
  VersionedFileCategory(VersionedFileCategory&& from) noexcept
    : VersionedFileCategory() {
    *this = ::std::move(from);
  }

  inline VersionedFileCategory& operator=(const VersionedFileCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionedFileCategory& operator=(VersionedFileCategory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionedFileCategory& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionedFileCategory* internal_default_instance() {
    return reinterpret_cast<const VersionedFileCategory*>(
               &_VersionedFileCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VersionedFileCategory& a, VersionedFileCategory& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionedFileCategory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionedFileCategory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionedFileCategory* New() const final {
    return new VersionedFileCategory();
  }

  VersionedFileCategory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionedFileCategory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionedFileCategory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VersionedFileCategory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionedFileCategory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.file.VersionedFileCategory";
  }
  protected:
  explicit VersionedFileCategory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kCategoryFieldNumber = 1,
  };
  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .sensory.api.v1.file.FileCategory category = 1 [(.validate.rules) = {
  void clear_category();
  ::sensory::api::v1::file::FileCategory category() const;
  void set_category(::sensory::api::v1::file::FileCategory value);
  private:
  ::sensory::api::v1::file::FileCategory _internal_category() const;
  void _internal_set_category(::sensory::api::v1::file::FileCategory value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.file.VersionedFileCategory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  int category_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2ffile_2ffile_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FileRequest

// string file = 1 [(.validate.rules) = {
inline void FileRequest::clear_file() {
  file_.ClearToEmpty();
}
inline const std::string& FileRequest::file() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileRequest.file)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileRequest::set_file(ArgT0&& arg0, ArgT... args) {
 
 file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileRequest.file)
}
inline std::string* FileRequest::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileRequest.file)
  return _s;
}
inline const std::string& FileRequest::_internal_file() const {
  return file_.Get();
}
inline void FileRequest::_internal_set_file(const std::string& value) {
  
  file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileRequest::_internal_mutable_file() {
  
  return file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileRequest::release_file() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileRequest.file)
  return file_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileRequest::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    
  } else {
    
  }
  file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileRequest.file)
}

// .sensory.api.v1.file.VersionedFileCategory category = 2;
inline bool FileRequest::_internal_has_category() const {
  return this != internal_default_instance() && category_ != nullptr;
}
inline bool FileRequest::has_category() const {
  return _internal_has_category();
}
inline void FileRequest::clear_category() {
  if (GetArenaForAllocation() == nullptr && category_ != nullptr) {
    delete category_;
  }
  category_ = nullptr;
}
inline const ::sensory::api::v1::file::VersionedFileCategory& FileRequest::_internal_category() const {
  const ::sensory::api::v1::file::VersionedFileCategory* p = category_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::file::VersionedFileCategory&>(
      ::sensory::api::v1::file::_VersionedFileCategory_default_instance_);
}
inline const ::sensory::api::v1::file::VersionedFileCategory& FileRequest::category() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileRequest.category)
  return _internal_category();
}
inline void FileRequest::unsafe_arena_set_allocated_category(
    ::sensory::api::v1::file::VersionedFileCategory* category) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(category_);
  }
  category_ = category;
  if (category) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.file.FileRequest.category)
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileRequest::release_category() {
  
  ::sensory::api::v1::file::VersionedFileCategory* temp = category_;
  category_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileRequest::unsafe_arena_release_category() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileRequest.category)
  
  ::sensory::api::v1::file::VersionedFileCategory* temp = category_;
  category_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileRequest::_internal_mutable_category() {
  
  if (category_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::file::VersionedFileCategory>(GetArenaForAllocation());
    category_ = p;
  }
  return category_;
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileRequest::mutable_category() {
  ::sensory::api::v1::file::VersionedFileCategory* _msg = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileRequest.category)
  return _msg;
}
inline void FileRequest::set_allocated_category(::sensory::api::v1::file::VersionedFileCategory* category) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete category_;
  }
  if (category) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::file::VersionedFileCategory>::GetOwningArena(category);
    if (message_arena != submessage_arena) {
      category = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, category, submessage_arena);
    }
    
  } else {
    
  }
  category_ = category;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileRequest.category)
}

// int64 offset = 3;
inline void FileRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileRequest::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileRequest::offset() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileRequest.offset)
  return _internal_offset();
}
inline void FileRequest::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void FileRequest::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileRequest.offset)
}

// -------------------------------------------------------------------

// FileResponse

// .sensory.api.v1.file.FileInfo info = 1;
inline bool FileResponse::_internal_has_info() const {
  return streamingResponse_case() == kInfo;
}
inline bool FileResponse::has_info() const {
  return _internal_has_info();
}
inline void FileResponse::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void FileResponse::clear_info() {
  if (_internal_has_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingResponse_.info_;
    }
    clear_has_streamingResponse();
  }
}
inline ::sensory::api::v1::file::FileInfo* FileResponse::release_info() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileResponse.info)
  if (_internal_has_info()) {
    clear_has_streamingResponse();
      ::sensory::api::v1::file::FileInfo* temp = streamingResponse_.info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingResponse_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::file::FileInfo& FileResponse::_internal_info() const {
  return _internal_has_info()
      ? *streamingResponse_.info_
      : reinterpret_cast< ::sensory::api::v1::file::FileInfo&>(::sensory::api::v1::file::_FileInfo_default_instance_);
}
inline const ::sensory::api::v1::file::FileInfo& FileResponse::info() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileResponse.info)
  return _internal_info();
}
inline ::sensory::api::v1::file::FileInfo* FileResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.file.FileResponse.info)
  if (_internal_has_info()) {
    clear_has_streamingResponse();
    ::sensory::api::v1::file::FileInfo* temp = streamingResponse_.info_;
    streamingResponse_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileResponse::unsafe_arena_set_allocated_info(::sensory::api::v1::file::FileInfo* info) {
  clear_streamingResponse();
  if (info) {
    set_has_info();
    streamingResponse_.info_ = info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.file.FileResponse.info)
}
inline ::sensory::api::v1::file::FileInfo* FileResponse::_internal_mutable_info() {
  if (!_internal_has_info()) {
    clear_streamingResponse();
    set_has_info();
    streamingResponse_.info_ = CreateMaybeMessage< ::sensory::api::v1::file::FileInfo >(GetArenaForAllocation());
  }
  return streamingResponse_.info_;
}
inline ::sensory::api::v1::file::FileInfo* FileResponse::mutable_info() {
  ::sensory::api::v1::file::FileInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileResponse.info)
  return _msg;
}

// .sensory.api.v1.file.FileChunk chunk = 2;
inline bool FileResponse::_internal_has_chunk() const {
  return streamingResponse_case() == kChunk;
}
inline bool FileResponse::has_chunk() const {
  return _internal_has_chunk();
}
inline void FileResponse::set_has_chunk() {
  _oneof_case_[0] = kChunk;
}
inline void FileResponse::clear_chunk() {
  if (_internal_has_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingResponse_.chunk_;
    }
    clear_has_streamingResponse();
  }
}
inline ::sensory::api::v1::file::FileChunk* FileResponse::release_chunk() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileResponse.chunk)
  if (_internal_has_chunk()) {
    clear_has_streamingResponse();
      ::sensory::api::v1::file::FileChunk* temp = streamingResponse_.chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingResponse_.chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::file::FileChunk& FileResponse::_internal_chunk() const {
  return _internal_has_chunk()
      ? *streamingResponse_.chunk_
      : reinterpret_cast< ::sensory::api::v1::file::FileChunk&>(::sensory::api::v1::file::_FileChunk_default_instance_);
}
inline const ::sensory::api::v1::file::FileChunk& FileResponse::chunk() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileResponse.chunk)
  return _internal_chunk();
}
inline ::sensory::api::v1::file::FileChunk* FileResponse::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.file.FileResponse.chunk)
  if (_internal_has_chunk()) {
    clear_has_streamingResponse();
    ::sensory::api::v1::file::FileChunk* temp = streamingResponse_.chunk_;
    streamingResponse_.chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FileResponse::unsafe_arena_set_allocated_chunk(::sensory::api::v1::file::FileChunk* chunk) {
  clear_streamingResponse();
  if (chunk) {
    set_has_chunk();
    streamingResponse_.chunk_ = chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.file.FileResponse.chunk)
}
inline ::sensory::api::v1::file::FileChunk* FileResponse::_internal_mutable_chunk() {
  if (!_internal_has_chunk()) {
    clear_streamingResponse();
    set_has_chunk();
    streamingResponse_.chunk_ = CreateMaybeMessage< ::sensory::api::v1::file::FileChunk >(GetArenaForAllocation());
  }
  return streamingResponse_.chunk_;
}
inline ::sensory::api::v1::file::FileChunk* FileResponse::mutable_chunk() {
  ::sensory::api::v1::file::FileChunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileResponse.chunk)
  return _msg;
}

// bool complete = 3;
inline void FileResponse::clear_complete() {
  complete_ = false;
}
inline bool FileResponse::_internal_complete() const {
  return complete_;
}
inline bool FileResponse::complete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileResponse.complete)
  return _internal_complete();
}
inline void FileResponse::_internal_set_complete(bool value) {
  
  complete_ = value;
}
inline void FileResponse::set_complete(bool value) {
  _internal_set_complete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileResponse.complete)
}

inline bool FileResponse::has_streamingResponse() const {
  return streamingResponse_case() != STREAMINGRESPONSE_NOT_SET;
}
inline void FileResponse::clear_has_streamingResponse() {
  _oneof_case_[0] = STREAMINGRESPONSE_NOT_SET;
}
inline FileResponse::StreamingResponseCase FileResponse::streamingResponse_case() const {
  return FileResponse::StreamingResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileCatalogRequest

// repeated .sensory.api.v1.file.VersionedFileCategory categories = 1 [(.validate.rules) = {
inline int FileCatalogRequest::_internal_categories_size() const {
  return categories_.size();
}
inline int FileCatalogRequest::categories_size() const {
  return _internal_categories_size();
}
inline void FileCatalogRequest::clear_categories() {
  categories_.Clear();
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileCatalogRequest::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileCatalogRequest.categories)
  return categories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::VersionedFileCategory >*
FileCatalogRequest::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.file.FileCatalogRequest.categories)
  return &categories_;
}
inline const ::sensory::api::v1::file::VersionedFileCategory& FileCatalogRequest::_internal_categories(int index) const {
  return categories_.Get(index);
}
inline const ::sensory::api::v1::file::VersionedFileCategory& FileCatalogRequest::categories(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileCatalogRequest.categories)
  return _internal_categories(index);
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileCatalogRequest::_internal_add_categories() {
  return categories_.Add();
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileCatalogRequest::add_categories() {
  ::sensory::api::v1::file::VersionedFileCategory* _add = _internal_add_categories();
  // @@protoc_insertion_point(field_add:sensory.api.v1.file.FileCatalogRequest.categories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::VersionedFileCategory >&
FileCatalogRequest::categories() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.file.FileCatalogRequest.categories)
  return categories_;
}

// -------------------------------------------------------------------

// FileCompleteCatalogRequest

// -------------------------------------------------------------------

// FileCatalogResponse

// repeated .sensory.api.v1.file.FileCatalog catalog = 1;
inline int FileCatalogResponse::_internal_catalog_size() const {
  return catalog_.size();
}
inline int FileCatalogResponse::catalog_size() const {
  return _internal_catalog_size();
}
inline void FileCatalogResponse::clear_catalog() {
  catalog_.Clear();
}
inline ::sensory::api::v1::file::FileCatalog* FileCatalogResponse::mutable_catalog(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileCatalogResponse.catalog)
  return catalog_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileCatalog >*
FileCatalogResponse::mutable_catalog() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.file.FileCatalogResponse.catalog)
  return &catalog_;
}
inline const ::sensory::api::v1::file::FileCatalog& FileCatalogResponse::_internal_catalog(int index) const {
  return catalog_.Get(index);
}
inline const ::sensory::api::v1::file::FileCatalog& FileCatalogResponse::catalog(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileCatalogResponse.catalog)
  return _internal_catalog(index);
}
inline ::sensory::api::v1::file::FileCatalog* FileCatalogResponse::_internal_add_catalog() {
  return catalog_.Add();
}
inline ::sensory::api::v1::file::FileCatalog* FileCatalogResponse::add_catalog() {
  ::sensory::api::v1::file::FileCatalog* _add = _internal_add_catalog();
  // @@protoc_insertion_point(field_add:sensory.api.v1.file.FileCatalogResponse.catalog)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileCatalog >&
FileCatalogResponse::catalog() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.file.FileCatalogResponse.catalog)
  return catalog_;
}

// -------------------------------------------------------------------

// FileChunk

// bytes bytes = 1;
inline void FileChunk::clear_bytes() {
  bytes_.ClearToEmpty();
}
inline const std::string& FileChunk::bytes() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileChunk.bytes)
  return _internal_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileChunk::set_bytes(ArgT0&& arg0, ArgT... args) {
 
 bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileChunk.bytes)
}
inline std::string* FileChunk::mutable_bytes() {
  std::string* _s = _internal_mutable_bytes();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileChunk.bytes)
  return _s;
}
inline const std::string& FileChunk::_internal_bytes() const {
  return bytes_.Get();
}
inline void FileChunk::_internal_set_bytes(const std::string& value) {
  
  bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileChunk::_internal_mutable_bytes() {
  
  return bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileChunk::release_bytes() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileChunk.bytes)
  return bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileChunk::set_allocated_bytes(std::string* bytes) {
  if (bytes != nullptr) {
    
  } else {
    
  }
  bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bytes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileChunk.bytes)
}

// int64 offset = 2;
inline void FileChunk::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileChunk::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileChunk::offset() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileChunk.offset)
  return _internal_offset();
}
inline void FileChunk::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void FileChunk::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileChunk.offset)
}

// -------------------------------------------------------------------

// FileInfo

// string file = 1;
inline void FileInfo::clear_file() {
  file_.ClearToEmpty();
}
inline const std::string& FileInfo::file() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileInfo.file)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_file(ArgT0&& arg0, ArgT... args) {
 
 file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileInfo.file)
}
inline std::string* FileInfo::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileInfo.file)
  return _s;
}
inline const std::string& FileInfo::_internal_file() const {
  return file_.Get();
}
inline void FileInfo::_internal_set_file(const std::string& value) {
  
  file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_file() {
  
  return file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_file() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileInfo.file)
  return file_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileInfo::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    
  } else {
    
  }
  file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileInfo.file)
}

// string absolutePath = 2;
inline void FileInfo::clear_absolutepath() {
  absolutepath_.ClearToEmpty();
}
inline const std::string& FileInfo::absolutepath() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileInfo.absolutePath)
  return _internal_absolutepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_absolutepath(ArgT0&& arg0, ArgT... args) {
 
 absolutepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileInfo.absolutePath)
}
inline std::string* FileInfo::mutable_absolutepath() {
  std::string* _s = _internal_mutable_absolutepath();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileInfo.absolutePath)
  return _s;
}
inline const std::string& FileInfo::_internal_absolutepath() const {
  return absolutepath_.Get();
}
inline void FileInfo::_internal_set_absolutepath(const std::string& value) {
  
  absolutepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_absolutepath() {
  
  return absolutepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_absolutepath() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileInfo.absolutePath)
  return absolutepath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileInfo::set_allocated_absolutepath(std::string* absolutepath) {
  if (absolutepath != nullptr) {
    
  } else {
    
  }
  absolutepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), absolutepath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileInfo.absolutePath)
}

// int64 size = 3;
inline void FileInfo::clear_size() {
  size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileInfo::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileInfo::size() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileInfo.size)
  return _internal_size();
}
inline void FileInfo::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  size_ = value;
}
inline void FileInfo::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileInfo.size)
}

// string contentType = 4;
inline void FileInfo::clear_contenttype() {
  contenttype_.ClearToEmpty();
}
inline const std::string& FileInfo::contenttype() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileInfo.contentType)
  return _internal_contenttype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_contenttype(ArgT0&& arg0, ArgT... args) {
 
 contenttype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileInfo.contentType)
}
inline std::string* FileInfo::mutable_contenttype() {
  std::string* _s = _internal_mutable_contenttype();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileInfo.contentType)
  return _s;
}
inline const std::string& FileInfo::_internal_contenttype() const {
  return contenttype_.Get();
}
inline void FileInfo::_internal_set_contenttype(const std::string& value) {
  
  contenttype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_contenttype() {
  
  return contenttype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_contenttype() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileInfo.contentType)
  return contenttype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileInfo::set_allocated_contenttype(std::string* contenttype) {
  if (contenttype != nullptr) {
    
  } else {
    
  }
  contenttype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contenttype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileInfo.contentType)
}

// string hash = 5;
inline void FileInfo::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& FileInfo::hash() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileInfo.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.FileInfo.hash)
}
inline std::string* FileInfo::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileInfo.hash)
  return _s;
}
inline const std::string& FileInfo::_internal_hash() const {
  return hash_.Get();
}
inline void FileInfo::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_hash() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileInfo.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileInfo::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileInfo.hash)
}

// -------------------------------------------------------------------

// FileCatalog

// repeated .sensory.api.v1.file.FileInfo files = 1;
inline int FileCatalog::_internal_files_size() const {
  return files_.size();
}
inline int FileCatalog::files_size() const {
  return _internal_files_size();
}
inline void FileCatalog::clear_files() {
  files_.Clear();
}
inline ::sensory::api::v1::file::FileInfo* FileCatalog::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileCatalog.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileInfo >*
FileCatalog::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.file.FileCatalog.files)
  return &files_;
}
inline const ::sensory::api::v1::file::FileInfo& FileCatalog::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::sensory::api::v1::file::FileInfo& FileCatalog::files(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileCatalog.files)
  return _internal_files(index);
}
inline ::sensory::api::v1::file::FileInfo* FileCatalog::_internal_add_files() {
  return files_.Add();
}
inline ::sensory::api::v1::file::FileInfo* FileCatalog::add_files() {
  ::sensory::api::v1::file::FileInfo* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:sensory.api.v1.file.FileCatalog.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::file::FileInfo >&
FileCatalog::files() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.file.FileCatalog.files)
  return files_;
}

// .sensory.api.v1.file.VersionedFileCategory category = 2;
inline bool FileCatalog::_internal_has_category() const {
  return this != internal_default_instance() && category_ != nullptr;
}
inline bool FileCatalog::has_category() const {
  return _internal_has_category();
}
inline void FileCatalog::clear_category() {
  if (GetArenaForAllocation() == nullptr && category_ != nullptr) {
    delete category_;
  }
  category_ = nullptr;
}
inline const ::sensory::api::v1::file::VersionedFileCategory& FileCatalog::_internal_category() const {
  const ::sensory::api::v1::file::VersionedFileCategory* p = category_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::file::VersionedFileCategory&>(
      ::sensory::api::v1::file::_VersionedFileCategory_default_instance_);
}
inline const ::sensory::api::v1::file::VersionedFileCategory& FileCatalog::category() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.FileCatalog.category)
  return _internal_category();
}
inline void FileCatalog::unsafe_arena_set_allocated_category(
    ::sensory::api::v1::file::VersionedFileCategory* category) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(category_);
  }
  category_ = category;
  if (category) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.file.FileCatalog.category)
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileCatalog::release_category() {
  
  ::sensory::api::v1::file::VersionedFileCategory* temp = category_;
  category_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileCatalog::unsafe_arena_release_category() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.FileCatalog.category)
  
  ::sensory::api::v1::file::VersionedFileCategory* temp = category_;
  category_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileCatalog::_internal_mutable_category() {
  
  if (category_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::file::VersionedFileCategory>(GetArenaForAllocation());
    category_ = p;
  }
  return category_;
}
inline ::sensory::api::v1::file::VersionedFileCategory* FileCatalog::mutable_category() {
  ::sensory::api::v1::file::VersionedFileCategory* _msg = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.FileCatalog.category)
  return _msg;
}
inline void FileCatalog::set_allocated_category(::sensory::api::v1::file::VersionedFileCategory* category) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete category_;
  }
  if (category) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::file::VersionedFileCategory>::GetOwningArena(category);
    if (message_arena != submessage_arena) {
      category = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, category, submessage_arena);
    }
    
  } else {
    
  }
  category_ = category;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileCatalog.category)
}

// -------------------------------------------------------------------

// VersionedFileCategory

// .sensory.api.v1.file.FileCategory category = 1 [(.validate.rules) = {
inline void VersionedFileCategory::clear_category() {
  category_ = 0;
}
inline ::sensory::api::v1::file::FileCategory VersionedFileCategory::_internal_category() const {
  return static_cast< ::sensory::api::v1::file::FileCategory >(category_);
}
inline ::sensory::api::v1::file::FileCategory VersionedFileCategory::category() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.VersionedFileCategory.category)
  return _internal_category();
}
inline void VersionedFileCategory::_internal_set_category(::sensory::api::v1::file::FileCategory value) {
  
  category_ = value;
}
inline void VersionedFileCategory::set_category(::sensory::api::v1::file::FileCategory value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.VersionedFileCategory.category)
}

// string version = 2;
inline void VersionedFileCategory::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& VersionedFileCategory::version() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.file.VersionedFileCategory.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionedFileCategory::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.file.VersionedFileCategory.version)
}
inline std::string* VersionedFileCategory::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.file.VersionedFileCategory.version)
  return _s;
}
inline const std::string& VersionedFileCategory::_internal_version() const {
  return version_.Get();
}
inline void VersionedFileCategory::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VersionedFileCategory::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VersionedFileCategory::release_version() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.file.VersionedFileCategory.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VersionedFileCategory::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.VersionedFileCategory.version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace file
}  // namespace v1
}  // namespace api
}  // namespace sensory

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensory::api::v1::file::FileCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::file::FileCategory>() {
  return ::sensory::api::v1::file::FileCategory_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_v1_2ffile_2ffile_2eproto
