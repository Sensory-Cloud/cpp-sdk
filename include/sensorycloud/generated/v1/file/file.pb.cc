// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/file/file.proto

#include "v1/file/file.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace sensory {
namespace api {
namespace v1 {
namespace file {
constexpr FileRequest::FileRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : file_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , category_(nullptr)
  , offset_(int64_t{0}){}
struct FileRequestDefaultTypeInternal {
  constexpr FileRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileRequestDefaultTypeInternal() {}
  union {
    FileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileRequestDefaultTypeInternal _FileRequest_default_instance_;
constexpr FileResponse::FileResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : complete_(false)
  , _oneof_case_{}{}
struct FileResponseDefaultTypeInternal {
  constexpr FileResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileResponseDefaultTypeInternal() {}
  union {
    FileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileResponseDefaultTypeInternal _FileResponse_default_instance_;
constexpr FileCatalogRequest::FileCatalogRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : categories_(){}
struct FileCatalogRequestDefaultTypeInternal {
  constexpr FileCatalogRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileCatalogRequestDefaultTypeInternal() {}
  union {
    FileCatalogRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileCatalogRequestDefaultTypeInternal _FileCatalogRequest_default_instance_;
constexpr FileCompleteCatalogRequest::FileCompleteCatalogRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tenantid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct FileCompleteCatalogRequestDefaultTypeInternal {
  constexpr FileCompleteCatalogRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileCompleteCatalogRequestDefaultTypeInternal() {}
  union {
    FileCompleteCatalogRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileCompleteCatalogRequestDefaultTypeInternal _FileCompleteCatalogRequest_default_instance_;
constexpr FileCatalogResponse::FileCatalogResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : catalog_(){}
struct FileCatalogResponseDefaultTypeInternal {
  constexpr FileCatalogResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileCatalogResponseDefaultTypeInternal() {}
  union {
    FileCatalogResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileCatalogResponseDefaultTypeInternal _FileCatalogResponse_default_instance_;
constexpr FileChunk::FileChunk(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bytes_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , offset_(int64_t{0}){}
struct FileChunkDefaultTypeInternal {
  constexpr FileChunkDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileChunkDefaultTypeInternal() {}
  union {
    FileChunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileChunkDefaultTypeInternal _FileChunk_default_instance_;
constexpr FileInfo::FileInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : file_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , absolutepath_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , contenttype_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , tenantid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , size_(int64_t{0}){}
struct FileInfoDefaultTypeInternal {
  constexpr FileInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileInfoDefaultTypeInternal() {}
  union {
    FileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileInfoDefaultTypeInternal _FileInfo_default_instance_;
constexpr FileCatalog::FileCatalog(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : files_()
  , category_(nullptr){}
struct FileCatalogDefaultTypeInternal {
  constexpr FileCatalogDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FileCatalogDefaultTypeInternal() {}
  union {
    FileCatalog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FileCatalogDefaultTypeInternal _FileCatalog_default_instance_;
constexpr VersionedFileCategory::VersionedFileCategory(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , category_(0)
{}
struct VersionedFileCategoryDefaultTypeInternal {
  constexpr VersionedFileCategoryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VersionedFileCategoryDefaultTypeInternal() {}
  union {
    VersionedFileCategory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VersionedFileCategoryDefaultTypeInternal _VersionedFileCategory_default_instance_;
}  // namespace file
}  // namespace v1
}  // namespace api
}  // namespace sensory
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_v1_2ffile_2ffile_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_v1_2ffile_2ffile_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_v1_2ffile_2ffile_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_v1_2ffile_2ffile_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileRequest, file_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileRequest, category_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileRequest, offset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileResponse, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileResponse, complete_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileResponse, streamingResponse_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCatalogRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCatalogRequest, categories_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCompleteCatalogRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCompleteCatalogRequest, tenantid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCatalogResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCatalogResponse, catalog_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileChunk, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileChunk, bytes_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileChunk, offset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileInfo, file_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileInfo, absolutepath_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileInfo, size_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileInfo, contenttype_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileInfo, hash_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileInfo, tenantid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCatalog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCatalog, files_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::FileCatalog, category_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::VersionedFileCategory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::VersionedFileCategory, category_),
  PROTOBUF_FIELD_OFFSET(::sensory::api::v1::file::VersionedFileCategory, version_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::sensory::api::v1::file::FileRequest)},
  { 9, -1, -1, sizeof(::sensory::api::v1::file::FileResponse)},
  { 19, -1, -1, sizeof(::sensory::api::v1::file::FileCatalogRequest)},
  { 26, -1, -1, sizeof(::sensory::api::v1::file::FileCompleteCatalogRequest)},
  { 33, -1, -1, sizeof(::sensory::api::v1::file::FileCatalogResponse)},
  { 40, -1, -1, sizeof(::sensory::api::v1::file::FileChunk)},
  { 48, -1, -1, sizeof(::sensory::api::v1::file::FileInfo)},
  { 60, -1, -1, sizeof(::sensory::api::v1::file::FileCatalog)},
  { 68, -1, -1, sizeof(::sensory::api::v1::file::VersionedFileCategory)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileCatalogRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileCompleteCatalogRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileCatalogResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileChunk_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_FileCatalog_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sensory::api::v1::file::_VersionedFileCategory_default_instance_),
};

const char descriptor_table_protodef_v1_2ffile_2ffile_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022v1/file/file.proto\022\023sensory.api.v1.fil"
  "e\032\027validate/validate.proto\"u\n\013FileReques"
  "t\022\030\n\004file\030\001 \001(\tB\n\372B\007r\005\020\001\030\377\017\022<\n\010category\030"
  "\002 \001(\0132*.sensory.api.v1.file.VersionedFil"
  "eCategory\022\016\n\006offset\030\003 \001(\003\"\225\001\n\014FileRespon"
  "se\022-\n\004info\030\001 \001(\0132\035.sensory.api.v1.file.F"
  "ileInfoH\000\022/\n\005chunk\030\002 \001(\0132\036.sensory.api.v"
  "1.file.FileChunkH\000\022\020\n\010complete\030\003 \001(\010B\023\n\021"
  "streamingResponse\"^\n\022FileCatalogRequest\022"
  "H\n\ncategories\030\001 \003(\0132*.sensory.api.v1.fil"
  "e.VersionedFileCategoryB\010\372B\005\222\001\002\010\001\".\n\032Fil"
  "eCompleteCatalogRequest\022\020\n\010tenantId\030\001 \001("
  "\t\"H\n\023FileCatalogResponse\0221\n\007catalog\030\001 \003("
  "\0132 .sensory.api.v1.file.FileCatalog\"*\n\tF"
  "ileChunk\022\r\n\005bytes\030\001 \001(\014\022\016\n\006offset\030\002 \001(\003\""
  "q\n\010FileInfo\022\014\n\004file\030\001 \001(\t\022\024\n\014absolutePat"
  "h\030\002 \001(\t\022\014\n\004size\030\003 \001(\003\022\023\n\013contentType\030\004 \001"
  "(\t\022\014\n\004hash\030\005 \001(\t\022\020\n\010tenantId\030\006 \001(\t\"y\n\013Fi"
  "leCatalog\022,\n\005files\030\001 \003(\0132\035.sensory.api.v"
  "1.file.FileInfo\022<\n\010category\030\002 \001(\0132*.sens"
  "ory.api.v1.file.VersionedFileCategory\"g\n"
  "\025VersionedFileCategory\022=\n\010category\030\001 \001(\016"
  "2!.sensory.api.v1.file.FileCategoryB\010\372B\005"
  "\202\001\002\020\001\022\017\n\007version\030\002 \001(\t*L\n\014FileCategory\022\016"
  "\n\nTSSV_MODEL\020\000\022\020\n\014FENRIR_MODEL\020\001\022\r\n\tTNL_"
  "MODEL\020\002\022\013\n\007UNKNOWN\020d2\377\002\n\004File\022L\n\007GetInfo"
  "\022 .sensory.api.v1.file.FileRequest\032\035.sen"
  "sory.api.v1.file.FileInfo\"\000\022a\n\nGetCatalo"
  "g\022\'.sensory.api.v1.file.FileCatalogReque"
  "st\032(.sensory.api.v1.file.FileCatalogResp"
  "onse\"\000\022q\n\022GetCompleteCatalog\022/.sensory.a"
  "pi.v1.file.FileCompleteCatalogRequest\032(."
  "sensory.api.v1.file.FileCatalogResponse\""
  "\000\022S\n\010Download\022 .sensory.api.v1.file.File"
  "Request\032!.sensory.api.v1.file.FileRespon"
  "se\"\0000\001Bq\n\033ai.sensorycloud.api.v1.fileB\025S"
  "ensoryApiV1FileProtoP\001Z9gitlab.com/senso"
  "ry-cloud/server/titan.git/pkg/api/v1/fil"
  "eb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_v1_2ffile_2ffile_2eproto_deps[1] = {
  &::descriptor_table_validate_2fvalidate_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_v1_2ffile_2ffile_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v1_2ffile_2ffile_2eproto = {
  false, false, 1529, descriptor_table_protodef_v1_2ffile_2ffile_2eproto, "v1/file/file.proto", 
  &descriptor_table_v1_2ffile_2ffile_2eproto_once, descriptor_table_v1_2ffile_2ffile_2eproto_deps, 1, 9,
  schemas, file_default_instances, TableStruct_v1_2ffile_2ffile_2eproto::offsets,
  file_level_metadata_v1_2ffile_2ffile_2eproto, file_level_enum_descriptors_v1_2ffile_2ffile_2eproto, file_level_service_descriptors_v1_2ffile_2ffile_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_v1_2ffile_2ffile_2eproto_getter() {
  return &descriptor_table_v1_2ffile_2ffile_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_v1_2ffile_2ffile_2eproto(&descriptor_table_v1_2ffile_2ffile_2eproto);
namespace sensory {
namespace api {
namespace v1 {
namespace file {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileCategory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_v1_2ffile_2ffile_2eproto);
  return file_level_enum_descriptors_v1_2ffile_2ffile_2eproto[0];
}
bool FileCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 100:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FileRequest::_Internal {
 public:
  static const ::sensory::api::v1::file::VersionedFileCategory& category(const FileRequest* msg);
};

const ::sensory::api::v1::file::VersionedFileCategory&
FileRequest::_Internal::category(const FileRequest* msg) {
  return *msg->category_;
}
FileRequest::FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileRequest)
}
FileRequest::FileRequest(const FileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_file().empty()) {
    file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_category()) {
    category_ = new ::sensory::api::v1::file::VersionedFileCategory(*from.category_);
  } else {
    category_ = nullptr;
  }
  offset_ = from.offset_;
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileRequest)
}

void FileRequest::SharedCtor() {
file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&category_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&category_)) + sizeof(offset_));
}

FileRequest::~FileRequest() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  file_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete category_;
}

void FileRequest::ArenaDtor(void* object) {
  FileRequest* _this = reinterpret_cast< FileRequest* >(object);
  (void)_this;
}
void FileRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  file_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && category_ != nullptr) {
    delete category_;
  }
  category_ = nullptr;
  offset_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string file = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_file();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.FileRequest.file"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .sensory.api.v1.file.VersionedFileCategory category = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_category(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string file = 1 [(.validate.rules) = {
  if (!this->_internal_file().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file().data(), static_cast<int>(this->_internal_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.FileRequest.file");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_file(), target);
  }

  // .sensory.api.v1.file.VersionedFileCategory category = 2;
  if (this->_internal_has_category()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::category(this), target, stream);
  }

  // int64 offset = 3;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileRequest)
  return target;
}

size_t FileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string file = 1 [(.validate.rules) = {
  if (!this->_internal_file().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file());
  }

  // .sensory.api.v1.file.VersionedFileCategory category = 2;
  if (this->_internal_has_category()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *category_);
  }

  // int64 offset = 3;
  if (this->_internal_offset() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileRequest::GetClassData() const { return &_class_data_; }

void FileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileRequest *>(to)->MergeFrom(
      static_cast<const FileRequest &>(from));
}


void FileRequest::MergeFrom(const FileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_file().empty()) {
    _internal_set_file(from._internal_file());
  }
  if (from._internal_has_category()) {
    _internal_mutable_category()->::sensory::api::v1::file::VersionedFileCategory::MergeFrom(from._internal_category());
  }
  if (from._internal_offset() != 0) {
    _internal_set_offset(from._internal_offset());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileRequest::CopyFrom(const FileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileRequest::IsInitialized() const {
  return true;
}

void FileRequest::InternalSwap(FileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_, lhs_arena,
      &other->file_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FileRequest, offset_)
      + sizeof(FileRequest::offset_)
      - PROTOBUF_FIELD_OFFSET(FileRequest, category_)>(
          reinterpret_cast<char*>(&category_),
          reinterpret_cast<char*>(&other->category_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FileRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[0]);
}

// ===================================================================

class FileResponse::_Internal {
 public:
  static const ::sensory::api::v1::file::FileInfo& info(const FileResponse* msg);
  static const ::sensory::api::v1::file::FileChunk& chunk(const FileResponse* msg);
};

const ::sensory::api::v1::file::FileInfo&
FileResponse::_Internal::info(const FileResponse* msg) {
  return *msg->streamingResponse_.info_;
}
const ::sensory::api::v1::file::FileChunk&
FileResponse::_Internal::chunk(const FileResponse* msg) {
  return *msg->streamingResponse_.chunk_;
}
void FileResponse::set_allocated_info(::sensory::api::v1::file::FileInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_streamingResponse();
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::file::FileInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
    streamingResponse_.info_ = info;
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileResponse.info)
}
void FileResponse::set_allocated_chunk(::sensory::api::v1::file::FileChunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_streamingResponse();
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::file::FileChunk>::GetOwningArena(chunk);
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    set_has_chunk();
    streamingResponse_.chunk_ = chunk;
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.file.FileResponse.chunk)
}
FileResponse::FileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileResponse)
}
FileResponse::FileResponse(const FileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  complete_ = from.complete_;
  clear_has_streamingResponse();
  switch (from.streamingResponse_case()) {
    case kInfo: {
      _internal_mutable_info()->::sensory::api::v1::file::FileInfo::MergeFrom(from._internal_info());
      break;
    }
    case kChunk: {
      _internal_mutable_chunk()->::sensory::api::v1::file::FileChunk::MergeFrom(from._internal_chunk());
      break;
    }
    case STREAMINGRESPONSE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileResponse)
}

void FileResponse::SharedCtor() {
complete_ = false;
clear_has_streamingResponse();
}

FileResponse::~FileResponse() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_streamingResponse()) {
    clear_streamingResponse();
  }
}

void FileResponse::ArenaDtor(void* object) {
  FileResponse* _this = reinterpret_cast< FileResponse* >(object);
  (void)_this;
}
void FileResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileResponse::clear_streamingResponse() {
// @@protoc_insertion_point(one_of_clear_start:sensory.api.v1.file.FileResponse)
  switch (streamingResponse_case()) {
    case kInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete streamingResponse_.info_;
      }
      break;
    }
    case kChunk: {
      if (GetArenaForAllocation() == nullptr) {
        delete streamingResponse_.chunk_;
      }
      break;
    }
    case STREAMINGRESPONSE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = STREAMINGRESPONSE_NOT_SET;
}


void FileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  complete_ = false;
  clear_streamingResponse();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .sensory.api.v1.file.FileInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .sensory.api.v1.file.FileChunk chunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_chunk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool complete = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          complete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensory.api.v1.file.FileInfo info = 1;
  if (_internal_has_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::info(this), target, stream);
  }

  // .sensory.api.v1.file.FileChunk chunk = 2;
  if (_internal_has_chunk()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::chunk(this), target, stream);
  }

  // bool complete = 3;
  if (this->_internal_complete() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_complete(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileResponse)
  return target;
}

size_t FileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool complete = 3;
  if (this->_internal_complete() != 0) {
    total_size += 1 + 1;
  }

  switch (streamingResponse_case()) {
    // .sensory.api.v1.file.FileInfo info = 1;
    case kInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *streamingResponse_.info_);
      break;
    }
    // .sensory.api.v1.file.FileChunk chunk = 2;
    case kChunk: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *streamingResponse_.chunk_);
      break;
    }
    case STREAMINGRESPONSE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileResponse::GetClassData() const { return &_class_data_; }

void FileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileResponse *>(to)->MergeFrom(
      static_cast<const FileResponse &>(from));
}


void FileResponse::MergeFrom(const FileResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_complete() != 0) {
    _internal_set_complete(from._internal_complete());
  }
  switch (from.streamingResponse_case()) {
    case kInfo: {
      _internal_mutable_info()->::sensory::api::v1::file::FileInfo::MergeFrom(from._internal_info());
      break;
    }
    case kChunk: {
      _internal_mutable_chunk()->::sensory::api::v1::file::FileChunk::MergeFrom(from._internal_chunk());
      break;
    }
    case STREAMINGRESPONSE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileResponse::CopyFrom(const FileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileResponse::IsInitialized() const {
  return true;
}

void FileResponse::InternalSwap(FileResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(complete_, other->complete_);
  swap(streamingResponse_, other->streamingResponse_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[1]);
}

// ===================================================================

class FileCatalogRequest::_Internal {
 public:
};

FileCatalogRequest::FileCatalogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  categories_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileCatalogRequest)
}
FileCatalogRequest::FileCatalogRequest(const FileCatalogRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      categories_(from.categories_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileCatalogRequest)
}

void FileCatalogRequest::SharedCtor() {
}

FileCatalogRequest::~FileCatalogRequest() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileCatalogRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileCatalogRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FileCatalogRequest::ArenaDtor(void* object) {
  FileCatalogRequest* _this = reinterpret_cast< FileCatalogRequest* >(object);
  (void)_this;
}
void FileCatalogRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileCatalogRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileCatalogRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileCatalogRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  categories_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileCatalogRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sensory.api.v1.file.VersionedFileCategory categories = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_categories(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileCatalogRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileCatalogRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sensory.api.v1.file.VersionedFileCategory categories = 1 [(.validate.rules) = {
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_categories_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_categories(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileCatalogRequest)
  return target;
}

size_t FileCatalogRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileCatalogRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sensory.api.v1.file.VersionedFileCategory categories = 1 [(.validate.rules) = {
  total_size += 1UL * this->_internal_categories_size();
  for (const auto& msg : this->categories_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileCatalogRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileCatalogRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileCatalogRequest::GetClassData() const { return &_class_data_; }

void FileCatalogRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileCatalogRequest *>(to)->MergeFrom(
      static_cast<const FileCatalogRequest &>(from));
}


void FileCatalogRequest::MergeFrom(const FileCatalogRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileCatalogRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  categories_.MergeFrom(from.categories_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileCatalogRequest::CopyFrom(const FileCatalogRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileCatalogRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCatalogRequest::IsInitialized() const {
  return true;
}

void FileCatalogRequest::InternalSwap(FileCatalogRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  categories_.InternalSwap(&other->categories_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileCatalogRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[2]);
}

// ===================================================================

class FileCompleteCatalogRequest::_Internal {
 public:
};

FileCompleteCatalogRequest::FileCompleteCatalogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileCompleteCatalogRequest)
}
FileCompleteCatalogRequest::FileCompleteCatalogRequest(const FileCompleteCatalogRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tenantid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_tenantid().empty()) {
    tenantid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tenantid(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileCompleteCatalogRequest)
}

void FileCompleteCatalogRequest::SharedCtor() {
tenantid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

FileCompleteCatalogRequest::~FileCompleteCatalogRequest() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileCompleteCatalogRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileCompleteCatalogRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tenantid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FileCompleteCatalogRequest::ArenaDtor(void* object) {
  FileCompleteCatalogRequest* _this = reinterpret_cast< FileCompleteCatalogRequest* >(object);
  (void)_this;
}
void FileCompleteCatalogRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileCompleteCatalogRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileCompleteCatalogRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileCompleteCatalogRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tenantid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileCompleteCatalogRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string tenantId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_tenantid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.FileCompleteCatalogRequest.tenantId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileCompleteCatalogRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileCompleteCatalogRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string tenantId = 1;
  if (!this->_internal_tenantid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tenantid().data(), static_cast<int>(this->_internal_tenantid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.FileCompleteCatalogRequest.tenantId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tenantid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileCompleteCatalogRequest)
  return target;
}

size_t FileCompleteCatalogRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileCompleteCatalogRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string tenantId = 1;
  if (!this->_internal_tenantid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tenantid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileCompleteCatalogRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileCompleteCatalogRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileCompleteCatalogRequest::GetClassData() const { return &_class_data_; }

void FileCompleteCatalogRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileCompleteCatalogRequest *>(to)->MergeFrom(
      static_cast<const FileCompleteCatalogRequest &>(from));
}


void FileCompleteCatalogRequest::MergeFrom(const FileCompleteCatalogRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileCompleteCatalogRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_tenantid().empty()) {
    _internal_set_tenantid(from._internal_tenantid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileCompleteCatalogRequest::CopyFrom(const FileCompleteCatalogRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileCompleteCatalogRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCompleteCatalogRequest::IsInitialized() const {
  return true;
}

void FileCompleteCatalogRequest::InternalSwap(FileCompleteCatalogRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tenantid_, lhs_arena,
      &other->tenantid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata FileCompleteCatalogRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[3]);
}

// ===================================================================

class FileCatalogResponse::_Internal {
 public:
};

FileCatalogResponse::FileCatalogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  catalog_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileCatalogResponse)
}
FileCatalogResponse::FileCatalogResponse(const FileCatalogResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      catalog_(from.catalog_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileCatalogResponse)
}

void FileCatalogResponse::SharedCtor() {
}

FileCatalogResponse::~FileCatalogResponse() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileCatalogResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileCatalogResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FileCatalogResponse::ArenaDtor(void* object) {
  FileCatalogResponse* _this = reinterpret_cast< FileCatalogResponse* >(object);
  (void)_this;
}
void FileCatalogResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileCatalogResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileCatalogResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileCatalogResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  catalog_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileCatalogResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sensory.api.v1.file.FileCatalog catalog = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_catalog(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileCatalogResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileCatalogResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sensory.api.v1.file.FileCatalog catalog = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_catalog_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_catalog(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileCatalogResponse)
  return target;
}

size_t FileCatalogResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileCatalogResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sensory.api.v1.file.FileCatalog catalog = 1;
  total_size += 1UL * this->_internal_catalog_size();
  for (const auto& msg : this->catalog_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileCatalogResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileCatalogResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileCatalogResponse::GetClassData() const { return &_class_data_; }

void FileCatalogResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileCatalogResponse *>(to)->MergeFrom(
      static_cast<const FileCatalogResponse &>(from));
}


void FileCatalogResponse::MergeFrom(const FileCatalogResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileCatalogResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  catalog_.MergeFrom(from.catalog_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileCatalogResponse::CopyFrom(const FileCatalogResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileCatalogResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCatalogResponse::IsInitialized() const {
  return true;
}

void FileCatalogResponse::InternalSwap(FileCatalogResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  catalog_.InternalSwap(&other->catalog_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileCatalogResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[4]);
}

// ===================================================================

class FileChunk::_Internal {
 public:
};

FileChunk::FileChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileChunk)
}
FileChunk::FileChunk(const FileChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_bytes().empty()) {
    bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_bytes(), 
      GetArenaForAllocation());
  }
  offset_ = from.offset_;
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileChunk)
}

void FileChunk::SharedCtor() {
bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
offset_ = int64_t{0};
}

FileChunk::~FileChunk() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileChunk)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileChunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  bytes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FileChunk::ArenaDtor(void* object) {
  FileChunk* _this = reinterpret_cast< FileChunk* >(object);
  (void)_this;
}
void FileChunk::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileChunk::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileChunk)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bytes_.ClearToEmpty();
  offset_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileChunk::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes bytes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_bytes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileChunk::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileChunk)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes bytes = 1;
  if (!this->_internal_bytes().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_bytes(), target);
  }

  // int64 offset = 2;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileChunk)
  return target;
}

size_t FileChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileChunk)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes bytes = 1;
  if (!this->_internal_bytes().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_bytes());
  }

  // int64 offset = 2;
  if (this->_internal_offset() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileChunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileChunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileChunk::GetClassData() const { return &_class_data_; }

void FileChunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileChunk *>(to)->MergeFrom(
      static_cast<const FileChunk &>(from));
}


void FileChunk::MergeFrom(const FileChunk& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileChunk)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_bytes().empty()) {
    _internal_set_bytes(from._internal_bytes());
  }
  if (from._internal_offset() != 0) {
    _internal_set_offset(from._internal_offset());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileChunk::CopyFrom(const FileChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileChunk::IsInitialized() const {
  return true;
}

void FileChunk::InternalSwap(FileChunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &bytes_, lhs_arena,
      &other->bytes_, rhs_arena
  );
  swap(offset_, other->offset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileChunk::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[5]);
}

// ===================================================================

class FileInfo::_Internal {
 public:
};

FileInfo::FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileInfo)
}
FileInfo::FileInfo(const FileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_file().empty()) {
    file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file(), 
      GetArenaForAllocation());
  }
  absolutepath_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_absolutepath().empty()) {
    absolutepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_absolutepath(), 
      GetArenaForAllocation());
  }
  contenttype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_contenttype().empty()) {
    contenttype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_contenttype(), 
      GetArenaForAllocation());
  }
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_hash().empty()) {
    hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hash(), 
      GetArenaForAllocation());
  }
  tenantid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_tenantid().empty()) {
    tenantid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tenantid(), 
      GetArenaForAllocation());
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileInfo)
}

void FileInfo::SharedCtor() {
file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
absolutepath_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
contenttype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
tenantid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
size_ = int64_t{0};
}

FileInfo::~FileInfo() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  file_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  absolutepath_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  contenttype_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  tenantid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FileInfo::ArenaDtor(void* object) {
  FileInfo* _this = reinterpret_cast< FileInfo* >(object);
  (void)_this;
}
void FileInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  file_.ClearToEmpty();
  absolutepath_.ClearToEmpty();
  contenttype_.ClearToEmpty();
  hash_.ClearToEmpty();
  tenantid_.ClearToEmpty();
  size_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string file = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_file();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.FileInfo.file"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string absolutePath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_absolutepath();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.FileInfo.absolutePath"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contentType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_contenttype();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.FileInfo.contentType"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.FileInfo.hash"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string tenantId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_tenantid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.FileInfo.tenantId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string file = 1;
  if (!this->_internal_file().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file().data(), static_cast<int>(this->_internal_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.FileInfo.file");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_file(), target);
  }

  // string absolutePath = 2;
  if (!this->_internal_absolutepath().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_absolutepath().data(), static_cast<int>(this->_internal_absolutepath().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.FileInfo.absolutePath");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_absolutepath(), target);
  }

  // int64 size = 3;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_size(), target);
  }

  // string contentType = 4;
  if (!this->_internal_contenttype().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_contenttype().data(), static_cast<int>(this->_internal_contenttype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.FileInfo.contentType");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_contenttype(), target);
  }

  // string hash = 5;
  if (!this->_internal_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hash().data(), static_cast<int>(this->_internal_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.FileInfo.hash");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_hash(), target);
  }

  // string tenantId = 6;
  if (!this->_internal_tenantid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tenantid().data(), static_cast<int>(this->_internal_tenantid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.FileInfo.tenantId");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_tenantid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileInfo)
  return target;
}

size_t FileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string file = 1;
  if (!this->_internal_file().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file());
  }

  // string absolutePath = 2;
  if (!this->_internal_absolutepath().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_absolutepath());
  }

  // string contentType = 4;
  if (!this->_internal_contenttype().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contenttype());
  }

  // string hash = 5;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hash());
  }

  // string tenantId = 6;
  if (!this->_internal_tenantid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tenantid());
  }

  // int64 size = 3;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileInfo::GetClassData() const { return &_class_data_; }

void FileInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileInfo *>(to)->MergeFrom(
      static_cast<const FileInfo &>(from));
}


void FileInfo::MergeFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_file().empty()) {
    _internal_set_file(from._internal_file());
  }
  if (!from._internal_absolutepath().empty()) {
    _internal_set_absolutepath(from._internal_absolutepath());
  }
  if (!from._internal_contenttype().empty()) {
    _internal_set_contenttype(from._internal_contenttype());
  }
  if (!from._internal_hash().empty()) {
    _internal_set_hash(from._internal_hash());
  }
  if (!from._internal_tenantid().empty()) {
    _internal_set_tenantid(from._internal_tenantid());
  }
  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileInfo::CopyFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfo::IsInitialized() const {
  return true;
}

void FileInfo::InternalSwap(FileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_, lhs_arena,
      &other->file_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &absolutepath_, lhs_arena,
      &other->absolutepath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &contenttype_, lhs_arena,
      &other->contenttype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hash_, lhs_arena,
      &other->hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tenantid_, lhs_arena,
      &other->tenantid_, rhs_arena
  );
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[6]);
}

// ===================================================================

class FileCatalog::_Internal {
 public:
  static const ::sensory::api::v1::file::VersionedFileCategory& category(const FileCatalog* msg);
};

const ::sensory::api::v1::file::VersionedFileCategory&
FileCatalog::_Internal::category(const FileCatalog* msg) {
  return *msg->category_;
}
FileCatalog::FileCatalog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  files_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.FileCatalog)
}
FileCatalog::FileCatalog(const FileCatalog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      files_(from.files_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_category()) {
    category_ = new ::sensory::api::v1::file::VersionedFileCategory(*from.category_);
  } else {
    category_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.FileCatalog)
}

void FileCatalog::SharedCtor() {
category_ = nullptr;
}

FileCatalog::~FileCatalog() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.FileCatalog)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FileCatalog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete category_;
}

void FileCatalog::ArenaDtor(void* object) {
  FileCatalog* _this = reinterpret_cast< FileCatalog* >(object);
  (void)_this;
}
void FileCatalog::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FileCatalog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileCatalog::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.FileCatalog)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  files_.Clear();
  if (GetArenaForAllocation() == nullptr && category_ != nullptr) {
    delete category_;
  }
  category_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileCatalog::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sensory.api.v1.file.FileInfo files = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_files(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .sensory.api.v1.file.VersionedFileCategory category = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_category(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileCatalog::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.FileCatalog)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sensory.api.v1.file.FileInfo files = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_files_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_files(i), target, stream);
  }

  // .sensory.api.v1.file.VersionedFileCategory category = 2;
  if (this->_internal_has_category()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::category(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.FileCatalog)
  return target;
}

size_t FileCatalog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.FileCatalog)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sensory.api.v1.file.FileInfo files = 1;
  total_size += 1UL * this->_internal_files_size();
  for (const auto& msg : this->files_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .sensory.api.v1.file.VersionedFileCategory category = 2;
  if (this->_internal_has_category()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *category_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileCatalog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileCatalog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileCatalog::GetClassData() const { return &_class_data_; }

void FileCatalog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileCatalog *>(to)->MergeFrom(
      static_cast<const FileCatalog &>(from));
}


void FileCatalog::MergeFrom(const FileCatalog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.FileCatalog)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  files_.MergeFrom(from.files_);
  if (from._internal_has_category()) {
    _internal_mutable_category()->::sensory::api::v1::file::VersionedFileCategory::MergeFrom(from._internal_category());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileCatalog::CopyFrom(const FileCatalog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.FileCatalog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCatalog::IsInitialized() const {
  return true;
}

void FileCatalog::InternalSwap(FileCatalog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  files_.InternalSwap(&other->files_);
  swap(category_, other->category_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileCatalog::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[7]);
}

// ===================================================================

class VersionedFileCategory::_Internal {
 public:
};

VersionedFileCategory::VersionedFileCategory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sensory.api.v1.file.VersionedFileCategory)
}
VersionedFileCategory::VersionedFileCategory(const VersionedFileCategory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_version().empty()) {
    version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version(), 
      GetArenaForAllocation());
  }
  category_ = from.category_;
  // @@protoc_insertion_point(copy_constructor:sensory.api.v1.file.VersionedFileCategory)
}

void VersionedFileCategory::SharedCtor() {
version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
category_ = 0;
}

VersionedFileCategory::~VersionedFileCategory() {
  // @@protoc_insertion_point(destructor:sensory.api.v1.file.VersionedFileCategory)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VersionedFileCategory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void VersionedFileCategory::ArenaDtor(void* object) {
  VersionedFileCategory* _this = reinterpret_cast< VersionedFileCategory* >(object);
  (void)_this;
}
void VersionedFileCategory::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VersionedFileCategory::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VersionedFileCategory::Clear() {
// @@protoc_insertion_point(message_clear_start:sensory.api.v1.file.VersionedFileCategory)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  version_.ClearToEmpty();
  category_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VersionedFileCategory::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .sensory.api.v1.file.FileCategory category = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_category(static_cast<::sensory::api::v1::file::FileCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sensory.api.v1.file.VersionedFileCategory.version"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VersionedFileCategory::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensory.api.v1.file.VersionedFileCategory)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensory.api.v1.file.FileCategory category = 1 [(.validate.rules) = {
  if (this->_internal_category() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_category(), target);
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sensory.api.v1.file.VersionedFileCategory.version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensory.api.v1.file.VersionedFileCategory)
  return target;
}

size_t VersionedFileCategory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensory.api.v1.file.VersionedFileCategory)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // .sensory.api.v1.file.FileCategory category = 1 [(.validate.rules) = {
  if (this->_internal_category() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_category());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VersionedFileCategory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VersionedFileCategory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VersionedFileCategory::GetClassData() const { return &_class_data_; }

void VersionedFileCategory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VersionedFileCategory *>(to)->MergeFrom(
      static_cast<const VersionedFileCategory &>(from));
}


void VersionedFileCategory::MergeFrom(const VersionedFileCategory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensory.api.v1.file.VersionedFileCategory)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_version().empty()) {
    _internal_set_version(from._internal_version());
  }
  if (from._internal_category() != 0) {
    _internal_set_category(from._internal_category());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VersionedFileCategory::CopyFrom(const VersionedFileCategory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensory.api.v1.file.VersionedFileCategory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionedFileCategory::IsInitialized() const {
  return true;
}

void VersionedFileCategory::InternalSwap(VersionedFileCategory* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  swap(category_, other->category_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VersionedFileCategory::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2ffile_2ffile_2eproto_getter, &descriptor_table_v1_2ffile_2ffile_2eproto_once,
      file_level_metadata_v1_2ffile_2ffile_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace file
}  // namespace v1
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileRequest* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileResponse* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileCatalogRequest* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileCatalogRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileCatalogRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileCompleteCatalogRequest* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileCompleteCatalogRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileCompleteCatalogRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileCatalogResponse* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileCatalogResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileCatalogResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileChunk* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileInfo* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::FileCatalog* Arena::CreateMaybeMessage< ::sensory::api::v1::file::FileCatalog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::FileCatalog >(arena);
}
template<> PROTOBUF_NOINLINE ::sensory::api::v1::file::VersionedFileCategory* Arena::CreateMaybeMessage< ::sensory::api::v1::file::VersionedFileCategory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensory::api::v1::file::VersionedFileCategory >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
