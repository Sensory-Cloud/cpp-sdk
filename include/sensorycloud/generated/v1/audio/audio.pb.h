// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/audio/audio.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2faudio_2faudio_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_v1_2faudio_2faudio_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "validate/validate.pb.h"
#include "common/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_v1_2faudio_2faudio_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2faudio_2faudio_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[28]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v1_2faudio_2faudio_2eproto;
namespace sensory {
namespace api {
namespace v1 {
namespace audio {
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class AudioModel;
struct AudioModelDefaultTypeInternal;
extern AudioModelDefaultTypeInternal _AudioModel_default_instance_;
class AudioRequestPostProcessingAction;
struct AudioRequestPostProcessingActionDefaultTypeInternal;
extern AudioRequestPostProcessingActionDefaultTypeInternal _AudioRequestPostProcessingAction_default_instance_;
class AudioResponsePostProcessingAction;
struct AudioResponsePostProcessingActionDefaultTypeInternal;
extern AudioResponsePostProcessingActionDefaultTypeInternal _AudioResponsePostProcessingAction_default_instance_;
class AuthenticateConfig;
struct AuthenticateConfigDefaultTypeInternal;
extern AuthenticateConfigDefaultTypeInternal _AuthenticateConfig_default_instance_;
class AuthenticateRequest;
struct AuthenticateRequestDefaultTypeInternal;
extern AuthenticateRequestDefaultTypeInternal _AuthenticateRequest_default_instance_;
class AuthenticateResponse;
struct AuthenticateResponseDefaultTypeInternal;
extern AuthenticateResponseDefaultTypeInternal _AuthenticateResponse_default_instance_;
class CreateEnrolledEventRequest;
struct CreateEnrolledEventRequestDefaultTypeInternal;
extern CreateEnrolledEventRequestDefaultTypeInternal _CreateEnrolledEventRequest_default_instance_;
class CreateEnrollmentConfig;
struct CreateEnrollmentConfigDefaultTypeInternal;
extern CreateEnrollmentConfigDefaultTypeInternal _CreateEnrollmentConfig_default_instance_;
class CreateEnrollmentEventConfig;
struct CreateEnrollmentEventConfigDefaultTypeInternal;
extern CreateEnrollmentEventConfigDefaultTypeInternal _CreateEnrollmentEventConfig_default_instance_;
class CreateEnrollmentRequest;
struct CreateEnrollmentRequestDefaultTypeInternal;
extern CreateEnrollmentRequestDefaultTypeInternal _CreateEnrollmentRequest_default_instance_;
class CreateEnrollmentResponse;
struct CreateEnrollmentResponseDefaultTypeInternal;
extern CreateEnrollmentResponseDefaultTypeInternal _CreateEnrollmentResponse_default_instance_;
class GetModelsRequest;
struct GetModelsRequestDefaultTypeInternal;
extern GetModelsRequestDefaultTypeInternal _GetModelsRequest_default_instance_;
class GetModelsResponse;
struct GetModelsResponseDefaultTypeInternal;
extern GetModelsResponseDefaultTypeInternal _GetModelsResponse_default_instance_;
class SynthesizeSpeechRequest;
struct SynthesizeSpeechRequestDefaultTypeInternal;
extern SynthesizeSpeechRequestDefaultTypeInternal _SynthesizeSpeechRequest_default_instance_;
class SynthesizeSpeechResponse;
struct SynthesizeSpeechResponseDefaultTypeInternal;
extern SynthesizeSpeechResponseDefaultTypeInternal _SynthesizeSpeechResponse_default_instance_;
class TranscribeConfig;
struct TranscribeConfigDefaultTypeInternal;
extern TranscribeConfigDefaultTypeInternal _TranscribeConfig_default_instance_;
class TranscribeRequest;
struct TranscribeRequestDefaultTypeInternal;
extern TranscribeRequestDefaultTypeInternal _TranscribeRequest_default_instance_;
class TranscribeResponse;
struct TranscribeResponseDefaultTypeInternal;
extern TranscribeResponseDefaultTypeInternal _TranscribeResponse_default_instance_;
class TranscribeWord;
struct TranscribeWordDefaultTypeInternal;
extern TranscribeWordDefaultTypeInternal _TranscribeWord_default_instance_;
class TranscribeWordResponse;
struct TranscribeWordResponseDefaultTypeInternal;
extern TranscribeWordResponseDefaultTypeInternal _TranscribeWordResponse_default_instance_;
class ValidateEnrolledEventConfig;
struct ValidateEnrolledEventConfigDefaultTypeInternal;
extern ValidateEnrolledEventConfigDefaultTypeInternal _ValidateEnrolledEventConfig_default_instance_;
class ValidateEnrolledEventRequest;
struct ValidateEnrolledEventRequestDefaultTypeInternal;
extern ValidateEnrolledEventRequestDefaultTypeInternal _ValidateEnrolledEventRequest_default_instance_;
class ValidateEnrolledEventResponse;
struct ValidateEnrolledEventResponseDefaultTypeInternal;
extern ValidateEnrolledEventResponseDefaultTypeInternal _ValidateEnrolledEventResponse_default_instance_;
class ValidateEventConfig;
struct ValidateEventConfigDefaultTypeInternal;
extern ValidateEventConfigDefaultTypeInternal _ValidateEventConfig_default_instance_;
class ValidateEventRequest;
struct ValidateEventRequestDefaultTypeInternal;
extern ValidateEventRequestDefaultTypeInternal _ValidateEventRequest_default_instance_;
class ValidateEventResponse;
struct ValidateEventResponseDefaultTypeInternal;
extern ValidateEventResponseDefaultTypeInternal _ValidateEventResponse_default_instance_;
class VoiceSynthesisConfig;
struct VoiceSynthesisConfigDefaultTypeInternal;
extern VoiceSynthesisConfigDefaultTypeInternal _VoiceSynthesisConfig_default_instance_;
}  // namespace audio
}  // namespace v1
}  // namespace api
}  // namespace sensory
PROTOBUF_NAMESPACE_OPEN
template<> ::sensory::api::v1::audio::AudioConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(Arena*);
template<> ::sensory::api::v1::audio::AudioModel* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AudioModel>(Arena*);
template<> ::sensory::api::v1::audio::AudioRequestPostProcessingAction* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AudioRequestPostProcessingAction>(Arena*);
template<> ::sensory::api::v1::audio::AudioResponsePostProcessingAction* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AudioResponsePostProcessingAction>(Arena*);
template<> ::sensory::api::v1::audio::AuthenticateConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AuthenticateConfig>(Arena*);
template<> ::sensory::api::v1::audio::AuthenticateRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AuthenticateRequest>(Arena*);
template<> ::sensory::api::v1::audio::AuthenticateResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::AuthenticateResponse>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrolledEventRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrolledEventRequest>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrollmentConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrollmentConfig>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrollmentEventConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrollmentEventConfig>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrollmentRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrollmentRequest>(Arena*);
template<> ::sensory::api::v1::audio::CreateEnrollmentResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::CreateEnrollmentResponse>(Arena*);
template<> ::sensory::api::v1::audio::GetModelsRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::GetModelsRequest>(Arena*);
template<> ::sensory::api::v1::audio::GetModelsResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::GetModelsResponse>(Arena*);
template<> ::sensory::api::v1::audio::SynthesizeSpeechRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::SynthesizeSpeechRequest>(Arena*);
template<> ::sensory::api::v1::audio::SynthesizeSpeechResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::SynthesizeSpeechResponse>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeConfig>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeRequest>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeResponse>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeWord* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeWord>(Arena*);
template<> ::sensory::api::v1::audio::TranscribeWordResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::TranscribeWordResponse>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEnrolledEventConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEnrolledEventConfig>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEnrolledEventRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEnrolledEventRequest>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEnrolledEventResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEnrolledEventResponse>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEventConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEventConfig>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEventRequest* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEventRequest>(Arena*);
template<> ::sensory::api::v1::audio::ValidateEventResponse* Arena::CreateMaybeMessage<::sensory::api::v1::audio::ValidateEventResponse>(Arena*);
template<> ::sensory::api::v1::audio::VoiceSynthesisConfig* Arena::CreateMaybeMessage<::sensory::api::v1::audio::VoiceSynthesisConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensory {
namespace api {
namespace v1 {
namespace audio {

enum AuthenticateConfig_ThresholdSecurity : int {
  AuthenticateConfig_ThresholdSecurity_HIGH = 0,
  AuthenticateConfig_ThresholdSecurity_LOW = 1,
  AuthenticateConfig_ThresholdSecurity_AuthenticateConfig_ThresholdSecurity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AuthenticateConfig_ThresholdSecurity_AuthenticateConfig_ThresholdSecurity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AuthenticateConfig_ThresholdSecurity_IsValid(int value);
constexpr AuthenticateConfig_ThresholdSecurity AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MIN = AuthenticateConfig_ThresholdSecurity_HIGH;
constexpr AuthenticateConfig_ThresholdSecurity AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MAX = AuthenticateConfig_ThresholdSecurity_LOW;
constexpr int AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_ARRAYSIZE = AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AuthenticateConfig_ThresholdSecurity_descriptor();
template<typename T>
inline const std::string& AuthenticateConfig_ThresholdSecurity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuthenticateConfig_ThresholdSecurity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuthenticateConfig_ThresholdSecurity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AuthenticateConfig_ThresholdSecurity_descriptor(), enum_t_value);
}
inline bool AuthenticateConfig_ThresholdSecurity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AuthenticateConfig_ThresholdSecurity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AuthenticateConfig_ThresholdSecurity>(
    AuthenticateConfig_ThresholdSecurity_descriptor(), name, value);
}
enum AudioConfig_AudioEncoding : int {
  AudioConfig_AudioEncoding_LINEAR16 = 0,
  AudioConfig_AudioEncoding_FLAC = 1,
  AudioConfig_AudioEncoding_MULAW = 2,
  AudioConfig_AudioEncoding_AudioConfig_AudioEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioConfig_AudioEncoding_AudioConfig_AudioEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioConfig_AudioEncoding_IsValid(int value);
constexpr AudioConfig_AudioEncoding AudioConfig_AudioEncoding_AudioEncoding_MIN = AudioConfig_AudioEncoding_LINEAR16;
constexpr AudioConfig_AudioEncoding AudioConfig_AudioEncoding_AudioEncoding_MAX = AudioConfig_AudioEncoding_MULAW;
constexpr int AudioConfig_AudioEncoding_AudioEncoding_ARRAYSIZE = AudioConfig_AudioEncoding_AudioEncoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioConfig_AudioEncoding_descriptor();
template<typename T>
inline const std::string& AudioConfig_AudioEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioConfig_AudioEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioConfig_AudioEncoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioConfig_AudioEncoding_descriptor(), enum_t_value);
}
inline bool AudioConfig_AudioEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioConfig_AudioEncoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioConfig_AudioEncoding>(
    AudioConfig_AudioEncoding_descriptor(), name, value);
}
enum AudioPostProcessingAction : int {
  NOT_SET = 0,
  FLUSH = 1,
  RESET = 2,
  FINAL = 3,
  AudioPostProcessingAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioPostProcessingAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioPostProcessingAction_IsValid(int value);
constexpr AudioPostProcessingAction AudioPostProcessingAction_MIN = NOT_SET;
constexpr AudioPostProcessingAction AudioPostProcessingAction_MAX = FINAL;
constexpr int AudioPostProcessingAction_ARRAYSIZE = AudioPostProcessingAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioPostProcessingAction_descriptor();
template<typename T>
inline const std::string& AudioPostProcessingAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioPostProcessingAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioPostProcessingAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioPostProcessingAction_descriptor(), enum_t_value);
}
inline bool AudioPostProcessingAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioPostProcessingAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioPostProcessingAction>(
    AudioPostProcessingAction_descriptor(), name, value);
}
enum WordState : int {
  WORDSTATE_PENDING = 0,
  WORDSTATE_FINAL = 1,
  WordState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WordState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WordState_IsValid(int value);
constexpr WordState WordState_MIN = WORDSTATE_PENDING;
constexpr WordState WordState_MAX = WORDSTATE_FINAL;
constexpr int WordState_ARRAYSIZE = WordState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WordState_descriptor();
template<typename T>
inline const std::string& WordState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WordState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WordState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WordState_descriptor(), enum_t_value);
}
inline bool WordState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WordState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WordState>(
    WordState_descriptor(), name, value);
}
enum ThresholdSensitivity : int {
  LOWEST = 0,
  LOW = 1,
  MEDIUM = 2,
  HIGH = 3,
  HIGHEST = 4,
  ThresholdSensitivity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ThresholdSensitivity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ThresholdSensitivity_IsValid(int value);
constexpr ThresholdSensitivity ThresholdSensitivity_MIN = LOWEST;
constexpr ThresholdSensitivity ThresholdSensitivity_MAX = HIGHEST;
constexpr int ThresholdSensitivity_ARRAYSIZE = ThresholdSensitivity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThresholdSensitivity_descriptor();
template<typename T>
inline const std::string& ThresholdSensitivity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThresholdSensitivity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThresholdSensitivity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThresholdSensitivity_descriptor(), enum_t_value);
}
inline bool ThresholdSensitivity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThresholdSensitivity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThresholdSensitivity>(
    ThresholdSensitivity_descriptor(), name, value);
}
// ===================================================================

class GetModelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.GetModelsRequest) */ {
 public:
  inline GetModelsRequest() : GetModelsRequest(nullptr) {}
  explicit constexpr GetModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsRequest(const GetModelsRequest& from);
  GetModelsRequest(GetModelsRequest&& from) noexcept
    : GetModelsRequest() {
    *this = ::std::move(from);
  }

  inline GetModelsRequest& operator=(const GetModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsRequest& operator=(GetModelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsRequest* internal_default_instance() {
    return reinterpret_cast<const GetModelsRequest*>(
               &_GetModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetModelsRequest& a, GetModelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsRequest* New() const final {
    return new GetModelsRequest();
  }

  GetModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetModelsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetModelsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.GetModelsRequest";
  }
  protected:
  explicit GetModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.GetModelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AudioModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AudioModel) */ {
 public:
  inline AudioModel() : AudioModel(nullptr) {}
  ~AudioModel() override;
  explicit constexpr AudioModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioModel(const AudioModel& from);
  AudioModel(AudioModel&& from) noexcept
    : AudioModel() {
    *this = ::std::move(from);
  }

  inline AudioModel& operator=(const AudioModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioModel& operator=(AudioModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioModel* internal_default_instance() {
    return reinterpret_cast<const AudioModel*>(
               &_AudioModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AudioModel& a, AudioModel& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioModel* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioModel* New() const final {
    return new AudioModel();
  }

  AudioModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioModel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AudioModel";
  }
  protected:
  explicit AudioModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 6,
    kNameFieldNumber = 1,
    kFixedPhraseFieldNumber = 4,
    kModelTypeFieldNumber = 3,
    kSampleRateFieldNumber = 5,
    kIsEnrollableFieldNumber = 2,
    kIsLivenessSupportedFieldNumber = 8,
    kTechnologyFieldNumber = 7,
  };
  // repeated string versions = 6;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fixedPhrase = 4;
  void clear_fixedphrase();
  const std::string& fixedphrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fixedphrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fixedphrase();
  PROTOBUF_MUST_USE_RESULT std::string* release_fixedphrase();
  void set_allocated_fixedphrase(std::string* fixedphrase);
  private:
  const std::string& _internal_fixedphrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixedphrase(const std::string& value);
  std::string* _internal_mutable_fixedphrase();
  public:

  // .sensory.api.common.ModelType modelType = 3;
  void clear_modeltype();
  ::sensory::api::common::ModelType modeltype() const;
  void set_modeltype(::sensory::api::common::ModelType value);
  private:
  ::sensory::api::common::ModelType _internal_modeltype() const;
  void _internal_set_modeltype(::sensory::api::common::ModelType value);
  public:

  // int32 sampleRate = 5;
  void clear_samplerate();
  ::PROTOBUF_NAMESPACE_ID::int32 samplerate() const;
  void set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_samplerate() const;
  void _internal_set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isEnrollable = 2;
  void clear_isenrollable();
  bool isenrollable() const;
  void set_isenrollable(bool value);
  private:
  bool _internal_isenrollable() const;
  void _internal_set_isenrollable(bool value);
  public:

  // bool isLivenessSupported = 8;
  void clear_islivenesssupported();
  bool islivenesssupported() const;
  void set_islivenesssupported(bool value);
  private:
  bool _internal_islivenesssupported() const;
  void _internal_set_islivenesssupported(bool value);
  public:

  // .sensory.api.common.TechnologyType technology = 7;
  void clear_technology();
  ::sensory::api::common::TechnologyType technology() const;
  void set_technology(::sensory::api::common::TechnologyType value);
  private:
  ::sensory::api::common::TechnologyType _internal_technology() const;
  void _internal_set_technology(::sensory::api::common::TechnologyType value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AudioModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixedphrase_;
  int modeltype_;
  ::PROTOBUF_NAMESPACE_ID::int32 samplerate_;
  bool isenrollable_;
  bool islivenesssupported_;
  int technology_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AudioRequestPostProcessingAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AudioRequestPostProcessingAction) */ {
 public:
  inline AudioRequestPostProcessingAction() : AudioRequestPostProcessingAction(nullptr) {}
  ~AudioRequestPostProcessingAction() override;
  explicit constexpr AudioRequestPostProcessingAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioRequestPostProcessingAction(const AudioRequestPostProcessingAction& from);
  AudioRequestPostProcessingAction(AudioRequestPostProcessingAction&& from) noexcept
    : AudioRequestPostProcessingAction() {
    *this = ::std::move(from);
  }

  inline AudioRequestPostProcessingAction& operator=(const AudioRequestPostProcessingAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioRequestPostProcessingAction& operator=(AudioRequestPostProcessingAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioRequestPostProcessingAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioRequestPostProcessingAction* internal_default_instance() {
    return reinterpret_cast<const AudioRequestPostProcessingAction*>(
               &_AudioRequestPostProcessingAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AudioRequestPostProcessingAction& a, AudioRequestPostProcessingAction& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioRequestPostProcessingAction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioRequestPostProcessingAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioRequestPostProcessingAction* New() const final {
    return new AudioRequestPostProcessingAction();
  }

  AudioRequestPostProcessingAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioRequestPostProcessingAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioRequestPostProcessingAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioRequestPostProcessingAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioRequestPostProcessingAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AudioRequestPostProcessingAction";
  }
  protected:
  explicit AudioRequestPostProcessingAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionIdFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // string actionId = 1;
  void clear_actionid();
  const std::string& actionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actionid();
  PROTOBUF_MUST_USE_RESULT std::string* release_actionid();
  void set_allocated_actionid(std::string* actionid);
  private:
  const std::string& _internal_actionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actionid(const std::string& value);
  std::string* _internal_mutable_actionid();
  public:

  // .sensory.api.v1.audio.AudioPostProcessingAction action = 2 [(.validate.rules) = {
  void clear_action();
  ::sensory::api::v1::audio::AudioPostProcessingAction action() const;
  void set_action(::sensory::api::v1::audio::AudioPostProcessingAction value);
  private:
  ::sensory::api::v1::audio::AudioPostProcessingAction _internal_action() const;
  void _internal_set_action(::sensory::api::v1::audio::AudioPostProcessingAction value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AudioRequestPostProcessingAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actionid_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AudioResponsePostProcessingAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AudioResponsePostProcessingAction) */ {
 public:
  inline AudioResponsePostProcessingAction() : AudioResponsePostProcessingAction(nullptr) {}
  ~AudioResponsePostProcessingAction() override;
  explicit constexpr AudioResponsePostProcessingAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioResponsePostProcessingAction(const AudioResponsePostProcessingAction& from);
  AudioResponsePostProcessingAction(AudioResponsePostProcessingAction&& from) noexcept
    : AudioResponsePostProcessingAction() {
    *this = ::std::move(from);
  }

  inline AudioResponsePostProcessingAction& operator=(const AudioResponsePostProcessingAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioResponsePostProcessingAction& operator=(AudioResponsePostProcessingAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioResponsePostProcessingAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioResponsePostProcessingAction* internal_default_instance() {
    return reinterpret_cast<const AudioResponsePostProcessingAction*>(
               &_AudioResponsePostProcessingAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AudioResponsePostProcessingAction& a, AudioResponsePostProcessingAction& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioResponsePostProcessingAction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioResponsePostProcessingAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioResponsePostProcessingAction* New() const final {
    return new AudioResponsePostProcessingAction();
  }

  AudioResponsePostProcessingAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioResponsePostProcessingAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioResponsePostProcessingAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioResponsePostProcessingAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioResponsePostProcessingAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AudioResponsePostProcessingAction";
  }
  protected:
  explicit AudioResponsePostProcessingAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionIdFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // string actionId = 1;
  void clear_actionid();
  const std::string& actionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actionid();
  PROTOBUF_MUST_USE_RESULT std::string* release_actionid();
  void set_allocated_actionid(std::string* actionid);
  private:
  const std::string& _internal_actionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actionid(const std::string& value);
  std::string* _internal_mutable_actionid();
  public:

  // .sensory.api.v1.audio.AudioPostProcessingAction action = 2 [(.validate.rules) = {
  void clear_action();
  ::sensory::api::v1::audio::AudioPostProcessingAction action() const;
  void set_action(::sensory::api::v1::audio::AudioPostProcessingAction value);
  private:
  ::sensory::api::v1::audio::AudioPostProcessingAction _internal_action() const;
  void _internal_set_action(::sensory::api::v1::audio::AudioPostProcessingAction value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AudioResponsePostProcessingAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actionid_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class GetModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.GetModelsResponse) */ {
 public:
  inline GetModelsResponse() : GetModelsResponse(nullptr) {}
  ~GetModelsResponse() override;
  explicit constexpr GetModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsResponse(const GetModelsResponse& from);
  GetModelsResponse(GetModelsResponse&& from) noexcept
    : GetModelsResponse() {
    *this = ::std::move(from);
  }

  inline GetModelsResponse& operator=(const GetModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsResponse& operator=(GetModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsResponse* internal_default_instance() {
    return reinterpret_cast<const GetModelsResponse*>(
               &_GetModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetModelsResponse& a, GetModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsResponse* New() const final {
    return new GetModelsResponse();
  }

  GetModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetModelsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.GetModelsResponse";
  }
  protected:
  explicit GetModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
  };
  // repeated .sensory.api.v1.audio.AudioModel models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::sensory::api::v1::audio::AudioModel* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >*
      mutable_models();
  private:
  const ::sensory::api::v1::audio::AudioModel& _internal_models(int index) const;
  ::sensory::api::v1::audio::AudioModel* _internal_add_models();
  public:
  const ::sensory::api::v1::audio::AudioModel& models(int index) const;
  ::sensory::api::v1::audio::AudioModel* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >&
      models() const;

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.GetModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel > models_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrollmentRequest) */ {
 public:
  inline CreateEnrollmentRequest() : CreateEnrollmentRequest(nullptr) {}
  ~CreateEnrollmentRequest() override;
  explicit constexpr CreateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentRequest(const CreateEnrollmentRequest& from);
  CreateEnrollmentRequest(CreateEnrollmentRequest&& from) noexcept
    : CreateEnrollmentRequest() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentRequest& operator=(const CreateEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentRequest& operator=(CreateEnrollmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const CreateEnrollmentRequest* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentRequest*>(
               &_CreateEnrollmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateEnrollmentRequest& a, CreateEnrollmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentRequest* New() const final {
    return new CreateEnrollmentRequest();
  }

  CreateEnrollmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrollmentRequest";
  }
  protected:
  explicit CreateEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.CreateEnrollmentConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::CreateEnrollmentConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::CreateEnrollmentConfig* release_config();
  ::sensory::api::v1::audio::CreateEnrollmentConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::CreateEnrollmentConfig* config);
  private:
  const ::sensory::api::v1::audio::CreateEnrollmentConfig& _internal_config() const;
  ::sensory::api::v1::audio::CreateEnrollmentConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::CreateEnrollmentConfig* config);
  ::sensory::api::v1::audio::CreateEnrollmentConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrollmentRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::CreateEnrollmentConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AuthenticateRequest) */ {
 public:
  inline AuthenticateRequest() : AuthenticateRequest(nullptr) {}
  ~AuthenticateRequest() override;
  explicit constexpr AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateRequest(const AuthenticateRequest& from);
  AuthenticateRequest(AuthenticateRequest&& from) noexcept
    : AuthenticateRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateRequest& operator=(const AuthenticateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateRequest& operator=(AuthenticateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const AuthenticateRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateRequest*>(
               &_AuthenticateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AuthenticateRequest& a, AuthenticateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateRequest* New() const final {
    return new AuthenticateRequest();
  }

  AuthenticateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AuthenticateRequest";
  }
  protected:
  explicit AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.AuthenticateConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::AuthenticateConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AuthenticateConfig* release_config();
  ::sensory::api::v1::audio::AuthenticateConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::AuthenticateConfig* config);
  private:
  const ::sensory::api::v1::audio::AuthenticateConfig& _internal_config() const;
  ::sensory::api::v1::audio::AuthenticateConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::AuthenticateConfig* config);
  ::sensory::api::v1::audio::AuthenticateConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AuthenticateRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::AuthenticateConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEventRequest) */ {
 public:
  inline ValidateEventRequest() : ValidateEventRequest(nullptr) {}
  ~ValidateEventRequest() override;
  explicit constexpr ValidateEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEventRequest(const ValidateEventRequest& from);
  ValidateEventRequest(ValidateEventRequest&& from) noexcept
    : ValidateEventRequest() {
    *this = ::std::move(from);
  }

  inline ValidateEventRequest& operator=(const ValidateEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEventRequest& operator=(ValidateEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEventRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const ValidateEventRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateEventRequest*>(
               &_ValidateEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ValidateEventRequest& a, ValidateEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEventRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEventRequest* New() const final {
    return new ValidateEventRequest();
  }

  ValidateEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEventRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEventRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEventRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEventRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEventRequest";
  }
  protected:
  explicit ValidateEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPostProcessingActionFieldNumber = 10,
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.AudioRequestPostProcessingAction postProcessingAction = 10;
  bool has_postprocessingaction() const;
  private:
  bool _internal_has_postprocessingaction() const;
  public:
  void clear_postprocessingaction();
  const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& postprocessingaction() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioRequestPostProcessingAction* release_postprocessingaction();
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* mutable_postprocessingaction();
  void set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction);
  private:
  const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& _internal_postprocessingaction() const;
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* _internal_mutable_postprocessingaction();
  public:
  void unsafe_arena_set_allocated_postprocessingaction(
      ::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction);
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* unsafe_arena_release_postprocessingaction();

  // .sensory.api.v1.audio.ValidateEventConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::ValidateEventConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::ValidateEventConfig* release_config();
  ::sensory::api::v1::audio::ValidateEventConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::ValidateEventConfig* config);
  private:
  const ::sensory::api::v1::audio::ValidateEventConfig& _internal_config() const;
  ::sensory::api::v1::audio::ValidateEventConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::ValidateEventConfig* config);
  ::sensory::api::v1::audio::ValidateEventConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEventRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::ValidateEventConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrolledEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrolledEventRequest) */ {
 public:
  inline CreateEnrolledEventRequest() : CreateEnrolledEventRequest(nullptr) {}
  ~CreateEnrolledEventRequest() override;
  explicit constexpr CreateEnrolledEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrolledEventRequest(const CreateEnrolledEventRequest& from);
  CreateEnrolledEventRequest(CreateEnrolledEventRequest&& from) noexcept
    : CreateEnrolledEventRequest() {
    *this = ::std::move(from);
  }

  inline CreateEnrolledEventRequest& operator=(const CreateEnrolledEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrolledEventRequest& operator=(CreateEnrolledEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrolledEventRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const CreateEnrolledEventRequest* internal_default_instance() {
    return reinterpret_cast<const CreateEnrolledEventRequest*>(
               &_CreateEnrolledEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateEnrolledEventRequest& a, CreateEnrolledEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrolledEventRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrolledEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrolledEventRequest* New() const final {
    return new CreateEnrolledEventRequest();
  }

  CreateEnrolledEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrolledEventRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrolledEventRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrolledEventRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrolledEventRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrolledEventRequest";
  }
  protected:
  explicit CreateEnrolledEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.CreateEnrollmentEventConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::CreateEnrollmentEventConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::CreateEnrollmentEventConfig* release_config();
  ::sensory::api::v1::audio::CreateEnrollmentEventConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::CreateEnrollmentEventConfig* config);
  private:
  const ::sensory::api::v1::audio::CreateEnrollmentEventConfig& _internal_config() const;
  ::sensory::api::v1::audio::CreateEnrollmentEventConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::CreateEnrollmentEventConfig* config);
  ::sensory::api::v1::audio::CreateEnrollmentEventConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrolledEventRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::CreateEnrollmentEventConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEnrolledEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEnrolledEventRequest) */ {
 public:
  inline ValidateEnrolledEventRequest() : ValidateEnrolledEventRequest(nullptr) {}
  ~ValidateEnrolledEventRequest() override;
  explicit constexpr ValidateEnrolledEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEnrolledEventRequest(const ValidateEnrolledEventRequest& from);
  ValidateEnrolledEventRequest(ValidateEnrolledEventRequest&& from) noexcept
    : ValidateEnrolledEventRequest() {
    *this = ::std::move(from);
  }

  inline ValidateEnrolledEventRequest& operator=(const ValidateEnrolledEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEnrolledEventRequest& operator=(ValidateEnrolledEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEnrolledEventRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const ValidateEnrolledEventRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateEnrolledEventRequest*>(
               &_ValidateEnrolledEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ValidateEnrolledEventRequest& a, ValidateEnrolledEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEnrolledEventRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEnrolledEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEnrolledEventRequest* New() const final {
    return new ValidateEnrolledEventRequest();
  }

  ValidateEnrolledEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEnrolledEventRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEnrolledEventRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEnrolledEventRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEnrolledEventRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEnrolledEventRequest";
  }
  protected:
  explicit ValidateEnrolledEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.ValidateEnrolledEventConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::ValidateEnrolledEventConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::ValidateEnrolledEventConfig* release_config();
  ::sensory::api::v1::audio::ValidateEnrolledEventConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::ValidateEnrolledEventConfig* config);
  private:
  const ::sensory::api::v1::audio::ValidateEnrolledEventConfig& _internal_config() const;
  ::sensory::api::v1::audio::ValidateEnrolledEventConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::ValidateEnrolledEventConfig* config);
  ::sensory::api::v1::audio::ValidateEnrolledEventConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEnrolledEventRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::ValidateEnrolledEventConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeRequest) */ {
 public:
  inline TranscribeRequest() : TranscribeRequest(nullptr) {}
  ~TranscribeRequest() override;
  explicit constexpr TranscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeRequest(const TranscribeRequest& from);
  TranscribeRequest(TranscribeRequest&& from) noexcept
    : TranscribeRequest() {
    *this = ::std::move(from);
  }

  inline TranscribeRequest& operator=(const TranscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeRequest& operator=(TranscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGREQUEST_NOT_SET = 0,
  };

  static inline const TranscribeRequest* internal_default_instance() {
    return reinterpret_cast<const TranscribeRequest*>(
               &_TranscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TranscribeRequest& a, TranscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeRequest* New() const final {
    return new TranscribeRequest();
  }

  TranscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeRequest";
  }
  protected:
  explicit TranscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPostProcessingActionFieldNumber = 10,
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.AudioRequestPostProcessingAction postProcessingAction = 10;
  bool has_postprocessingaction() const;
  private:
  bool _internal_has_postprocessingaction() const;
  public:
  void clear_postprocessingaction();
  const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& postprocessingaction() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioRequestPostProcessingAction* release_postprocessingaction();
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* mutable_postprocessingaction();
  void set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction);
  private:
  const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& _internal_postprocessingaction() const;
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* _internal_mutable_postprocessingaction();
  public:
  void unsafe_arena_set_allocated_postprocessingaction(
      ::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction);
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* unsafe_arena_release_postprocessingaction();

  // .sensory.api.v1.audio.TranscribeConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::TranscribeConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::TranscribeConfig* release_config();
  ::sensory::api::v1::audio::TranscribeConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::TranscribeConfig* config);
  private:
  const ::sensory::api::v1::audio::TranscribeConfig& _internal_config() const;
  ::sensory::api::v1::audio::TranscribeConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::TranscribeConfig* config);
  ::sensory::api::v1::audio::TranscribeConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingRequest();
  StreamingRequestCase streamingRequest_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeRequest)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingRequest() const;
  inline void clear_has_streamingRequest();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction_;
  union StreamingRequestUnion {
    constexpr StreamingRequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::TranscribeConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingRequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class SynthesizeSpeechRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.SynthesizeSpeechRequest) */ {
 public:
  inline SynthesizeSpeechRequest() : SynthesizeSpeechRequest(nullptr) {}
  ~SynthesizeSpeechRequest() override;
  explicit constexpr SynthesizeSpeechRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeSpeechRequest(const SynthesizeSpeechRequest& from);
  SynthesizeSpeechRequest(SynthesizeSpeechRequest&& from) noexcept
    : SynthesizeSpeechRequest() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechRequest& operator=(const SynthesizeSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeSpeechRequest& operator=(SynthesizeSpeechRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeSpeechRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeSpeechRequest* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechRequest*>(
               &_SynthesizeSpeechRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SynthesizeSpeechRequest& a, SynthesizeSpeechRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeSpeechRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeSpeechRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SynthesizeSpeechRequest* New() const final {
    return new SynthesizeSpeechRequest();
  }

  SynthesizeSpeechRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SynthesizeSpeechRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeSpeechRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SynthesizeSpeechRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeSpeechRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.SynthesizeSpeechRequest";
  }
  protected:
  explicit SynthesizeSpeechRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhraseFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // string phrase = 1;
  void clear_phrase();
  const std::string& phrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phrase();
  PROTOBUF_MUST_USE_RESULT std::string* release_phrase();
  void set_allocated_phrase(std::string* phrase);
  private:
  const std::string& _internal_phrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phrase(const std::string& value);
  std::string* _internal_mutable_phrase();
  public:

  // .sensory.api.v1.audio.VoiceSynthesisConfig config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::VoiceSynthesisConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::VoiceSynthesisConfig* release_config();
  ::sensory::api::v1::audio::VoiceSynthesisConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::VoiceSynthesisConfig* config);
  private:
  const ::sensory::api::v1::audio::VoiceSynthesisConfig& _internal_config() const;
  ::sensory::api::v1::audio::VoiceSynthesisConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::VoiceSynthesisConfig* config);
  ::sensory::api::v1::audio::VoiceSynthesisConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.SynthesizeSpeechRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phrase_;
  ::sensory::api::v1::audio::VoiceSynthesisConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrollmentResponse) */ {
 public:
  inline CreateEnrollmentResponse() : CreateEnrollmentResponse(nullptr) {}
  ~CreateEnrollmentResponse() override;
  explicit constexpr CreateEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentResponse(const CreateEnrollmentResponse& from);
  CreateEnrollmentResponse(CreateEnrollmentResponse&& from) noexcept
    : CreateEnrollmentResponse() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentResponse& operator=(const CreateEnrollmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentResponse& operator=(CreateEnrollmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateEnrollmentResponse* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentResponse*>(
               &_CreateEnrollmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateEnrollmentResponse& a, CreateEnrollmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentResponse* New() const final {
    return new CreateEnrollmentResponse();
  }

  CreateEnrollmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrollmentResponse";
  }
  protected:
  explicit CreateEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdFieldNumber = 3,
    kModelNameFieldNumber = 4,
    kModelVersionFieldNumber = 5,
    kModelPromptFieldNumber = 6,
    kEnrollmentTokenFieldNumber = 8,
    kPercentCompleteFieldNumber = 1,
    kPercentSegmentCompleteFieldNumber = 7,
    kAudioEnergyFieldNumber = 2,
  };
  // string enrollmentId = 3;
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string modelName = 4;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string modelVersion = 5;
  void clear_modelversion();
  const std::string& modelversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelversion();
  void set_allocated_modelversion(std::string* modelversion);
  private:
  const std::string& _internal_modelversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelversion(const std::string& value);
  std::string* _internal_mutable_modelversion();
  public:

  // string modelPrompt = 6;
  void clear_modelprompt();
  const std::string& modelprompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelprompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelprompt();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelprompt();
  void set_allocated_modelprompt(std::string* modelprompt);
  private:
  const std::string& _internal_modelprompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelprompt(const std::string& value);
  std::string* _internal_mutable_modelprompt();
  public:

  // .sensory.api.common.EnrollmentToken enrollmentToken = 8;
  bool has_enrollmenttoken() const;
  private:
  bool _internal_has_enrollmenttoken() const;
  public:
  void clear_enrollmenttoken();
  const ::sensory::api::common::EnrollmentToken& enrollmenttoken() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::EnrollmentToken* release_enrollmenttoken();
  ::sensory::api::common::EnrollmentToken* mutable_enrollmenttoken();
  void set_allocated_enrollmenttoken(::sensory::api::common::EnrollmentToken* enrollmenttoken);
  private:
  const ::sensory::api::common::EnrollmentToken& _internal_enrollmenttoken() const;
  ::sensory::api::common::EnrollmentToken* _internal_mutable_enrollmenttoken();
  public:
  void unsafe_arena_set_allocated_enrollmenttoken(
      ::sensory::api::common::EnrollmentToken* enrollmenttoken);
  ::sensory::api::common::EnrollmentToken* unsafe_arena_release_enrollmenttoken();

  // int64 percentComplete = 1;
  void clear_percentcomplete();
  ::PROTOBUF_NAMESPACE_ID::int64 percentcomplete() const;
  void set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_percentcomplete() const;
  void _internal_set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 percentSegmentComplete = 7;
  void clear_percentsegmentcomplete();
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete() const;
  void set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_percentsegmentcomplete() const;
  void _internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float audioEnergy = 2;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrollmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelprompt_;
  ::sensory::api::common::EnrollmentToken* enrollmenttoken_;
  ::PROTOBUF_NAMESPACE_ID::int64 percentcomplete_;
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete_;
  float audioenergy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AuthenticateResponse) */ {
 public:
  inline AuthenticateResponse() : AuthenticateResponse(nullptr) {}
  ~AuthenticateResponse() override;
  explicit constexpr AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateResponse(const AuthenticateResponse& from);
  AuthenticateResponse(AuthenticateResponse&& from) noexcept
    : AuthenticateResponse() {
    *this = ::std::move(from);
  }

  inline AuthenticateResponse& operator=(const AuthenticateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateResponse& operator=(AuthenticateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateResponse* internal_default_instance() {
    return reinterpret_cast<const AuthenticateResponse*>(
               &_AuthenticateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AuthenticateResponse& a, AuthenticateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateResponse* New() const final {
    return new AuthenticateResponse();
  }

  AuthenticateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AuthenticateResponse";
  }
  protected:
  explicit AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 4,
    kEnrollmentIdFieldNumber = 5,
    kModelPromptFieldNumber = 6,
    kTokenFieldNumber = 3,
    kAudioEnergyFieldNumber = 1,
    kSuccessFieldNumber = 2,
    kPercentSegmentCompleteFieldNumber = 7,
  };
  // string userId = 4;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string enrollmentId = 5;
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string modelPrompt = 6;
  void clear_modelprompt();
  const std::string& modelprompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelprompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelprompt();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelprompt();
  void set_allocated_modelprompt(std::string* modelprompt);
  private:
  const std::string& _internal_modelprompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelprompt(const std::string& value);
  std::string* _internal_mutable_modelprompt();
  public:

  // .sensory.api.common.TokenResponse token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::sensory::api::common::TokenResponse& token() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::common::TokenResponse* release_token();
  ::sensory::api::common::TokenResponse* mutable_token();
  void set_allocated_token(::sensory::api::common::TokenResponse* token);
  private:
  const ::sensory::api::common::TokenResponse& _internal_token() const;
  ::sensory::api::common::TokenResponse* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::sensory::api::common::TokenResponse* token);
  ::sensory::api::common::TokenResponse* unsafe_arena_release_token();

  // float audioEnergy = 1;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int64 percentSegmentComplete = 7;
  void clear_percentsegmentcomplete();
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete() const;
  void set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_percentsegmentcomplete() const;
  void _internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AuthenticateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelprompt_;
  ::sensory::api::common::TokenResponse* token_;
  float audioenergy_;
  bool success_;
  ::PROTOBUF_NAMESPACE_ID::int64 percentsegmentcomplete_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEventResponse) */ {
 public:
  inline ValidateEventResponse() : ValidateEventResponse(nullptr) {}
  ~ValidateEventResponse() override;
  explicit constexpr ValidateEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEventResponse(const ValidateEventResponse& from);
  ValidateEventResponse(ValidateEventResponse&& from) noexcept
    : ValidateEventResponse() {
    *this = ::std::move(from);
  }

  inline ValidateEventResponse& operator=(const ValidateEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEventResponse& operator=(ValidateEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateEventResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateEventResponse*>(
               &_ValidateEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ValidateEventResponse& a, ValidateEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEventResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEventResponse* New() const final {
    return new ValidateEventResponse();
  }

  ValidateEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEventResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEventResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEventResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEventResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEventResponse";
  }
  protected:
  explicit ValidateEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 3,
    kPostProcessingActionFieldNumber = 10,
    kAudioEnergyFieldNumber = 1,
    kSuccessFieldNumber = 2,
    kScoreFieldNumber = 4,
  };
  // string resultId = 3;
  void clear_resultid();
  const std::string& resultid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resultid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resultid();
  PROTOBUF_MUST_USE_RESULT std::string* release_resultid();
  void set_allocated_resultid(std::string* resultid);
  private:
  const std::string& _internal_resultid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resultid(const std::string& value);
  std::string* _internal_mutable_resultid();
  public:

  // .sensory.api.v1.audio.AudioResponsePostProcessingAction postProcessingAction = 10;
  bool has_postprocessingaction() const;
  private:
  bool _internal_has_postprocessingaction() const;
  public:
  void clear_postprocessingaction();
  const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& postprocessingaction() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioResponsePostProcessingAction* release_postprocessingaction();
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* mutable_postprocessingaction();
  void set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction);
  private:
  const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& _internal_postprocessingaction() const;
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* _internal_mutable_postprocessingaction();
  public:
  void unsafe_arena_set_allocated_postprocessingaction(
      ::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction);
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* unsafe_arena_release_postprocessingaction();

  // float audioEnergy = 1;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // float score = 4;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resultid_;
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction_;
  float audioenergy_;
  bool success_;
  float score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEnrolledEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEnrolledEventResponse) */ {
 public:
  inline ValidateEnrolledEventResponse() : ValidateEnrolledEventResponse(nullptr) {}
  ~ValidateEnrolledEventResponse() override;
  explicit constexpr ValidateEnrolledEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEnrolledEventResponse(const ValidateEnrolledEventResponse& from);
  ValidateEnrolledEventResponse(ValidateEnrolledEventResponse&& from) noexcept
    : ValidateEnrolledEventResponse() {
    *this = ::std::move(from);
  }

  inline ValidateEnrolledEventResponse& operator=(const ValidateEnrolledEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEnrolledEventResponse& operator=(ValidateEnrolledEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEnrolledEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateEnrolledEventResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateEnrolledEventResponse*>(
               &_ValidateEnrolledEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ValidateEnrolledEventResponse& a, ValidateEnrolledEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEnrolledEventResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEnrolledEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEnrolledEventResponse* New() const final {
    return new ValidateEnrolledEventResponse();
  }

  ValidateEnrolledEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEnrolledEventResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEnrolledEventResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEnrolledEventResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEnrolledEventResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEnrolledEventResponse";
  }
  protected:
  explicit ValidateEnrolledEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentIdFieldNumber = 3,
    kUserIdFieldNumber = 4,
    kModelPromptFieldNumber = 5,
    kAudioEnergyFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string enrollmentId = 3;
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string userId = 4;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string modelPrompt = 5;
  void clear_modelprompt();
  const std::string& modelprompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelprompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelprompt();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelprompt();
  void set_allocated_modelprompt(std::string* modelprompt);
  private:
  const std::string& _internal_modelprompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelprompt(const std::string& value);
  std::string* _internal_mutable_modelprompt();
  public:

  // float audioEnergy = 1;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEnrolledEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelprompt_;
  float audioenergy_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeWord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeWord) */ {
 public:
  inline TranscribeWord() : TranscribeWord(nullptr) {}
  ~TranscribeWord() override;
  explicit constexpr TranscribeWord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeWord(const TranscribeWord& from);
  TranscribeWord(TranscribeWord&& from) noexcept
    : TranscribeWord() {
    *this = ::std::move(from);
  }

  inline TranscribeWord& operator=(const TranscribeWord& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeWord& operator=(TranscribeWord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeWord& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscribeWord* internal_default_instance() {
    return reinterpret_cast<const TranscribeWord*>(
               &_TranscribeWord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TranscribeWord& a, TranscribeWord& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeWord* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeWord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeWord* New() const final {
    return new TranscribeWord();
  }

  TranscribeWord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeWord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeWord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeWord& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeWord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeWord";
  }
  protected:
  explicit TranscribeWord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordFieldNumber = 6,
    kBegintimeMsFieldNumber = 1,
    kEndtimeMsFieldNumber = 2,
    kConfidenceFieldNumber = 3,
    kWordStateFieldNumber = 4,
    kWordIndexFieldNumber = 5,
  };
  // string word = 6;
  void clear_word();
  const std::string& word() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_word(ArgT0&& arg0, ArgT... args);
  std::string* mutable_word();
  PROTOBUF_MUST_USE_RESULT std::string* release_word();
  void set_allocated_word(std::string* word);
  private:
  const std::string& _internal_word() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_word(const std::string& value);
  std::string* _internal_mutable_word();
  public:

  // uint64 begintimeMs = 1;
  void clear_begintimems();
  ::PROTOBUF_NAMESPACE_ID::uint64 begintimems() const;
  void set_begintimems(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_begintimems() const;
  void _internal_set_begintimems(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 endtimeMs = 2;
  void clear_endtimems();
  ::PROTOBUF_NAMESPACE_ID::uint64 endtimems() const;
  void set_endtimems(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_endtimems() const;
  void _internal_set_endtimems(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float confidence = 3;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // .sensory.api.v1.audio.WordState wordState = 4;
  void clear_wordstate();
  ::sensory::api::v1::audio::WordState wordstate() const;
  void set_wordstate(::sensory::api::v1::audio::WordState value);
  private:
  ::sensory::api::v1::audio::WordState _internal_wordstate() const;
  void _internal_set_wordstate(::sensory::api::v1::audio::WordState value);
  public:

  // uint64 wordIndex = 5;
  void clear_wordindex();
  ::PROTOBUF_NAMESPACE_ID::uint64 wordindex() const;
  void set_wordindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_wordindex() const;
  void _internal_set_wordindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeWord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  ::PROTOBUF_NAMESPACE_ID::uint64 begintimems_;
  ::PROTOBUF_NAMESPACE_ID::uint64 endtimems_;
  float confidence_;
  int wordstate_;
  ::PROTOBUF_NAMESPACE_ID::uint64 wordindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeWordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeWordResponse) */ {
 public:
  inline TranscribeWordResponse() : TranscribeWordResponse(nullptr) {}
  ~TranscribeWordResponse() override;
  explicit constexpr TranscribeWordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeWordResponse(const TranscribeWordResponse& from);
  TranscribeWordResponse(TranscribeWordResponse&& from) noexcept
    : TranscribeWordResponse() {
    *this = ::std::move(from);
  }

  inline TranscribeWordResponse& operator=(const TranscribeWordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeWordResponse& operator=(TranscribeWordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeWordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscribeWordResponse* internal_default_instance() {
    return reinterpret_cast<const TranscribeWordResponse*>(
               &_TranscribeWordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TranscribeWordResponse& a, TranscribeWordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeWordResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeWordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeWordResponse* New() const final {
    return new TranscribeWordResponse();
  }

  TranscribeWordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeWordResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeWordResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeWordResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeWordResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeWordResponse";
  }
  protected:
  explicit TranscribeWordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordsFieldNumber = 1,
    kFirstWordIndexFieldNumber = 2,
    kLastWordIndexFieldNumber = 3,
  };
  // repeated .sensory.api.v1.audio.TranscribeWord words = 1;
  int words_size() const;
  private:
  int _internal_words_size() const;
  public:
  void clear_words();
  ::sensory::api::v1::audio::TranscribeWord* mutable_words(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::TranscribeWord >*
      mutable_words();
  private:
  const ::sensory::api::v1::audio::TranscribeWord& _internal_words(int index) const;
  ::sensory::api::v1::audio::TranscribeWord* _internal_add_words();
  public:
  const ::sensory::api::v1::audio::TranscribeWord& words(int index) const;
  ::sensory::api::v1::audio::TranscribeWord* add_words();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::TranscribeWord >&
      words() const;

  // uint64 firstWordIndex = 2;
  void clear_firstwordindex();
  ::PROTOBUF_NAMESPACE_ID::uint64 firstwordindex() const;
  void set_firstwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_firstwordindex() const;
  void _internal_set_firstwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 lastWordIndex = 3;
  void clear_lastwordindex();
  ::PROTOBUF_NAMESPACE_ID::uint64 lastwordindex() const;
  void set_lastwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_lastwordindex() const;
  void _internal_set_lastwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeWordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::TranscribeWord > words_;
  ::PROTOBUF_NAMESPACE_ID::uint64 firstwordindex_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lastwordindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeResponse) */ {
 public:
  inline TranscribeResponse() : TranscribeResponse(nullptr) {}
  ~TranscribeResponse() override;
  explicit constexpr TranscribeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeResponse(const TranscribeResponse& from);
  TranscribeResponse(TranscribeResponse&& from) noexcept
    : TranscribeResponse() {
    *this = ::std::move(from);
  }

  inline TranscribeResponse& operator=(const TranscribeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeResponse& operator=(TranscribeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscribeResponse* internal_default_instance() {
    return reinterpret_cast<const TranscribeResponse*>(
               &_TranscribeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TranscribeResponse& a, TranscribeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeResponse* New() const final {
    return new TranscribeResponse();
  }

  TranscribeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeResponse";
  }
  protected:
  explicit TranscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranscriptFieldNumber = 2,
    kWordListFieldNumber = 4,
    kPostProcessingActionFieldNumber = 10,
    kAudioEnergyFieldNumber = 1,
    kIsPartialResultFieldNumber = 3,
  };
  // string transcript = 2;
  void clear_transcript();
  const std::string& transcript() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcript(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcript();
  PROTOBUF_MUST_USE_RESULT std::string* release_transcript();
  void set_allocated_transcript(std::string* transcript);
  private:
  const std::string& _internal_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcript(const std::string& value);
  std::string* _internal_mutable_transcript();
  public:

  // .sensory.api.v1.audio.TranscribeWordResponse wordList = 4;
  bool has_wordlist() const;
  private:
  bool _internal_has_wordlist() const;
  public:
  void clear_wordlist();
  const ::sensory::api::v1::audio::TranscribeWordResponse& wordlist() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::TranscribeWordResponse* release_wordlist();
  ::sensory::api::v1::audio::TranscribeWordResponse* mutable_wordlist();
  void set_allocated_wordlist(::sensory::api::v1::audio::TranscribeWordResponse* wordlist);
  private:
  const ::sensory::api::v1::audio::TranscribeWordResponse& _internal_wordlist() const;
  ::sensory::api::v1::audio::TranscribeWordResponse* _internal_mutable_wordlist();
  public:
  void unsafe_arena_set_allocated_wordlist(
      ::sensory::api::v1::audio::TranscribeWordResponse* wordlist);
  ::sensory::api::v1::audio::TranscribeWordResponse* unsafe_arena_release_wordlist();

  // .sensory.api.v1.audio.AudioResponsePostProcessingAction postProcessingAction = 10;
  bool has_postprocessingaction() const;
  private:
  bool _internal_has_postprocessingaction() const;
  public:
  void clear_postprocessingaction();
  const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& postprocessingaction() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioResponsePostProcessingAction* release_postprocessingaction();
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* mutable_postprocessingaction();
  void set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction);
  private:
  const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& _internal_postprocessingaction() const;
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* _internal_mutable_postprocessingaction();
  public:
  void unsafe_arena_set_allocated_postprocessingaction(
      ::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction);
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* unsafe_arena_release_postprocessingaction();

  // float audioEnergy = 1;
  void clear_audioenergy();
  float audioenergy() const;
  void set_audioenergy(float value);
  private:
  float _internal_audioenergy() const;
  void _internal_set_audioenergy(float value);
  public:

  // bool isPartialResult = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_ispartialresult();
  PROTOBUF_DEPRECATED bool ispartialresult() const;
  PROTOBUF_DEPRECATED void set_ispartialresult(bool value);
  private:
  bool _internal_ispartialresult() const;
  void _internal_set_ispartialresult(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcript_;
  ::sensory::api::v1::audio::TranscribeWordResponse* wordlist_;
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction_;
  float audioenergy_;
  bool ispartialresult_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class SynthesizeSpeechResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.SynthesizeSpeechResponse) */ {
 public:
  inline SynthesizeSpeechResponse() : SynthesizeSpeechResponse(nullptr) {}
  ~SynthesizeSpeechResponse() override;
  explicit constexpr SynthesizeSpeechResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeSpeechResponse(const SynthesizeSpeechResponse& from);
  SynthesizeSpeechResponse(SynthesizeSpeechResponse&& from) noexcept
    : SynthesizeSpeechResponse() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechResponse& operator=(const SynthesizeSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeSpeechResponse& operator=(SynthesizeSpeechResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeSpeechResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingResponseCase {
    kConfig = 1,
    kAudioContent = 2,
    STREAMINGRESPONSE_NOT_SET = 0,
  };

  static inline const SynthesizeSpeechResponse* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechResponse*>(
               &_SynthesizeSpeechResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SynthesizeSpeechResponse& a, SynthesizeSpeechResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeSpeechResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeSpeechResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SynthesizeSpeechResponse* New() const final {
    return new SynthesizeSpeechResponse();
  }

  SynthesizeSpeechResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SynthesizeSpeechResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeSpeechResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SynthesizeSpeechResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeSpeechResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.SynthesizeSpeechResponse";
  }
  protected:
  explicit SynthesizeSpeechResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .sensory.api.v1.audio.AudioConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::sensory::api::v1::audio::AudioConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_config();
  ::sensory::api::v1::audio::AudioConfig* mutable_config();
  void set_allocated_config(::sensory::api::v1::audio::AudioConfig* config);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_config() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::sensory::api::v1::audio::AudioConfig* config);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_config();

  // bytes audioContent = 2;
  bool has_audiocontent() const;
  private:
  bool _internal_has_audiocontent() const;
  public:
  void clear_audiocontent();
  const std::string& audiocontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audiocontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audiocontent();
  PROTOBUF_MUST_USE_RESULT std::string* release_audiocontent();
  void set_allocated_audiocontent(std::string* audiocontent);
  private:
  const std::string& _internal_audiocontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audiocontent(const std::string& value);
  std::string* _internal_mutable_audiocontent();
  public:

  void clear_streamingResponse();
  StreamingResponseCase streamingResponse_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.SynthesizeSpeechResponse)
 private:
  class _Internal;
  void set_has_config();
  void set_has_audiocontent();

  inline bool has_streamingResponse() const;
  inline void clear_has_streamingResponse();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamingResponseUnion {
    constexpr StreamingResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sensory::api::v1::audio::AudioConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiocontent_;
  } streamingResponse_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrollmentConfig) */ {
 public:
  inline CreateEnrollmentConfig() : CreateEnrollmentConfig(nullptr) {}
  ~CreateEnrollmentConfig() override;
  explicit constexpr CreateEnrollmentConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentConfig(const CreateEnrollmentConfig& from);
  CreateEnrollmentConfig(CreateEnrollmentConfig&& from) noexcept
    : CreateEnrollmentConfig() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentConfig& operator=(const CreateEnrollmentConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentConfig& operator=(CreateEnrollmentConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentConfig& default_instance() {
    return *internal_default_instance();
  }
  enum EnrollLengthCase {
    kEnrollmentNumUtterances = 7,
    kEnrollmentDuration = 8,
    ENROLLLENGTH_NOT_SET = 0,
  };

  static inline const CreateEnrollmentConfig* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentConfig*>(
               &_CreateEnrollmentConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateEnrollmentConfig& a, CreateEnrollmentConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentConfig* New() const final {
    return new CreateEnrollmentConfig();
  }

  CreateEnrollmentConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrollmentConfig";
  }
  protected:
  explicit CreateEnrollmentConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kModelNameFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kReferenceIdFieldNumber = 9,
    kAudioFieldNumber = 1,
    kIsLivenessEnabledFieldNumber = 6,
    kDisableServerEnrollmentTemplateStorageFieldNumber = 10,
    kEnrollmentNumUtterancesFieldNumber = 7,
    kEnrollmentDurationFieldNumber = 8,
  };
  // string userId = 2 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceId = 3 [(.validate.rules) = {
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_MUST_USE_RESULT std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string modelName = 4 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string description = 5 [(.validate.rules) = {
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string referenceId = 9 [(.validate.rules) = {
  void clear_referenceid();
  const std::string& referenceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referenceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referenceid();
  PROTOBUF_MUST_USE_RESULT std::string* release_referenceid();
  void set_allocated_referenceid(std::string* referenceid);
  private:
  const std::string& _internal_referenceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referenceid(const std::string& value);
  std::string* _internal_mutable_referenceid();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // bool isLivenessEnabled = 6;
  void clear_islivenessenabled();
  bool islivenessenabled() const;
  void set_islivenessenabled(bool value);
  private:
  bool _internal_islivenessenabled() const;
  void _internal_set_islivenessenabled(bool value);
  public:

  // bool disableServerEnrollmentTemplateStorage = 10;
  void clear_disableserverenrollmenttemplatestorage();
  bool disableserverenrollmenttemplatestorage() const;
  void set_disableserverenrollmenttemplatestorage(bool value);
  private:
  bool _internal_disableserverenrollmenttemplatestorage() const;
  void _internal_set_disableserverenrollmenttemplatestorage(bool value);
  public:

  // uint32 enrollmentNumUtterances = 7 [(.validate.rules) = {
  bool has_enrollmentnumutterances() const;
  private:
  bool _internal_has_enrollmentnumutterances() const;
  public:
  void clear_enrollmentnumutterances();
  ::PROTOBUF_NAMESPACE_ID::uint32 enrollmentnumutterances() const;
  void set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_enrollmentnumutterances() const;
  void _internal_set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float enrollmentDuration = 8 [(.validate.rules) = {
  bool has_enrollmentduration() const;
  private:
  bool _internal_has_enrollmentduration() const;
  public:
  void clear_enrollmentduration();
  float enrollmentduration() const;
  void set_enrollmentduration(float value);
  private:
  float _internal_enrollmentduration() const;
  void _internal_set_enrollmentduration(float value);
  public:

  void clear_enrollLength();
  EnrollLengthCase enrollLength_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrollmentConfig)
 private:
  class _Internal;
  void set_has_enrollmentnumutterances();
  void set_has_enrollmentduration();

  inline bool has_enrollLength() const;
  inline void clear_has_enrollLength();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referenceid_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  bool islivenessenabled_;
  bool disableserverenrollmenttemplatestorage_;
  union EnrollLengthUnion {
    constexpr EnrollLengthUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 enrollmentnumutterances_;
    float enrollmentduration_;
  } enrollLength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AuthenticateConfig) */ {
 public:
  inline AuthenticateConfig() : AuthenticateConfig(nullptr) {}
  ~AuthenticateConfig() override;
  explicit constexpr AuthenticateConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateConfig(const AuthenticateConfig& from);
  AuthenticateConfig(AuthenticateConfig&& from) noexcept
    : AuthenticateConfig() {
    *this = ::std::move(from);
  }

  inline AuthenticateConfig& operator=(const AuthenticateConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateConfig& operator=(AuthenticateConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateConfig& default_instance() {
    return *internal_default_instance();
  }
  enum AuthIdCase {
    kEnrollmentId = 2,
    kEnrollmentGroupId = 3,
    AUTHID_NOT_SET = 0,
  };

  static inline const AuthenticateConfig* internal_default_instance() {
    return reinterpret_cast<const AuthenticateConfig*>(
               &_AuthenticateConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AuthenticateConfig& a, AuthenticateConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateConfig* New() const final {
    return new AuthenticateConfig();
  }

  AuthenticateConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AuthenticateConfig";
  }
  protected:
  explicit AuthenticateConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AuthenticateConfig_ThresholdSecurity ThresholdSecurity;
  static constexpr ThresholdSecurity HIGH =
    AuthenticateConfig_ThresholdSecurity_HIGH;
  static constexpr ThresholdSecurity LOW =
    AuthenticateConfig_ThresholdSecurity_LOW;
  static inline bool ThresholdSecurity_IsValid(int value) {
    return AuthenticateConfig_ThresholdSecurity_IsValid(value);
  }
  static constexpr ThresholdSecurity ThresholdSecurity_MIN =
    AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MIN;
  static constexpr ThresholdSecurity ThresholdSecurity_MAX =
    AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_MAX;
  static constexpr int ThresholdSecurity_ARRAYSIZE =
    AuthenticateConfig_ThresholdSecurity_ThresholdSecurity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ThresholdSecurity_descriptor() {
    return AuthenticateConfig_ThresholdSecurity_descriptor();
  }
  template<typename T>
  static inline const std::string& ThresholdSecurity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ThresholdSecurity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ThresholdSecurity_Name.");
    return AuthenticateConfig_ThresholdSecurity_Name(enum_t_value);
  }
  static inline bool ThresholdSecurity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ThresholdSecurity* value) {
    return AuthenticateConfig_ThresholdSecurity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentTokenFieldNumber = 8,
    kAudioFieldNumber = 1,
    kSensitivityFieldNumber = 5,
    kDoIncludeTokenFieldNumber = 4,
    kIsLivenessEnabledFieldNumber = 7,
    kSecurityFieldNumber = 6,
    kEnrollmentIdFieldNumber = 2,
    kEnrollmentGroupIdFieldNumber = 3,
  };
  // bytes enrollmentToken = 8;
  void clear_enrollmenttoken();
  const std::string& enrollmenttoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmenttoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmenttoken();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmenttoken();
  void set_allocated_enrollmenttoken(std::string* enrollmenttoken);
  private:
  const std::string& _internal_enrollmenttoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmenttoken(const std::string& value);
  std::string* _internal_mutable_enrollmenttoken();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 5 [(.validate.rules) = {
  void clear_sensitivity();
  ::sensory::api::v1::audio::ThresholdSensitivity sensitivity() const;
  void set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  private:
  ::sensory::api::v1::audio::ThresholdSensitivity _internal_sensitivity() const;
  void _internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  public:

  // bool doIncludeToken = 4;
  void clear_doincludetoken();
  bool doincludetoken() const;
  void set_doincludetoken(bool value);
  private:
  bool _internal_doincludetoken() const;
  void _internal_set_doincludetoken(bool value);
  public:

  // bool isLivenessEnabled = 7;
  void clear_islivenessenabled();
  bool islivenessenabled() const;
  void set_islivenessenabled(bool value);
  private:
  bool _internal_islivenessenabled() const;
  void _internal_set_islivenessenabled(bool value);
  public:

  // .sensory.api.v1.audio.AuthenticateConfig.ThresholdSecurity security = 6 [(.validate.rules) = {
  void clear_security();
  ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity security() const;
  void set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value);
  private:
  ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity _internal_security() const;
  void _internal_set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value);
  public:

  // string enrollmentId = 2 [(.validate.rules) = {
  bool has_enrollmentid() const;
  private:
  bool _internal_has_enrollmentid() const;
  public:
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string enrollmentGroupId = 3;
  bool has_enrollmentgroupid() const;
  private:
  bool _internal_has_enrollmentgroupid() const;
  public:
  void clear_enrollmentgroupid();
  const std::string& enrollmentgroupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentgroupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentgroupid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentgroupid();
  void set_allocated_enrollmentgroupid(std::string* enrollmentgroupid);
  private:
  const std::string& _internal_enrollmentgroupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentgroupid(const std::string& value);
  std::string* _internal_mutable_enrollmentgroupid();
  public:

  void clear_authId();
  AuthIdCase authId_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AuthenticateConfig)
 private:
  class _Internal;
  void set_has_enrollmentid();
  void set_has_enrollmentgroupid();

  inline bool has_authId() const;
  inline void clear_has_authId();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmenttoken_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  int sensitivity_;
  bool doincludetoken_;
  bool islivenessenabled_;
  int security_;
  union AuthIdUnion {
    constexpr AuthIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentgroupid_;
  } authId_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEventConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEventConfig) */ {
 public:
  inline ValidateEventConfig() : ValidateEventConfig(nullptr) {}
  ~ValidateEventConfig() override;
  explicit constexpr ValidateEventConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEventConfig(const ValidateEventConfig& from);
  ValidateEventConfig(ValidateEventConfig&& from) noexcept
    : ValidateEventConfig() {
    *this = ::std::move(from);
  }

  inline ValidateEventConfig& operator=(const ValidateEventConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEventConfig& operator=(ValidateEventConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEventConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateEventConfig* internal_default_instance() {
    return reinterpret_cast<const ValidateEventConfig*>(
               &_ValidateEventConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ValidateEventConfig& a, ValidateEventConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEventConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEventConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEventConfig* New() const final {
    return new ValidateEventConfig();
  }

  ValidateEventConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEventConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEventConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEventConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEventConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEventConfig";
  }
  protected:
  explicit ValidateEventConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kAudioFieldNumber = 1,
    kSensitivityFieldNumber = 4,
  };
  // string modelName = 2 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string userId = 3 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 4 [(.validate.rules) = {
  void clear_sensitivity();
  ::sensory::api::v1::audio::ThresholdSensitivity sensitivity() const;
  void set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  private:
  ::sensory::api::v1::audio::ThresholdSensitivity _internal_sensitivity() const;
  void _internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEventConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  int sensitivity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class CreateEnrollmentEventConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.CreateEnrollmentEventConfig) */ {
 public:
  inline CreateEnrollmentEventConfig() : CreateEnrollmentEventConfig(nullptr) {}
  ~CreateEnrollmentEventConfig() override;
  explicit constexpr CreateEnrollmentEventConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEnrollmentEventConfig(const CreateEnrollmentEventConfig& from);
  CreateEnrollmentEventConfig(CreateEnrollmentEventConfig&& from) noexcept
    : CreateEnrollmentEventConfig() {
    *this = ::std::move(from);
  }

  inline CreateEnrollmentEventConfig& operator=(const CreateEnrollmentEventConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEnrollmentEventConfig& operator=(CreateEnrollmentEventConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEnrollmentEventConfig& default_instance() {
    return *internal_default_instance();
  }
  enum EnrollLengthCase {
    kEnrollmentNumUtterances = 5,
    kEnrollmentDuration = 6,
    ENROLLLENGTH_NOT_SET = 0,
  };

  static inline const CreateEnrollmentEventConfig* internal_default_instance() {
    return reinterpret_cast<const CreateEnrollmentEventConfig*>(
               &_CreateEnrollmentEventConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CreateEnrollmentEventConfig& a, CreateEnrollmentEventConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEnrollmentEventConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEnrollmentEventConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEnrollmentEventConfig* New() const final {
    return new CreateEnrollmentEventConfig();
  }

  CreateEnrollmentEventConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEnrollmentEventConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEnrollmentEventConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateEnrollmentEventConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEnrollmentEventConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.CreateEnrollmentEventConfig";
  }
  protected:
  explicit CreateEnrollmentEventConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kModelNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kReferenceIdFieldNumber = 7,
    kAudioFieldNumber = 1,
    kEnrollmentNumUtterancesFieldNumber = 5,
    kEnrollmentDurationFieldNumber = 6,
  };
  // string userId = 2 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string modelName = 3 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string description = 4 [(.validate.rules) = {
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string referenceId = 7 [(.validate.rules) = {
  void clear_referenceid();
  const std::string& referenceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referenceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referenceid();
  PROTOBUF_MUST_USE_RESULT std::string* release_referenceid();
  void set_allocated_referenceid(std::string* referenceid);
  private:
  const std::string& _internal_referenceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referenceid(const std::string& value);
  std::string* _internal_mutable_referenceid();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // uint32 enrollmentNumUtterances = 5 [(.validate.rules) = {
  bool has_enrollmentnumutterances() const;
  private:
  bool _internal_has_enrollmentnumutterances() const;
  public:
  void clear_enrollmentnumutterances();
  ::PROTOBUF_NAMESPACE_ID::uint32 enrollmentnumutterances() const;
  void set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_enrollmentnumutterances() const;
  void _internal_set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float enrollmentDuration = 6 [(.validate.rules) = {
  bool has_enrollmentduration() const;
  private:
  bool _internal_has_enrollmentduration() const;
  public:
  void clear_enrollmentduration();
  float enrollmentduration() const;
  void set_enrollmentduration(float value);
  private:
  float _internal_enrollmentduration() const;
  void _internal_set_enrollmentduration(float value);
  public:

  void clear_enrollLength();
  EnrollLengthCase enrollLength_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.CreateEnrollmentEventConfig)
 private:
  class _Internal;
  void set_has_enrollmentnumutterances();
  void set_has_enrollmentduration();

  inline bool has_enrollLength() const;
  inline void clear_has_enrollLength();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referenceid_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  union EnrollLengthUnion {
    constexpr EnrollLengthUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint32 enrollmentnumutterances_;
    float enrollmentduration_;
  } enrollLength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class ValidateEnrolledEventConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.ValidateEnrolledEventConfig) */ {
 public:
  inline ValidateEnrolledEventConfig() : ValidateEnrolledEventConfig(nullptr) {}
  ~ValidateEnrolledEventConfig() override;
  explicit constexpr ValidateEnrolledEventConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateEnrolledEventConfig(const ValidateEnrolledEventConfig& from);
  ValidateEnrolledEventConfig(ValidateEnrolledEventConfig&& from) noexcept
    : ValidateEnrolledEventConfig() {
    *this = ::std::move(from);
  }

  inline ValidateEnrolledEventConfig& operator=(const ValidateEnrolledEventConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateEnrolledEventConfig& operator=(ValidateEnrolledEventConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateEnrolledEventConfig& default_instance() {
    return *internal_default_instance();
  }
  enum AuthIdCase {
    kEnrollmentId = 2,
    kEnrollmentGroupId = 3,
    AUTHID_NOT_SET = 0,
  };

  static inline const ValidateEnrolledEventConfig* internal_default_instance() {
    return reinterpret_cast<const ValidateEnrolledEventConfig*>(
               &_ValidateEnrolledEventConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ValidateEnrolledEventConfig& a, ValidateEnrolledEventConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateEnrolledEventConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateEnrolledEventConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateEnrolledEventConfig* New() const final {
    return new ValidateEnrolledEventConfig();
  }

  ValidateEnrolledEventConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateEnrolledEventConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateEnrolledEventConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateEnrolledEventConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateEnrolledEventConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.ValidateEnrolledEventConfig";
  }
  protected:
  explicit ValidateEnrolledEventConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnrollmentTokenFieldNumber = 5,
    kAudioFieldNumber = 1,
    kSensitivityFieldNumber = 4,
    kEnrollmentIdFieldNumber = 2,
    kEnrollmentGroupIdFieldNumber = 3,
  };
  // bytes enrollmentToken = 5;
  void clear_enrollmenttoken();
  const std::string& enrollmenttoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmenttoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmenttoken();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmenttoken();
  void set_allocated_enrollmenttoken(std::string* enrollmenttoken);
  private:
  const std::string& _internal_enrollmenttoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmenttoken(const std::string& value);
  std::string* _internal_mutable_enrollmenttoken();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 4 [(.validate.rules) = {
  void clear_sensitivity();
  ::sensory::api::v1::audio::ThresholdSensitivity sensitivity() const;
  void set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  private:
  ::sensory::api::v1::audio::ThresholdSensitivity _internal_sensitivity() const;
  void _internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value);
  public:

  // string enrollmentId = 2 [(.validate.rules) = {
  bool has_enrollmentid() const;
  private:
  bool _internal_has_enrollmentid() const;
  public:
  void clear_enrollmentid();
  const std::string& enrollmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentid();
  void set_allocated_enrollmentid(std::string* enrollmentid);
  private:
  const std::string& _internal_enrollmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentid(const std::string& value);
  std::string* _internal_mutable_enrollmentid();
  public:

  // string enrollmentGroupId = 3;
  bool has_enrollmentgroupid() const;
  private:
  bool _internal_has_enrollmentgroupid() const;
  public:
  void clear_enrollmentgroupid();
  const std::string& enrollmentgroupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enrollmentgroupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enrollmentgroupid();
  PROTOBUF_MUST_USE_RESULT std::string* release_enrollmentgroupid();
  void set_allocated_enrollmentgroupid(std::string* enrollmentgroupid);
  private:
  const std::string& _internal_enrollmentgroupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enrollmentgroupid(const std::string& value);
  std::string* _internal_mutable_enrollmentgroupid();
  public:

  void clear_authId();
  AuthIdCase authId_case() const;
  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.ValidateEnrolledEventConfig)
 private:
  class _Internal;
  void set_has_enrollmentid();
  void set_has_enrollmentgroupid();

  inline bool has_authId() const;
  inline void clear_has_authId();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmenttoken_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  int sensitivity_;
  union AuthIdUnion {
    constexpr AuthIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enrollmentgroupid_;
  } authId_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class TranscribeConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.TranscribeConfig) */ {
 public:
  inline TranscribeConfig() : TranscribeConfig(nullptr) {}
  ~TranscribeConfig() override;
  explicit constexpr TranscribeConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscribeConfig(const TranscribeConfig& from);
  TranscribeConfig(TranscribeConfig&& from) noexcept
    : TranscribeConfig() {
    *this = ::std::move(from);
  }

  inline TranscribeConfig& operator=(const TranscribeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscribeConfig& operator=(TranscribeConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscribeConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscribeConfig* internal_default_instance() {
    return reinterpret_cast<const TranscribeConfig*>(
               &_TranscribeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TranscribeConfig& a, TranscribeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscribeConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscribeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TranscribeConfig* New() const final {
    return new TranscribeConfig();
  }

  TranscribeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscribeConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscribeConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TranscribeConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscribeConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.TranscribeConfig";
  }
  protected:
  explicit TranscribeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kAudioFieldNumber = 1,
  };
  // string modelName = 2 [(.validate.rules) = {
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_MUST_USE_RESULT std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string userId = 3 [(.validate.rules) = {
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_MUST_USE_RESULT std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.TranscribeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  explicit constexpr AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioConfig* New() const final {
    return new AudioConfig();
  }

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AudioConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AudioConfig_AudioEncoding AudioEncoding;
  static constexpr AudioEncoding LINEAR16 =
    AudioConfig_AudioEncoding_LINEAR16;
  static constexpr AudioEncoding FLAC =
    AudioConfig_AudioEncoding_FLAC;
  static constexpr AudioEncoding MULAW =
    AudioConfig_AudioEncoding_MULAW;
  static inline bool AudioEncoding_IsValid(int value) {
    return AudioConfig_AudioEncoding_IsValid(value);
  }
  static constexpr AudioEncoding AudioEncoding_MIN =
    AudioConfig_AudioEncoding_AudioEncoding_MIN;
  static constexpr AudioEncoding AudioEncoding_MAX =
    AudioConfig_AudioEncoding_AudioEncoding_MAX;
  static constexpr int AudioEncoding_ARRAYSIZE =
    AudioConfig_AudioEncoding_AudioEncoding_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AudioEncoding_descriptor() {
    return AudioConfig_AudioEncoding_descriptor();
  }
  template<typename T>
  static inline const std::string& AudioEncoding_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AudioEncoding>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AudioEncoding_Name.");
    return AudioConfig_AudioEncoding_Name(enum_t_value);
  }
  static inline bool AudioEncoding_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AudioEncoding* value) {
    return AudioConfig_AudioEncoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageCodeFieldNumber = 4,
    kEncodingFieldNumber = 1,
    kSampleRateHertzFieldNumber = 2,
    kAudioChannelCountFieldNumber = 3,
  };
  // string languageCode = 4;
  void clear_languagecode();
  const std::string& languagecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_languagecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_languagecode();
  PROTOBUF_MUST_USE_RESULT std::string* release_languagecode();
  void set_allocated_languagecode(std::string* languagecode);
  private:
  const std::string& _internal_languagecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_languagecode(const std::string& value);
  std::string* _internal_mutable_languagecode();
  public:

  // .sensory.api.v1.audio.AudioConfig.AudioEncoding encoding = 1 [(.validate.rules) = {
  void clear_encoding();
  ::sensory::api::v1::audio::AudioConfig_AudioEncoding encoding() const;
  void set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value);
  private:
  ::sensory::api::v1::audio::AudioConfig_AudioEncoding _internal_encoding() const;
  void _internal_set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value);
  public:

  // int32 sampleRateHertz = 2 [(.validate.rules) = {
  void clear_sampleratehertz();
  ::PROTOBUF_NAMESPACE_ID::int32 sampleratehertz() const;
  void set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sampleratehertz() const;
  void _internal_set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 audioChannelCount = 3 [(.validate.rules) = {
  void clear_audiochannelcount();
  ::PROTOBUF_NAMESPACE_ID::int32 audiochannelcount() const;
  void set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_audiochannelcount() const;
  void _internal_set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr languagecode_;
  int encoding_;
  ::PROTOBUF_NAMESPACE_ID::int32 sampleratehertz_;
  ::PROTOBUF_NAMESPACE_ID::int32 audiochannelcount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// -------------------------------------------------------------------

class VoiceSynthesisConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensory.api.v1.audio.VoiceSynthesisConfig) */ {
 public:
  inline VoiceSynthesisConfig() : VoiceSynthesisConfig(nullptr) {}
  ~VoiceSynthesisConfig() override;
  explicit constexpr VoiceSynthesisConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoiceSynthesisConfig(const VoiceSynthesisConfig& from);
  VoiceSynthesisConfig(VoiceSynthesisConfig&& from) noexcept
    : VoiceSynthesisConfig() {
    *this = ::std::move(from);
  }

  inline VoiceSynthesisConfig& operator=(const VoiceSynthesisConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceSynthesisConfig& operator=(VoiceSynthesisConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceSynthesisConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoiceSynthesisConfig* internal_default_instance() {
    return reinterpret_cast<const VoiceSynthesisConfig*>(
               &_VoiceSynthesisConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(VoiceSynthesisConfig& a, VoiceSynthesisConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceSynthesisConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceSynthesisConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoiceSynthesisConfig* New() const final {
    return new VoiceSynthesisConfig();
  }

  VoiceSynthesisConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoiceSynthesisConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoiceSynthesisConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoiceSynthesisConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceSynthesisConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensory.api.v1.audio.VoiceSynthesisConfig";
  }
  protected:
  explicit VoiceSynthesisConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoiceFieldNumber = 2,
    kAudioFieldNumber = 1,
  };
  // string voice = 2 [(.validate.rules) = {
  void clear_voice();
  const std::string& voice() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voice(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voice();
  PROTOBUF_MUST_USE_RESULT std::string* release_voice();
  void set_allocated_voice(std::string* voice);
  private:
  const std::string& _internal_voice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice(const std::string& value);
  std::string* _internal_mutable_voice();
  public:

  // .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::sensory::api::v1::audio::AudioConfig& audio() const;
  PROTOBUF_MUST_USE_RESULT ::sensory::api::v1::audio::AudioConfig* release_audio();
  ::sensory::api::v1::audio::AudioConfig* mutable_audio();
  void set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio);
  private:
  const ::sensory::api::v1::audio::AudioConfig& _internal_audio() const;
  ::sensory::api::v1::audio::AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::sensory::api::v1::audio::AudioConfig* audio);
  ::sensory::api::v1::audio::AudioConfig* unsafe_arena_release_audio();

  // @@protoc_insertion_point(class_scope:sensory.api.v1.audio.VoiceSynthesisConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voice_;
  ::sensory::api::v1::audio::AudioConfig* audio_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_v1_2faudio_2faudio_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetModelsRequest

// -------------------------------------------------------------------

// AudioModel

// string name = 1;
inline void AudioModel::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AudioModel::name() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioModel::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.name)
}
inline std::string* AudioModel::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioModel.name)
  return _s;
}
inline const std::string& AudioModel::_internal_name() const {
  return name_.Get();
}
inline void AudioModel::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioModel::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioModel::release_name() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioModel.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioModel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioModel.name)
}

// bool isEnrollable = 2;
inline void AudioModel::clear_isenrollable() {
  isenrollable_ = false;
}
inline bool AudioModel::_internal_isenrollable() const {
  return isenrollable_;
}
inline bool AudioModel::isenrollable() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.isEnrollable)
  return _internal_isenrollable();
}
inline void AudioModel::_internal_set_isenrollable(bool value) {
  
  isenrollable_ = value;
}
inline void AudioModel::set_isenrollable(bool value) {
  _internal_set_isenrollable(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.isEnrollable)
}

// .sensory.api.common.ModelType modelType = 3;
inline void AudioModel::clear_modeltype() {
  modeltype_ = 0;
}
inline ::sensory::api::common::ModelType AudioModel::_internal_modeltype() const {
  return static_cast< ::sensory::api::common::ModelType >(modeltype_);
}
inline ::sensory::api::common::ModelType AudioModel::modeltype() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.modelType)
  return _internal_modeltype();
}
inline void AudioModel::_internal_set_modeltype(::sensory::api::common::ModelType value) {
  
  modeltype_ = value;
}
inline void AudioModel::set_modeltype(::sensory::api::common::ModelType value) {
  _internal_set_modeltype(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.modelType)
}

// string fixedPhrase = 4;
inline void AudioModel::clear_fixedphrase() {
  fixedphrase_.ClearToEmpty();
}
inline const std::string& AudioModel::fixedphrase() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.fixedPhrase)
  return _internal_fixedphrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioModel::set_fixedphrase(ArgT0&& arg0, ArgT... args) {
 
 fixedphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.fixedPhrase)
}
inline std::string* AudioModel::mutable_fixedphrase() {
  std::string* _s = _internal_mutable_fixedphrase();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioModel.fixedPhrase)
  return _s;
}
inline const std::string& AudioModel::_internal_fixedphrase() const {
  return fixedphrase_.Get();
}
inline void AudioModel::_internal_set_fixedphrase(const std::string& value) {
  
  fixedphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioModel::_internal_mutable_fixedphrase() {
  
  return fixedphrase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioModel::release_fixedphrase() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioModel.fixedPhrase)
  return fixedphrase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioModel::set_allocated_fixedphrase(std::string* fixedphrase) {
  if (fixedphrase != nullptr) {
    
  } else {
    
  }
  fixedphrase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fixedphrase,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioModel.fixedPhrase)
}

// int32 sampleRate = 5;
inline void AudioModel::clear_samplerate() {
  samplerate_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioModel::_internal_samplerate() const {
  return samplerate_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioModel::samplerate() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.sampleRate)
  return _internal_samplerate();
}
inline void AudioModel::_internal_set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  samplerate_ = value;
}
inline void AudioModel::set_samplerate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_samplerate(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.sampleRate)
}

// repeated string versions = 6;
inline int AudioModel::_internal_versions_size() const {
  return versions_.size();
}
inline int AudioModel::versions_size() const {
  return _internal_versions_size();
}
inline void AudioModel::clear_versions() {
  versions_.Clear();
}
inline std::string* AudioModel::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:sensory.api.v1.audio.AudioModel.versions)
  return _s;
}
inline const std::string& AudioModel::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline const std::string& AudioModel::versions(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.versions)
  return _internal_versions(index);
}
inline std::string* AudioModel::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioModel.versions)
  return versions_.Mutable(index);
}
inline void AudioModel::set_versions(int index, const std::string& value) {
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::set_versions(int index, std::string&& value) {
  versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::set_versions(int index, const char* value, size_t size) {
  versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sensory.api.v1.audio.AudioModel.versions)
}
inline std::string* AudioModel::_internal_add_versions() {
  return versions_.Add();
}
inline void AudioModel::add_versions(const std::string& value) {
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::add_versions(std::string&& value) {
  versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sensory.api.v1.audio.AudioModel.versions)
}
inline void AudioModel::add_versions(const char* value, size_t size) {
  versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sensory.api.v1.audio.AudioModel.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AudioModel::versions() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.audio.AudioModel.versions)
  return versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AudioModel::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.audio.AudioModel.versions)
  return &versions_;
}

// .sensory.api.common.TechnologyType technology = 7;
inline void AudioModel::clear_technology() {
  technology_ = 0;
}
inline ::sensory::api::common::TechnologyType AudioModel::_internal_technology() const {
  return static_cast< ::sensory::api::common::TechnologyType >(technology_);
}
inline ::sensory::api::common::TechnologyType AudioModel::technology() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.technology)
  return _internal_technology();
}
inline void AudioModel::_internal_set_technology(::sensory::api::common::TechnologyType value) {
  
  technology_ = value;
}
inline void AudioModel::set_technology(::sensory::api::common::TechnologyType value) {
  _internal_set_technology(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.technology)
}

// bool isLivenessSupported = 8;
inline void AudioModel::clear_islivenesssupported() {
  islivenesssupported_ = false;
}
inline bool AudioModel::_internal_islivenesssupported() const {
  return islivenesssupported_;
}
inline bool AudioModel::islivenesssupported() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioModel.isLivenessSupported)
  return _internal_islivenesssupported();
}
inline void AudioModel::_internal_set_islivenesssupported(bool value) {
  
  islivenesssupported_ = value;
}
inline void AudioModel::set_islivenesssupported(bool value) {
  _internal_set_islivenesssupported(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioModel.isLivenessSupported)
}

// -------------------------------------------------------------------

// AudioRequestPostProcessingAction

// string actionId = 1;
inline void AudioRequestPostProcessingAction::clear_actionid() {
  actionid_.ClearToEmpty();
}
inline const std::string& AudioRequestPostProcessingAction::actionid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioRequestPostProcessingAction.actionId)
  return _internal_actionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioRequestPostProcessingAction::set_actionid(ArgT0&& arg0, ArgT... args) {
 
 actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioRequestPostProcessingAction.actionId)
}
inline std::string* AudioRequestPostProcessingAction::mutable_actionid() {
  std::string* _s = _internal_mutable_actionid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioRequestPostProcessingAction.actionId)
  return _s;
}
inline const std::string& AudioRequestPostProcessingAction::_internal_actionid() const {
  return actionid_.Get();
}
inline void AudioRequestPostProcessingAction::_internal_set_actionid(const std::string& value) {
  
  actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioRequestPostProcessingAction::_internal_mutable_actionid() {
  
  return actionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioRequestPostProcessingAction::release_actionid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioRequestPostProcessingAction.actionId)
  return actionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioRequestPostProcessingAction::set_allocated_actionid(std::string* actionid) {
  if (actionid != nullptr) {
    
  } else {
    
  }
  actionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actionid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioRequestPostProcessingAction.actionId)
}

// .sensory.api.v1.audio.AudioPostProcessingAction action = 2 [(.validate.rules) = {
inline void AudioRequestPostProcessingAction::clear_action() {
  action_ = 0;
}
inline ::sensory::api::v1::audio::AudioPostProcessingAction AudioRequestPostProcessingAction::_internal_action() const {
  return static_cast< ::sensory::api::v1::audio::AudioPostProcessingAction >(action_);
}
inline ::sensory::api::v1::audio::AudioPostProcessingAction AudioRequestPostProcessingAction::action() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioRequestPostProcessingAction.action)
  return _internal_action();
}
inline void AudioRequestPostProcessingAction::_internal_set_action(::sensory::api::v1::audio::AudioPostProcessingAction value) {
  
  action_ = value;
}
inline void AudioRequestPostProcessingAction::set_action(::sensory::api::v1::audio::AudioPostProcessingAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioRequestPostProcessingAction.action)
}

// -------------------------------------------------------------------

// AudioResponsePostProcessingAction

// string actionId = 1;
inline void AudioResponsePostProcessingAction::clear_actionid() {
  actionid_.ClearToEmpty();
}
inline const std::string& AudioResponsePostProcessingAction::actionid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioResponsePostProcessingAction.actionId)
  return _internal_actionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioResponsePostProcessingAction::set_actionid(ArgT0&& arg0, ArgT... args) {
 
 actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioResponsePostProcessingAction.actionId)
}
inline std::string* AudioResponsePostProcessingAction::mutable_actionid() {
  std::string* _s = _internal_mutable_actionid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioResponsePostProcessingAction.actionId)
  return _s;
}
inline const std::string& AudioResponsePostProcessingAction::_internal_actionid() const {
  return actionid_.Get();
}
inline void AudioResponsePostProcessingAction::_internal_set_actionid(const std::string& value) {
  
  actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioResponsePostProcessingAction::_internal_mutable_actionid() {
  
  return actionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioResponsePostProcessingAction::release_actionid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioResponsePostProcessingAction.actionId)
  return actionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioResponsePostProcessingAction::set_allocated_actionid(std::string* actionid) {
  if (actionid != nullptr) {
    
  } else {
    
  }
  actionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actionid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioResponsePostProcessingAction.actionId)
}

// .sensory.api.v1.audio.AudioPostProcessingAction action = 2 [(.validate.rules) = {
inline void AudioResponsePostProcessingAction::clear_action() {
  action_ = 0;
}
inline ::sensory::api::v1::audio::AudioPostProcessingAction AudioResponsePostProcessingAction::_internal_action() const {
  return static_cast< ::sensory::api::v1::audio::AudioPostProcessingAction >(action_);
}
inline ::sensory::api::v1::audio::AudioPostProcessingAction AudioResponsePostProcessingAction::action() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioResponsePostProcessingAction.action)
  return _internal_action();
}
inline void AudioResponsePostProcessingAction::_internal_set_action(::sensory::api::v1::audio::AudioPostProcessingAction value) {
  
  action_ = value;
}
inline void AudioResponsePostProcessingAction::set_action(::sensory::api::v1::audio::AudioPostProcessingAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioResponsePostProcessingAction.action)
}

// -------------------------------------------------------------------

// GetModelsResponse

// repeated .sensory.api.v1.audio.AudioModel models = 1;
inline int GetModelsResponse::_internal_models_size() const {
  return models_.size();
}
inline int GetModelsResponse::models_size() const {
  return _internal_models_size();
}
inline void GetModelsResponse::clear_models() {
  models_.Clear();
}
inline ::sensory::api::v1::audio::AudioModel* GetModelsResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.GetModelsResponse.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >*
GetModelsResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.audio.GetModelsResponse.models)
  return &models_;
}
inline const ::sensory::api::v1::audio::AudioModel& GetModelsResponse::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::sensory::api::v1::audio::AudioModel& GetModelsResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.GetModelsResponse.models)
  return _internal_models(index);
}
inline ::sensory::api::v1::audio::AudioModel* GetModelsResponse::_internal_add_models() {
  return models_.Add();
}
inline ::sensory::api::v1::audio::AudioModel* GetModelsResponse::add_models() {
  ::sensory::api::v1::audio::AudioModel* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:sensory.api.v1.audio.GetModelsResponse.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::AudioModel >&
GetModelsResponse::models() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.audio.GetModelsResponse.models)
  return models_;
}

// -------------------------------------------------------------------

// CreateEnrollmentRequest

// .sensory.api.v1.audio.CreateEnrollmentConfig config = 1;
inline bool CreateEnrollmentRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool CreateEnrollmentRequest::has_config() const {
  return _internal_has_config();
}
inline void CreateEnrollmentRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void CreateEnrollmentRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::CreateEnrollmentConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::CreateEnrollmentConfig& CreateEnrollmentRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::CreateEnrollmentConfig&>(::sensory::api::v1::audio::_CreateEnrollmentConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::CreateEnrollmentConfig& CreateEnrollmentRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::CreateEnrollmentConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateEnrollmentRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::CreateEnrollmentConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.CreateEnrollmentRequest.config)
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::CreateEnrollmentConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::CreateEnrollmentConfig* CreateEnrollmentRequest::mutable_config() {
  ::sensory::api::v1::audio::CreateEnrollmentConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool CreateEnrollmentRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool CreateEnrollmentRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void CreateEnrollmentRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void CreateEnrollmentRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& CreateEnrollmentRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void CreateEnrollmentRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
}
inline std::string* CreateEnrollmentRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
  return _s;
}
inline const std::string& CreateEnrollmentRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateEnrollmentRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void CreateEnrollmentRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentRequest.audioContent)
}

inline bool CreateEnrollmentRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void CreateEnrollmentRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline CreateEnrollmentRequest::StreamingRequestCase CreateEnrollmentRequest::streamingRequest_case() const {
  return CreateEnrollmentRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateRequest

// .sensory.api.v1.audio.AuthenticateConfig config = 1;
inline bool AuthenticateRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool AuthenticateRequest::has_config() const {
  return _internal_has_config();
}
inline void AuthenticateRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void AuthenticateRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::AuthenticateConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::AuthenticateConfig& AuthenticateRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::AuthenticateConfig&>(::sensory::api::v1::audio::_AuthenticateConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AuthenticateConfig& AuthenticateRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.AuthenticateRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::AuthenticateConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthenticateRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::AuthenticateConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.AuthenticateRequest.config)
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::AuthenticateConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::AuthenticateConfig* AuthenticateRequest::mutable_config() {
  ::sensory::api::v1::audio::AuthenticateConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool AuthenticateRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool AuthenticateRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void AuthenticateRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void AuthenticateRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& AuthenticateRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateRequest.audioContent)
}
inline std::string* AuthenticateRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateRequest.audioContent)
  return _s;
}
inline const std::string& AuthenticateRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void AuthenticateRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateRequest.audioContent)
}

inline bool AuthenticateRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void AuthenticateRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline AuthenticateRequest::StreamingRequestCase AuthenticateRequest::streamingRequest_case() const {
  return AuthenticateRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidateEventRequest

// .sensory.api.v1.audio.ValidateEventConfig config = 1;
inline bool ValidateEventRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool ValidateEventRequest::has_config() const {
  return _internal_has_config();
}
inline void ValidateEventRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void ValidateEventRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::ValidateEventConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::ValidateEventConfig& ValidateEventRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::ValidateEventConfig&>(::sensory::api::v1::audio::_ValidateEventConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::ValidateEventConfig& ValidateEventRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.ValidateEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::ValidateEventConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValidateEventRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::ValidateEventConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEventRequest.config)
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::ValidateEventConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::ValidateEventConfig* ValidateEventRequest::mutable_config() {
  ::sensory::api::v1::audio::ValidateEventConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool ValidateEventRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool ValidateEventRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void ValidateEventRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void ValidateEventRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& ValidateEventRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void ValidateEventRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventRequest.audioContent)
}
inline std::string* ValidateEventRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventRequest.audioContent)
  return _s;
}
inline const std::string& ValidateEventRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValidateEventRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ValidateEventRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventRequest.audioContent)
}

// .sensory.api.v1.audio.AudioRequestPostProcessingAction postProcessingAction = 10;
inline bool ValidateEventRequest::_internal_has_postprocessingaction() const {
  return this != internal_default_instance() && postprocessingaction_ != nullptr;
}
inline bool ValidateEventRequest::has_postprocessingaction() const {
  return _internal_has_postprocessingaction();
}
inline void ValidateEventRequest::clear_postprocessingaction() {
  if (GetArenaForAllocation() == nullptr && postprocessingaction_ != nullptr) {
    delete postprocessingaction_;
  }
  postprocessingaction_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& ValidateEventRequest::_internal_postprocessingaction() const {
  const ::sensory::api::v1::audio::AudioRequestPostProcessingAction* p = postprocessingaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioRequestPostProcessingAction&>(
      ::sensory::api::v1::audio::_AudioRequestPostProcessingAction_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& ValidateEventRequest::postprocessingaction() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventRequest.postProcessingAction)
  return _internal_postprocessingaction();
}
inline void ValidateEventRequest::unsafe_arena_set_allocated_postprocessingaction(
    ::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(postprocessingaction_);
  }
  postprocessingaction_ = postprocessingaction;
  if (postprocessingaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEventRequest.postProcessingAction)
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* ValidateEventRequest::release_postprocessingaction() {
  
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* ValidateEventRequest::unsafe_arena_release_postprocessingaction() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventRequest.postProcessingAction)
  
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* ValidateEventRequest::_internal_mutable_postprocessingaction() {
  
  if (postprocessingaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioRequestPostProcessingAction>(GetArenaForAllocation());
    postprocessingaction_ = p;
  }
  return postprocessingaction_;
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* ValidateEventRequest::mutable_postprocessingaction() {
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* _msg = _internal_mutable_postprocessingaction();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventRequest.postProcessingAction)
  return _msg;
}
inline void ValidateEventRequest::set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete postprocessingaction_;
  }
  if (postprocessingaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioRequestPostProcessingAction>::GetOwningArena(postprocessingaction);
    if (message_arena != submessage_arena) {
      postprocessingaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, postprocessingaction, submessage_arena);
    }
    
  } else {
    
  }
  postprocessingaction_ = postprocessingaction;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventRequest.postProcessingAction)
}

inline bool ValidateEventRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void ValidateEventRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline ValidateEventRequest::StreamingRequestCase ValidateEventRequest::streamingRequest_case() const {
  return ValidateEventRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateEnrolledEventRequest

// .sensory.api.v1.audio.CreateEnrollmentEventConfig config = 1;
inline bool CreateEnrolledEventRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool CreateEnrolledEventRequest::has_config() const {
  return _internal_has_config();
}
inline void CreateEnrolledEventRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void CreateEnrolledEventRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::CreateEnrollmentEventConfig* CreateEnrolledEventRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrolledEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::CreateEnrollmentEventConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::CreateEnrollmentEventConfig& CreateEnrolledEventRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::CreateEnrollmentEventConfig&>(::sensory::api::v1::audio::_CreateEnrollmentEventConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::CreateEnrollmentEventConfig& CreateEnrolledEventRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrolledEventRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::CreateEnrollmentEventConfig* CreateEnrolledEventRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.CreateEnrolledEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::CreateEnrollmentEventConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateEnrolledEventRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::CreateEnrollmentEventConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.CreateEnrolledEventRequest.config)
}
inline ::sensory::api::v1::audio::CreateEnrollmentEventConfig* CreateEnrolledEventRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::CreateEnrollmentEventConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::CreateEnrollmentEventConfig* CreateEnrolledEventRequest::mutable_config() {
  ::sensory::api::v1::audio::CreateEnrollmentEventConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrolledEventRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool CreateEnrolledEventRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool CreateEnrolledEventRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void CreateEnrolledEventRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void CreateEnrolledEventRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& CreateEnrolledEventRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrolledEventRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void CreateEnrolledEventRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrolledEventRequest.audioContent)
}
inline std::string* CreateEnrolledEventRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrolledEventRequest.audioContent)
  return _s;
}
inline const std::string& CreateEnrolledEventRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateEnrolledEventRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrolledEventRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrolledEventRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrolledEventRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void CreateEnrolledEventRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrolledEventRequest.audioContent)
}

inline bool CreateEnrolledEventRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void CreateEnrolledEventRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline CreateEnrolledEventRequest::StreamingRequestCase CreateEnrolledEventRequest::streamingRequest_case() const {
  return CreateEnrolledEventRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidateEnrolledEventRequest

// .sensory.api.v1.audio.ValidateEnrolledEventConfig config = 1;
inline bool ValidateEnrolledEventRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool ValidateEnrolledEventRequest::has_config() const {
  return _internal_has_config();
}
inline void ValidateEnrolledEventRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void ValidateEnrolledEventRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::ValidateEnrolledEventConfig* ValidateEnrolledEventRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::ValidateEnrolledEventConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::ValidateEnrolledEventConfig& ValidateEnrolledEventRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::ValidateEnrolledEventConfig&>(::sensory::api::v1::audio::_ValidateEnrolledEventConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::ValidateEnrolledEventConfig& ValidateEnrolledEventRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::ValidateEnrolledEventConfig* ValidateEnrolledEventRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.ValidateEnrolledEventRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::ValidateEnrolledEventConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValidateEnrolledEventRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::ValidateEnrolledEventConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventRequest.config)
}
inline ::sensory::api::v1::audio::ValidateEnrolledEventConfig* ValidateEnrolledEventRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::ValidateEnrolledEventConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::ValidateEnrolledEventConfig* ValidateEnrolledEventRequest::mutable_config() {
  ::sensory::api::v1::audio::ValidateEnrolledEventConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool ValidateEnrolledEventRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool ValidateEnrolledEventRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void ValidateEnrolledEventRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void ValidateEnrolledEventRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& ValidateEnrolledEventRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void ValidateEnrolledEventRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventRequest.audioContent)
}
inline std::string* ValidateEnrolledEventRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventRequest.audioContent)
  return _s;
}
inline const std::string& ValidateEnrolledEventRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValidateEnrolledEventRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ValidateEnrolledEventRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventRequest.audioContent)
}

inline bool ValidateEnrolledEventRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void ValidateEnrolledEventRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline ValidateEnrolledEventRequest::StreamingRequestCase ValidateEnrolledEventRequest::streamingRequest_case() const {
  return ValidateEnrolledEventRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TranscribeRequest

// .sensory.api.v1.audio.TranscribeConfig config = 1;
inline bool TranscribeRequest::_internal_has_config() const {
  return streamingRequest_case() == kConfig;
}
inline bool TranscribeRequest::has_config() const {
  return _internal_has_config();
}
inline void TranscribeRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void TranscribeRequest::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingRequest_.config_;
    }
    clear_has_streamingRequest();
  }
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
      ::sensory::api::v1::audio::TranscribeConfig* temp = streamingRequest_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::TranscribeConfig& TranscribeRequest::_internal_config() const {
  return _internal_has_config()
      ? *streamingRequest_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::TranscribeConfig&>(::sensory::api::v1::audio::_TranscribeConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::TranscribeConfig& TranscribeRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeRequest.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.TranscribeRequest.config)
  if (_internal_has_config()) {
    clear_has_streamingRequest();
    ::sensory::api::v1::audio::TranscribeConfig* temp = streamingRequest_.config_;
    streamingRequest_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TranscribeRequest::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::TranscribeConfig* config) {
  clear_streamingRequest();
  if (config) {
    set_has_config();
    streamingRequest_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.TranscribeRequest.config)
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingRequest();
    set_has_config();
    streamingRequest_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::TranscribeConfig >(GetArenaForAllocation());
  }
  return streamingRequest_.config_;
}
inline ::sensory::api::v1::audio::TranscribeConfig* TranscribeRequest::mutable_config() {
  ::sensory::api::v1::audio::TranscribeConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeRequest.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool TranscribeRequest::_internal_has_audiocontent() const {
  return streamingRequest_case() == kAudioContent;
}
inline bool TranscribeRequest::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void TranscribeRequest::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void TranscribeRequest::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingRequest_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingRequest();
  }
}
inline const std::string& TranscribeRequest::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeRequest.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void TranscribeRequest::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeRequest.audioContent)
}
inline std::string* TranscribeRequest::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeRequest.audioContent)
  return _s;
}
inline const std::string& TranscribeRequest::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingRequest_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TranscribeRequest::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingRequest_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeRequest::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingRequest();
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingRequest_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeRequest::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeRequest.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingRequest();
    return streamingRequest_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TranscribeRequest::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingRequest()) {
    clear_streamingRequest();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingRequest_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeRequest.audioContent)
}

// .sensory.api.v1.audio.AudioRequestPostProcessingAction postProcessingAction = 10;
inline bool TranscribeRequest::_internal_has_postprocessingaction() const {
  return this != internal_default_instance() && postprocessingaction_ != nullptr;
}
inline bool TranscribeRequest::has_postprocessingaction() const {
  return _internal_has_postprocessingaction();
}
inline void TranscribeRequest::clear_postprocessingaction() {
  if (GetArenaForAllocation() == nullptr && postprocessingaction_ != nullptr) {
    delete postprocessingaction_;
  }
  postprocessingaction_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& TranscribeRequest::_internal_postprocessingaction() const {
  const ::sensory::api::v1::audio::AudioRequestPostProcessingAction* p = postprocessingaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioRequestPostProcessingAction&>(
      ::sensory::api::v1::audio::_AudioRequestPostProcessingAction_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioRequestPostProcessingAction& TranscribeRequest::postprocessingaction() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeRequest.postProcessingAction)
  return _internal_postprocessingaction();
}
inline void TranscribeRequest::unsafe_arena_set_allocated_postprocessingaction(
    ::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(postprocessingaction_);
  }
  postprocessingaction_ = postprocessingaction;
  if (postprocessingaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.TranscribeRequest.postProcessingAction)
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* TranscribeRequest::release_postprocessingaction() {
  
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* TranscribeRequest::unsafe_arena_release_postprocessingaction() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeRequest.postProcessingAction)
  
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* TranscribeRequest::_internal_mutable_postprocessingaction() {
  
  if (postprocessingaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioRequestPostProcessingAction>(GetArenaForAllocation());
    postprocessingaction_ = p;
  }
  return postprocessingaction_;
}
inline ::sensory::api::v1::audio::AudioRequestPostProcessingAction* TranscribeRequest::mutable_postprocessingaction() {
  ::sensory::api::v1::audio::AudioRequestPostProcessingAction* _msg = _internal_mutable_postprocessingaction();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeRequest.postProcessingAction)
  return _msg;
}
inline void TranscribeRequest::set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioRequestPostProcessingAction* postprocessingaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete postprocessingaction_;
  }
  if (postprocessingaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioRequestPostProcessingAction>::GetOwningArena(postprocessingaction);
    if (message_arena != submessage_arena) {
      postprocessingaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, postprocessingaction, submessage_arena);
    }
    
  } else {
    
  }
  postprocessingaction_ = postprocessingaction;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeRequest.postProcessingAction)
}

inline bool TranscribeRequest::has_streamingRequest() const {
  return streamingRequest_case() != STREAMINGREQUEST_NOT_SET;
}
inline void TranscribeRequest::clear_has_streamingRequest() {
  _oneof_case_[0] = STREAMINGREQUEST_NOT_SET;
}
inline TranscribeRequest::StreamingRequestCase TranscribeRequest::streamingRequest_case() const {
  return TranscribeRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SynthesizeSpeechRequest

// string phrase = 1;
inline void SynthesizeSpeechRequest::clear_phrase() {
  phrase_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechRequest::phrase() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.SynthesizeSpeechRequest.phrase)
  return _internal_phrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeSpeechRequest::set_phrase(ArgT0&& arg0, ArgT... args) {
 
 phrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.SynthesizeSpeechRequest.phrase)
}
inline std::string* SynthesizeSpeechRequest::mutable_phrase() {
  std::string* _s = _internal_mutable_phrase();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.SynthesizeSpeechRequest.phrase)
  return _s;
}
inline const std::string& SynthesizeSpeechRequest::_internal_phrase() const {
  return phrase_.Get();
}
inline void SynthesizeSpeechRequest::_internal_set_phrase(const std::string& value) {
  
  phrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SynthesizeSpeechRequest::_internal_mutable_phrase() {
  
  return phrase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SynthesizeSpeechRequest::release_phrase() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.SynthesizeSpeechRequest.phrase)
  return phrase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SynthesizeSpeechRequest::set_allocated_phrase(std::string* phrase) {
  if (phrase != nullptr) {
    
  } else {
    
  }
  phrase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phrase,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.SynthesizeSpeechRequest.phrase)
}

// .sensory.api.v1.audio.VoiceSynthesisConfig config = 2;
inline bool SynthesizeSpeechRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool SynthesizeSpeechRequest::has_config() const {
  return _internal_has_config();
}
inline void SynthesizeSpeechRequest::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::sensory::api::v1::audio::VoiceSynthesisConfig& SynthesizeSpeechRequest::_internal_config() const {
  const ::sensory::api::v1::audio::VoiceSynthesisConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::VoiceSynthesisConfig&>(
      ::sensory::api::v1::audio::_VoiceSynthesisConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::VoiceSynthesisConfig& SynthesizeSpeechRequest::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.SynthesizeSpeechRequest.config)
  return _internal_config();
}
inline void SynthesizeSpeechRequest::unsafe_arena_set_allocated_config(
    ::sensory::api::v1::audio::VoiceSynthesisConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.SynthesizeSpeechRequest.config)
}
inline ::sensory::api::v1::audio::VoiceSynthesisConfig* SynthesizeSpeechRequest::release_config() {
  
  ::sensory::api::v1::audio::VoiceSynthesisConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::VoiceSynthesisConfig* SynthesizeSpeechRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.SynthesizeSpeechRequest.config)
  
  ::sensory::api::v1::audio::VoiceSynthesisConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::VoiceSynthesisConfig* SynthesizeSpeechRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::VoiceSynthesisConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::sensory::api::v1::audio::VoiceSynthesisConfig* SynthesizeSpeechRequest::mutable_config() {
  ::sensory::api::v1::audio::VoiceSynthesisConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.SynthesizeSpeechRequest.config)
  return _msg;
}
inline void SynthesizeSpeechRequest::set_allocated_config(::sensory::api::v1::audio::VoiceSynthesisConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::VoiceSynthesisConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.SynthesizeSpeechRequest.config)
}

// -------------------------------------------------------------------

// CreateEnrollmentResponse

// int64 percentComplete = 1;
inline void CreateEnrollmentResponse::clear_percentcomplete() {
  percentcomplete_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::_internal_percentcomplete() const {
  return percentcomplete_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::percentcomplete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.percentComplete)
  return _internal_percentcomplete();
}
inline void CreateEnrollmentResponse::_internal_set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  percentcomplete_ = value;
}
inline void CreateEnrollmentResponse::set_percentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_percentcomplete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.percentComplete)
}

// float audioEnergy = 2;
inline void CreateEnrollmentResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float CreateEnrollmentResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float CreateEnrollmentResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void CreateEnrollmentResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void CreateEnrollmentResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.audioEnergy)
}

// string enrollmentId = 3;
inline void CreateEnrollmentResponse::clear_enrollmentid() {
  enrollmentid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
 
 enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
}
inline std::string* CreateEnrollmentResponse::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_enrollmentid() const {
  return enrollmentid_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_enrollmentid(const std::string& value) {
  
  enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_enrollmentid() {
  
  return enrollmentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
  return enrollmentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (enrollmentid != nullptr) {
    
  } else {
    
  }
  enrollmentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentId)
}

// string modelName = 4;
inline void CreateEnrollmentResponse::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
}
inline std::string* CreateEnrollmentResponse::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.modelName)
}

// string modelVersion = 5;
inline void CreateEnrollmentResponse::clear_modelversion() {
  modelversion_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelversion() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
  return _internal_modelversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelversion(ArgT0&& arg0, ArgT... args) {
 
 modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
}
inline std::string* CreateEnrollmentResponse::mutable_modelversion() {
  std::string* _s = _internal_mutable_modelversion();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelversion() const {
  return modelversion_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelversion(const std::string& value) {
  
  modelversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelversion() {
  
  return modelversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelversion() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
  return modelversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelversion(std::string* modelversion) {
  if (modelversion != nullptr) {
    
  } else {
    
  }
  modelversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.modelVersion)
}

// string modelPrompt = 6;
inline void CreateEnrollmentResponse::clear_modelprompt() {
  modelprompt_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentResponse::modelprompt() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
  return _internal_modelprompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentResponse::set_modelprompt(ArgT0&& arg0, ArgT... args) {
 
 modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
}
inline std::string* CreateEnrollmentResponse::mutable_modelprompt() {
  std::string* _s = _internal_mutable_modelprompt();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
  return _s;
}
inline const std::string& CreateEnrollmentResponse::_internal_modelprompt() const {
  return modelprompt_.Get();
}
inline void CreateEnrollmentResponse::_internal_set_modelprompt(const std::string& value) {
  
  modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::_internal_mutable_modelprompt() {
  
  return modelprompt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentResponse::release_modelprompt() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
  return modelprompt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentResponse::set_allocated_modelprompt(std::string* modelprompt) {
  if (modelprompt != nullptr) {
    
  } else {
    
  }
  modelprompt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelprompt,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.modelPrompt)
}

// int64 percentSegmentComplete = 7;
inline void CreateEnrollmentResponse::clear_percentsegmentcomplete() {
  percentsegmentcomplete_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::_internal_percentsegmentcomplete() const {
  return percentsegmentcomplete_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateEnrollmentResponse::percentsegmentcomplete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.percentSegmentComplete)
  return _internal_percentsegmentcomplete();
}
inline void CreateEnrollmentResponse::_internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  percentsegmentcomplete_ = value;
}
inline void CreateEnrollmentResponse::set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_percentsegmentcomplete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentResponse.percentSegmentComplete)
}

// .sensory.api.common.EnrollmentToken enrollmentToken = 8;
inline bool CreateEnrollmentResponse::_internal_has_enrollmenttoken() const {
  return this != internal_default_instance() && enrollmenttoken_ != nullptr;
}
inline bool CreateEnrollmentResponse::has_enrollmenttoken() const {
  return _internal_has_enrollmenttoken();
}
inline const ::sensory::api::common::EnrollmentToken& CreateEnrollmentResponse::_internal_enrollmenttoken() const {
  const ::sensory::api::common::EnrollmentToken* p = enrollmenttoken_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::EnrollmentToken&>(
      ::sensory::api::common::_EnrollmentToken_default_instance_);
}
inline const ::sensory::api::common::EnrollmentToken& CreateEnrollmentResponse::enrollmenttoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentToken)
  return _internal_enrollmenttoken();
}
inline void CreateEnrollmentResponse::unsafe_arena_set_allocated_enrollmenttoken(
    ::sensory::api::common::EnrollmentToken* enrollmenttoken) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enrollmenttoken_);
  }
  enrollmenttoken_ = enrollmenttoken;
  if (enrollmenttoken) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentToken)
}
inline ::sensory::api::common::EnrollmentToken* CreateEnrollmentResponse::release_enrollmenttoken() {
  
  ::sensory::api::common::EnrollmentToken* temp = enrollmenttoken_;
  enrollmenttoken_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::EnrollmentToken* CreateEnrollmentResponse::unsafe_arena_release_enrollmenttoken() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentToken)
  
  ::sensory::api::common::EnrollmentToken* temp = enrollmenttoken_;
  enrollmenttoken_ = nullptr;
  return temp;
}
inline ::sensory::api::common::EnrollmentToken* CreateEnrollmentResponse::_internal_mutable_enrollmenttoken() {
  
  if (enrollmenttoken_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::EnrollmentToken>(GetArenaForAllocation());
    enrollmenttoken_ = p;
  }
  return enrollmenttoken_;
}
inline ::sensory::api::common::EnrollmentToken* CreateEnrollmentResponse::mutable_enrollmenttoken() {
  ::sensory::api::common::EnrollmentToken* _msg = _internal_mutable_enrollmenttoken();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentToken)
  return _msg;
}
inline void CreateEnrollmentResponse::set_allocated_enrollmenttoken(::sensory::api::common::EnrollmentToken* enrollmenttoken) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enrollmenttoken_);
  }
  if (enrollmenttoken) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enrollmenttoken));
    if (message_arena != submessage_arena) {
      enrollmenttoken = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enrollmenttoken, submessage_arena);
    }
    
  } else {
    
  }
  enrollmenttoken_ = enrollmenttoken;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentResponse.enrollmentToken)
}

// -------------------------------------------------------------------

// AuthenticateResponse

// float audioEnergy = 1;
inline void AuthenticateResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float AuthenticateResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float AuthenticateResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void AuthenticateResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void AuthenticateResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.audioEnergy)
}

// bool success = 2;
inline void AuthenticateResponse::clear_success() {
  success_ = false;
}
inline bool AuthenticateResponse::_internal_success() const {
  return success_;
}
inline bool AuthenticateResponse::success() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.success)
  return _internal_success();
}
inline void AuthenticateResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AuthenticateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.success)
}

// .sensory.api.common.TokenResponse token = 3;
inline bool AuthenticateResponse::_internal_has_token() const {
  return this != internal_default_instance() && token_ != nullptr;
}
inline bool AuthenticateResponse::has_token() const {
  return _internal_has_token();
}
inline const ::sensory::api::common::TokenResponse& AuthenticateResponse::_internal_token() const {
  const ::sensory::api::common::TokenResponse* p = token_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::common::TokenResponse&>(
      ::sensory::api::common::_TokenResponse_default_instance_);
}
inline const ::sensory::api::common::TokenResponse& AuthenticateResponse::token() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.token)
  return _internal_token();
}
inline void AuthenticateResponse::unsafe_arena_set_allocated_token(
    ::sensory::api::common::TokenResponse* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  token_ = token;
  if (token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.AuthenticateResponse.token)
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::release_token() {
  
  ::sensory::api::common::TokenResponse* temp = token_;
  token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.token)
  
  ::sensory::api::common::TokenResponse* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::_internal_mutable_token() {
  
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::common::TokenResponse>(GetArenaForAllocation());
    token_ = p;
  }
  return token_;
}
inline ::sensory::api::common::TokenResponse* AuthenticateResponse::mutable_token() {
  ::sensory::api::common::TokenResponse* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.token)
  return _msg;
}
inline void AuthenticateResponse::set_allocated_token(::sensory::api::common::TokenResponse* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token));
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.token)
}

// string userId = 4;
inline void AuthenticateResponse::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& AuthenticateResponse::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.userId)
}
inline std::string* AuthenticateResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.userId)
  return _s;
}
inline const std::string& AuthenticateResponse::_internal_userid() const {
  return userid_.Get();
}
inline void AuthenticateResponse::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.userId)
}

// string enrollmentId = 5;
inline void AuthenticateResponse::clear_enrollmentid() {
  enrollmentid_.ClearToEmpty();
}
inline const std::string& AuthenticateResponse::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateResponse::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
 
 enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
}
inline std::string* AuthenticateResponse::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
  return _s;
}
inline const std::string& AuthenticateResponse::_internal_enrollmentid() const {
  return enrollmentid_.Get();
}
inline void AuthenticateResponse::_internal_set_enrollmentid(const std::string& value) {
  
  enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::_internal_mutable_enrollmentid() {
  
  return enrollmentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
  return enrollmentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateResponse::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (enrollmentid != nullptr) {
    
  } else {
    
  }
  enrollmentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.enrollmentId)
}

// string modelPrompt = 6;
inline void AuthenticateResponse::clear_modelprompt() {
  modelprompt_.ClearToEmpty();
}
inline const std::string& AuthenticateResponse::modelprompt() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
  return _internal_modelprompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateResponse::set_modelprompt(ArgT0&& arg0, ArgT... args) {
 
 modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
}
inline std::string* AuthenticateResponse::mutable_modelprompt() {
  std::string* _s = _internal_mutable_modelprompt();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
  return _s;
}
inline const std::string& AuthenticateResponse::_internal_modelprompt() const {
  return modelprompt_.Get();
}
inline void AuthenticateResponse::_internal_set_modelprompt(const std::string& value) {
  
  modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::_internal_mutable_modelprompt() {
  
  return modelprompt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::release_modelprompt() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
  return modelprompt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateResponse::set_allocated_modelprompt(std::string* modelprompt) {
  if (modelprompt != nullptr) {
    
  } else {
    
  }
  modelprompt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelprompt,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateResponse.modelPrompt)
}

// int64 percentSegmentComplete = 7;
inline void AuthenticateResponse::clear_percentsegmentcomplete() {
  percentsegmentcomplete_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuthenticateResponse::_internal_percentsegmentcomplete() const {
  return percentsegmentcomplete_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuthenticateResponse::percentsegmentcomplete() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateResponse.percentSegmentComplete)
  return _internal_percentsegmentcomplete();
}
inline void AuthenticateResponse::_internal_set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  percentsegmentcomplete_ = value;
}
inline void AuthenticateResponse::set_percentsegmentcomplete(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_percentsegmentcomplete(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateResponse.percentSegmentComplete)
}

// -------------------------------------------------------------------

// ValidateEventResponse

// float audioEnergy = 1;
inline void ValidateEventResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float ValidateEventResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float ValidateEventResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void ValidateEventResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void ValidateEventResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.audioEnergy)
}

// bool success = 2;
inline void ValidateEventResponse::clear_success() {
  success_ = false;
}
inline bool ValidateEventResponse::_internal_success() const {
  return success_;
}
inline bool ValidateEventResponse::success() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.success)
  return _internal_success();
}
inline void ValidateEventResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ValidateEventResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.success)
}

// string resultId = 3;
inline void ValidateEventResponse::clear_resultid() {
  resultid_.ClearToEmpty();
}
inline const std::string& ValidateEventResponse::resultid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.resultId)
  return _internal_resultid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEventResponse::set_resultid(ArgT0&& arg0, ArgT... args) {
 
 resultid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.resultId)
}
inline std::string* ValidateEventResponse::mutable_resultid() {
  std::string* _s = _internal_mutable_resultid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventResponse.resultId)
  return _s;
}
inline const std::string& ValidateEventResponse::_internal_resultid() const {
  return resultid_.Get();
}
inline void ValidateEventResponse::_internal_set_resultid(const std::string& value) {
  
  resultid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventResponse::_internal_mutable_resultid() {
  
  return resultid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventResponse::release_resultid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventResponse.resultId)
  return resultid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEventResponse::set_allocated_resultid(std::string* resultid) {
  if (resultid != nullptr) {
    
  } else {
    
  }
  resultid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resultid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventResponse.resultId)
}

// float score = 4;
inline void ValidateEventResponse::clear_score() {
  score_ = 0;
}
inline float ValidateEventResponse::_internal_score() const {
  return score_;
}
inline float ValidateEventResponse::score() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.score)
  return _internal_score();
}
inline void ValidateEventResponse::_internal_set_score(float value) {
  
  score_ = value;
}
inline void ValidateEventResponse::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventResponse.score)
}

// .sensory.api.v1.audio.AudioResponsePostProcessingAction postProcessingAction = 10;
inline bool ValidateEventResponse::_internal_has_postprocessingaction() const {
  return this != internal_default_instance() && postprocessingaction_ != nullptr;
}
inline bool ValidateEventResponse::has_postprocessingaction() const {
  return _internal_has_postprocessingaction();
}
inline void ValidateEventResponse::clear_postprocessingaction() {
  if (GetArenaForAllocation() == nullptr && postprocessingaction_ != nullptr) {
    delete postprocessingaction_;
  }
  postprocessingaction_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& ValidateEventResponse::_internal_postprocessingaction() const {
  const ::sensory::api::v1::audio::AudioResponsePostProcessingAction* p = postprocessingaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioResponsePostProcessingAction&>(
      ::sensory::api::v1::audio::_AudioResponsePostProcessingAction_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& ValidateEventResponse::postprocessingaction() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventResponse.postProcessingAction)
  return _internal_postprocessingaction();
}
inline void ValidateEventResponse::unsafe_arena_set_allocated_postprocessingaction(
    ::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(postprocessingaction_);
  }
  postprocessingaction_ = postprocessingaction;
  if (postprocessingaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEventResponse.postProcessingAction)
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* ValidateEventResponse::release_postprocessingaction() {
  
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* ValidateEventResponse::unsafe_arena_release_postprocessingaction() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventResponse.postProcessingAction)
  
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* ValidateEventResponse::_internal_mutable_postprocessingaction() {
  
  if (postprocessingaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioResponsePostProcessingAction>(GetArenaForAllocation());
    postprocessingaction_ = p;
  }
  return postprocessingaction_;
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* ValidateEventResponse::mutable_postprocessingaction() {
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* _msg = _internal_mutable_postprocessingaction();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventResponse.postProcessingAction)
  return _msg;
}
inline void ValidateEventResponse::set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete postprocessingaction_;
  }
  if (postprocessingaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioResponsePostProcessingAction>::GetOwningArena(postprocessingaction);
    if (message_arena != submessage_arena) {
      postprocessingaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, postprocessingaction, submessage_arena);
    }
    
  } else {
    
  }
  postprocessingaction_ = postprocessingaction;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventResponse.postProcessingAction)
}

// -------------------------------------------------------------------

// ValidateEnrolledEventResponse

// float audioEnergy = 1;
inline void ValidateEnrolledEventResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float ValidateEnrolledEventResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float ValidateEnrolledEventResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void ValidateEnrolledEventResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void ValidateEnrolledEventResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventResponse.audioEnergy)
}

// bool success = 2;
inline void ValidateEnrolledEventResponse::clear_success() {
  success_ = false;
}
inline bool ValidateEnrolledEventResponse::_internal_success() const {
  return success_;
}
inline bool ValidateEnrolledEventResponse::success() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventResponse.success)
  return _internal_success();
}
inline void ValidateEnrolledEventResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ValidateEnrolledEventResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventResponse.success)
}

// string enrollmentId = 3;
inline void ValidateEnrolledEventResponse::clear_enrollmentid() {
  enrollmentid_.ClearToEmpty();
}
inline const std::string& ValidateEnrolledEventResponse::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventResponse.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEnrolledEventResponse::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
 
 enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventResponse.enrollmentId)
}
inline std::string* ValidateEnrolledEventResponse::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventResponse.enrollmentId)
  return _s;
}
inline const std::string& ValidateEnrolledEventResponse::_internal_enrollmentid() const {
  return enrollmentid_.Get();
}
inline void ValidateEnrolledEventResponse::_internal_set_enrollmentid(const std::string& value) {
  
  enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventResponse::_internal_mutable_enrollmentid() {
  
  return enrollmentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventResponse::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventResponse.enrollmentId)
  return enrollmentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEnrolledEventResponse::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (enrollmentid != nullptr) {
    
  } else {
    
  }
  enrollmentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventResponse.enrollmentId)
}

// string userId = 4;
inline void ValidateEnrolledEventResponse::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& ValidateEnrolledEventResponse::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventResponse.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEnrolledEventResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventResponse.userId)
}
inline std::string* ValidateEnrolledEventResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventResponse.userId)
  return _s;
}
inline const std::string& ValidateEnrolledEventResponse::_internal_userid() const {
  return userid_.Get();
}
inline void ValidateEnrolledEventResponse::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventResponse::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventResponse::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventResponse.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEnrolledEventResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventResponse.userId)
}

// string modelPrompt = 5;
inline void ValidateEnrolledEventResponse::clear_modelprompt() {
  modelprompt_.ClearToEmpty();
}
inline const std::string& ValidateEnrolledEventResponse::modelprompt() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventResponse.modelPrompt)
  return _internal_modelprompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEnrolledEventResponse::set_modelprompt(ArgT0&& arg0, ArgT... args) {
 
 modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventResponse.modelPrompt)
}
inline std::string* ValidateEnrolledEventResponse::mutable_modelprompt() {
  std::string* _s = _internal_mutable_modelprompt();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventResponse.modelPrompt)
  return _s;
}
inline const std::string& ValidateEnrolledEventResponse::_internal_modelprompt() const {
  return modelprompt_.Get();
}
inline void ValidateEnrolledEventResponse::_internal_set_modelprompt(const std::string& value) {
  
  modelprompt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventResponse::_internal_mutable_modelprompt() {
  
  return modelprompt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventResponse::release_modelprompt() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventResponse.modelPrompt)
  return modelprompt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEnrolledEventResponse::set_allocated_modelprompt(std::string* modelprompt) {
  if (modelprompt != nullptr) {
    
  } else {
    
  }
  modelprompt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelprompt,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventResponse.modelPrompt)
}

// -------------------------------------------------------------------

// TranscribeWord

// uint64 begintimeMs = 1;
inline void TranscribeWord::clear_begintimems() {
  begintimems_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWord::_internal_begintimems() const {
  return begintimems_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWord::begintimems() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWord.begintimeMs)
  return _internal_begintimems();
}
inline void TranscribeWord::_internal_set_begintimems(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  begintimems_ = value;
}
inline void TranscribeWord::set_begintimems(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_begintimems(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWord.begintimeMs)
}

// uint64 endtimeMs = 2;
inline void TranscribeWord::clear_endtimems() {
  endtimems_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWord::_internal_endtimems() const {
  return endtimems_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWord::endtimems() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWord.endtimeMs)
  return _internal_endtimems();
}
inline void TranscribeWord::_internal_set_endtimems(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  endtimems_ = value;
}
inline void TranscribeWord::set_endtimems(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_endtimems(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWord.endtimeMs)
}

// float confidence = 3;
inline void TranscribeWord::clear_confidence() {
  confidence_ = 0;
}
inline float TranscribeWord::_internal_confidence() const {
  return confidence_;
}
inline float TranscribeWord::confidence() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWord.confidence)
  return _internal_confidence();
}
inline void TranscribeWord::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void TranscribeWord::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWord.confidence)
}

// .sensory.api.v1.audio.WordState wordState = 4;
inline void TranscribeWord::clear_wordstate() {
  wordstate_ = 0;
}
inline ::sensory::api::v1::audio::WordState TranscribeWord::_internal_wordstate() const {
  return static_cast< ::sensory::api::v1::audio::WordState >(wordstate_);
}
inline ::sensory::api::v1::audio::WordState TranscribeWord::wordstate() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWord.wordState)
  return _internal_wordstate();
}
inline void TranscribeWord::_internal_set_wordstate(::sensory::api::v1::audio::WordState value) {
  
  wordstate_ = value;
}
inline void TranscribeWord::set_wordstate(::sensory::api::v1::audio::WordState value) {
  _internal_set_wordstate(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWord.wordState)
}

// uint64 wordIndex = 5;
inline void TranscribeWord::clear_wordindex() {
  wordindex_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWord::_internal_wordindex() const {
  return wordindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWord::wordindex() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWord.wordIndex)
  return _internal_wordindex();
}
inline void TranscribeWord::_internal_set_wordindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  wordindex_ = value;
}
inline void TranscribeWord::set_wordindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_wordindex(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWord.wordIndex)
}

// string word = 6;
inline void TranscribeWord::clear_word() {
  word_.ClearToEmpty();
}
inline const std::string& TranscribeWord::word() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWord.word)
  return _internal_word();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscribeWord::set_word(ArgT0&& arg0, ArgT... args) {
 
 word_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWord.word)
}
inline std::string* TranscribeWord::mutable_word() {
  std::string* _s = _internal_mutable_word();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeWord.word)
  return _s;
}
inline const std::string& TranscribeWord::_internal_word() const {
  return word_.Get();
}
inline void TranscribeWord::_internal_set_word(const std::string& value) {
  
  word_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeWord::_internal_mutable_word() {
  
  return word_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeWord::release_word() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeWord.word)
  return word_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranscribeWord::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  word_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), word,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeWord.word)
}

// -------------------------------------------------------------------

// TranscribeWordResponse

// repeated .sensory.api.v1.audio.TranscribeWord words = 1;
inline int TranscribeWordResponse::_internal_words_size() const {
  return words_.size();
}
inline int TranscribeWordResponse::words_size() const {
  return _internal_words_size();
}
inline void TranscribeWordResponse::clear_words() {
  words_.Clear();
}
inline ::sensory::api::v1::audio::TranscribeWord* TranscribeWordResponse::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeWordResponse.words)
  return words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::TranscribeWord >*
TranscribeWordResponse::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:sensory.api.v1.audio.TranscribeWordResponse.words)
  return &words_;
}
inline const ::sensory::api::v1::audio::TranscribeWord& TranscribeWordResponse::_internal_words(int index) const {
  return words_.Get(index);
}
inline const ::sensory::api::v1::audio::TranscribeWord& TranscribeWordResponse::words(int index) const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWordResponse.words)
  return _internal_words(index);
}
inline ::sensory::api::v1::audio::TranscribeWord* TranscribeWordResponse::_internal_add_words() {
  return words_.Add();
}
inline ::sensory::api::v1::audio::TranscribeWord* TranscribeWordResponse::add_words() {
  ::sensory::api::v1::audio::TranscribeWord* _add = _internal_add_words();
  // @@protoc_insertion_point(field_add:sensory.api.v1.audio.TranscribeWordResponse.words)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensory::api::v1::audio::TranscribeWord >&
TranscribeWordResponse::words() const {
  // @@protoc_insertion_point(field_list:sensory.api.v1.audio.TranscribeWordResponse.words)
  return words_;
}

// uint64 firstWordIndex = 2;
inline void TranscribeWordResponse::clear_firstwordindex() {
  firstwordindex_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWordResponse::_internal_firstwordindex() const {
  return firstwordindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWordResponse::firstwordindex() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWordResponse.firstWordIndex)
  return _internal_firstwordindex();
}
inline void TranscribeWordResponse::_internal_set_firstwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  firstwordindex_ = value;
}
inline void TranscribeWordResponse::set_firstwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_firstwordindex(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWordResponse.firstWordIndex)
}

// uint64 lastWordIndex = 3;
inline void TranscribeWordResponse::clear_lastwordindex() {
  lastwordindex_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWordResponse::_internal_lastwordindex() const {
  return lastwordindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TranscribeWordResponse::lastwordindex() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeWordResponse.lastWordIndex)
  return _internal_lastwordindex();
}
inline void TranscribeWordResponse::_internal_set_lastwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  lastwordindex_ = value;
}
inline void TranscribeWordResponse::set_lastwordindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_lastwordindex(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeWordResponse.lastWordIndex)
}

// -------------------------------------------------------------------

// TranscribeResponse

// float audioEnergy = 1;
inline void TranscribeResponse::clear_audioenergy() {
  audioenergy_ = 0;
}
inline float TranscribeResponse::_internal_audioenergy() const {
  return audioenergy_;
}
inline float TranscribeResponse::audioenergy() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.audioEnergy)
  return _internal_audioenergy();
}
inline void TranscribeResponse::_internal_set_audioenergy(float value) {
  
  audioenergy_ = value;
}
inline void TranscribeResponse::set_audioenergy(float value) {
  _internal_set_audioenergy(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeResponse.audioEnergy)
}

// string transcript = 2;
inline void TranscribeResponse::clear_transcript() {
  transcript_.ClearToEmpty();
}
inline const std::string& TranscribeResponse::transcript() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.transcript)
  return _internal_transcript();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscribeResponse::set_transcript(ArgT0&& arg0, ArgT... args) {
 
 transcript_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeResponse.transcript)
}
inline std::string* TranscribeResponse::mutable_transcript() {
  std::string* _s = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeResponse.transcript)
  return _s;
}
inline const std::string& TranscribeResponse::_internal_transcript() const {
  return transcript_.Get();
}
inline void TranscribeResponse::_internal_set_transcript(const std::string& value) {
  
  transcript_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeResponse::_internal_mutable_transcript() {
  
  return transcript_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeResponse::release_transcript() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeResponse.transcript)
  return transcript_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranscribeResponse::set_allocated_transcript(std::string* transcript) {
  if (transcript != nullptr) {
    
  } else {
    
  }
  transcript_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transcript,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeResponse.transcript)
}

// bool isPartialResult = 3 [deprecated = true];
inline void TranscribeResponse::clear_ispartialresult() {
  ispartialresult_ = false;
}
inline bool TranscribeResponse::_internal_ispartialresult() const {
  return ispartialresult_;
}
inline bool TranscribeResponse::ispartialresult() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.isPartialResult)
  return _internal_ispartialresult();
}
inline void TranscribeResponse::_internal_set_ispartialresult(bool value) {
  
  ispartialresult_ = value;
}
inline void TranscribeResponse::set_ispartialresult(bool value) {
  _internal_set_ispartialresult(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeResponse.isPartialResult)
}

// .sensory.api.v1.audio.TranscribeWordResponse wordList = 4;
inline bool TranscribeResponse::_internal_has_wordlist() const {
  return this != internal_default_instance() && wordlist_ != nullptr;
}
inline bool TranscribeResponse::has_wordlist() const {
  return _internal_has_wordlist();
}
inline void TranscribeResponse::clear_wordlist() {
  if (GetArenaForAllocation() == nullptr && wordlist_ != nullptr) {
    delete wordlist_;
  }
  wordlist_ = nullptr;
}
inline const ::sensory::api::v1::audio::TranscribeWordResponse& TranscribeResponse::_internal_wordlist() const {
  const ::sensory::api::v1::audio::TranscribeWordResponse* p = wordlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::TranscribeWordResponse&>(
      ::sensory::api::v1::audio::_TranscribeWordResponse_default_instance_);
}
inline const ::sensory::api::v1::audio::TranscribeWordResponse& TranscribeResponse::wordlist() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.wordList)
  return _internal_wordlist();
}
inline void TranscribeResponse::unsafe_arena_set_allocated_wordlist(
    ::sensory::api::v1::audio::TranscribeWordResponse* wordlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wordlist_);
  }
  wordlist_ = wordlist;
  if (wordlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.TranscribeResponse.wordList)
}
inline ::sensory::api::v1::audio::TranscribeWordResponse* TranscribeResponse::release_wordlist() {
  
  ::sensory::api::v1::audio::TranscribeWordResponse* temp = wordlist_;
  wordlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::TranscribeWordResponse* TranscribeResponse::unsafe_arena_release_wordlist() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeResponse.wordList)
  
  ::sensory::api::v1::audio::TranscribeWordResponse* temp = wordlist_;
  wordlist_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::TranscribeWordResponse* TranscribeResponse::_internal_mutable_wordlist() {
  
  if (wordlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::TranscribeWordResponse>(GetArenaForAllocation());
    wordlist_ = p;
  }
  return wordlist_;
}
inline ::sensory::api::v1::audio::TranscribeWordResponse* TranscribeResponse::mutable_wordlist() {
  ::sensory::api::v1::audio::TranscribeWordResponse* _msg = _internal_mutable_wordlist();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeResponse.wordList)
  return _msg;
}
inline void TranscribeResponse::set_allocated_wordlist(::sensory::api::v1::audio::TranscribeWordResponse* wordlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wordlist_;
  }
  if (wordlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::TranscribeWordResponse>::GetOwningArena(wordlist);
    if (message_arena != submessage_arena) {
      wordlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wordlist, submessage_arena);
    }
    
  } else {
    
  }
  wordlist_ = wordlist;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeResponse.wordList)
}

// .sensory.api.v1.audio.AudioResponsePostProcessingAction postProcessingAction = 10;
inline bool TranscribeResponse::_internal_has_postprocessingaction() const {
  return this != internal_default_instance() && postprocessingaction_ != nullptr;
}
inline bool TranscribeResponse::has_postprocessingaction() const {
  return _internal_has_postprocessingaction();
}
inline void TranscribeResponse::clear_postprocessingaction() {
  if (GetArenaForAllocation() == nullptr && postprocessingaction_ != nullptr) {
    delete postprocessingaction_;
  }
  postprocessingaction_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& TranscribeResponse::_internal_postprocessingaction() const {
  const ::sensory::api::v1::audio::AudioResponsePostProcessingAction* p = postprocessingaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioResponsePostProcessingAction&>(
      ::sensory::api::v1::audio::_AudioResponsePostProcessingAction_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioResponsePostProcessingAction& TranscribeResponse::postprocessingaction() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeResponse.postProcessingAction)
  return _internal_postprocessingaction();
}
inline void TranscribeResponse::unsafe_arena_set_allocated_postprocessingaction(
    ::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(postprocessingaction_);
  }
  postprocessingaction_ = postprocessingaction;
  if (postprocessingaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.TranscribeResponse.postProcessingAction)
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* TranscribeResponse::release_postprocessingaction() {
  
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* TranscribeResponse::unsafe_arena_release_postprocessingaction() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeResponse.postProcessingAction)
  
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* temp = postprocessingaction_;
  postprocessingaction_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* TranscribeResponse::_internal_mutable_postprocessingaction() {
  
  if (postprocessingaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioResponsePostProcessingAction>(GetArenaForAllocation());
    postprocessingaction_ = p;
  }
  return postprocessingaction_;
}
inline ::sensory::api::v1::audio::AudioResponsePostProcessingAction* TranscribeResponse::mutable_postprocessingaction() {
  ::sensory::api::v1::audio::AudioResponsePostProcessingAction* _msg = _internal_mutable_postprocessingaction();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeResponse.postProcessingAction)
  return _msg;
}
inline void TranscribeResponse::set_allocated_postprocessingaction(::sensory::api::v1::audio::AudioResponsePostProcessingAction* postprocessingaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete postprocessingaction_;
  }
  if (postprocessingaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioResponsePostProcessingAction>::GetOwningArena(postprocessingaction);
    if (message_arena != submessage_arena) {
      postprocessingaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, postprocessingaction, submessage_arena);
    }
    
  } else {
    
  }
  postprocessingaction_ = postprocessingaction;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeResponse.postProcessingAction)
}

// -------------------------------------------------------------------

// SynthesizeSpeechResponse

// .sensory.api.v1.audio.AudioConfig config = 1;
inline bool SynthesizeSpeechResponse::_internal_has_config() const {
  return streamingResponse_case() == kConfig;
}
inline bool SynthesizeSpeechResponse::has_config() const {
  return _internal_has_config();
}
inline void SynthesizeSpeechResponse::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void SynthesizeSpeechResponse::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete streamingResponse_.config_;
    }
    clear_has_streamingResponse();
  }
}
inline ::sensory::api::v1::audio::AudioConfig* SynthesizeSpeechResponse::release_config() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.SynthesizeSpeechResponse.config)
  if (_internal_has_config()) {
    clear_has_streamingResponse();
      ::sensory::api::v1::audio::AudioConfig* temp = streamingResponse_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    streamingResponse_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensory::api::v1::audio::AudioConfig& SynthesizeSpeechResponse::_internal_config() const {
  return _internal_has_config()
      ? *streamingResponse_.config_
      : reinterpret_cast< ::sensory::api::v1::audio::AudioConfig&>(::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& SynthesizeSpeechResponse::config() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.SynthesizeSpeechResponse.config)
  return _internal_config();
}
inline ::sensory::api::v1::audio::AudioConfig* SynthesizeSpeechResponse::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensory.api.v1.audio.SynthesizeSpeechResponse.config)
  if (_internal_has_config()) {
    clear_has_streamingResponse();
    ::sensory::api::v1::audio::AudioConfig* temp = streamingResponse_.config_;
    streamingResponse_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SynthesizeSpeechResponse::unsafe_arena_set_allocated_config(::sensory::api::v1::audio::AudioConfig* config) {
  clear_streamingResponse();
  if (config) {
    set_has_config();
    streamingResponse_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.SynthesizeSpeechResponse.config)
}
inline ::sensory::api::v1::audio::AudioConfig* SynthesizeSpeechResponse::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_streamingResponse();
    set_has_config();
    streamingResponse_.config_ = CreateMaybeMessage< ::sensory::api::v1::audio::AudioConfig >(GetArenaForAllocation());
  }
  return streamingResponse_.config_;
}
inline ::sensory::api::v1::audio::AudioConfig* SynthesizeSpeechResponse::mutable_config() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.SynthesizeSpeechResponse.config)
  return _msg;
}

// bytes audioContent = 2;
inline bool SynthesizeSpeechResponse::_internal_has_audiocontent() const {
  return streamingResponse_case() == kAudioContent;
}
inline bool SynthesizeSpeechResponse::has_audiocontent() const {
  return _internal_has_audiocontent();
}
inline void SynthesizeSpeechResponse::set_has_audiocontent() {
  _oneof_case_[0] = kAudioContent;
}
inline void SynthesizeSpeechResponse::clear_audiocontent() {
  if (_internal_has_audiocontent()) {
    streamingResponse_.audiocontent_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_streamingResponse();
  }
}
inline const std::string& SynthesizeSpeechResponse::audiocontent() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.SynthesizeSpeechResponse.audioContent)
  return _internal_audiocontent();
}
template <typename ArgT0, typename... ArgT>
inline void SynthesizeSpeechResponse::set_audiocontent(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audiocontent()) {
    clear_streamingResponse();
    set_has_audiocontent();
    streamingResponse_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingResponse_.audiocontent_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.SynthesizeSpeechResponse.audioContent)
}
inline std::string* SynthesizeSpeechResponse::mutable_audiocontent() {
  std::string* _s = _internal_mutable_audiocontent();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.SynthesizeSpeechResponse.audioContent)
  return _s;
}
inline const std::string& SynthesizeSpeechResponse::_internal_audiocontent() const {
  if (_internal_has_audiocontent()) {
    return streamingResponse_.audiocontent_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SynthesizeSpeechResponse::_internal_set_audiocontent(const std::string& value) {
  if (!_internal_has_audiocontent()) {
    clear_streamingResponse();
    set_has_audiocontent();
    streamingResponse_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streamingResponse_.audiocontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SynthesizeSpeechResponse::_internal_mutable_audiocontent() {
  if (!_internal_has_audiocontent()) {
    clear_streamingResponse();
    set_has_audiocontent();
    streamingResponse_.audiocontent_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return streamingResponse_.audiocontent_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SynthesizeSpeechResponse::release_audiocontent() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.SynthesizeSpeechResponse.audioContent)
  if (_internal_has_audiocontent()) {
    clear_has_streamingResponse();
    return streamingResponse_.audiocontent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void SynthesizeSpeechResponse::set_allocated_audiocontent(std::string* audiocontent) {
  if (has_streamingResponse()) {
    clear_streamingResponse();
  }
  if (audiocontent != nullptr) {
    set_has_audiocontent();
    streamingResponse_.audiocontent_.UnsafeSetDefault(audiocontent);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(audiocontent);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.SynthesizeSpeechResponse.audioContent)
}

inline bool SynthesizeSpeechResponse::has_streamingResponse() const {
  return streamingResponse_case() != STREAMINGRESPONSE_NOT_SET;
}
inline void SynthesizeSpeechResponse::clear_has_streamingResponse() {
  _oneof_case_[0] = STREAMINGRESPONSE_NOT_SET;
}
inline SynthesizeSpeechResponse::StreamingResponseCase SynthesizeSpeechResponse::streamingResponse_case() const {
  return SynthesizeSpeechResponse::StreamingResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateEnrollmentConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool CreateEnrollmentConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool CreateEnrollmentConfig::has_audio() const {
  return _internal_has_audio();
}
inline void CreateEnrollmentConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& CreateEnrollmentConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& CreateEnrollmentConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
  return _internal_audio();
}
inline void CreateEnrollmentConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
  return _msg;
}
inline void CreateEnrollmentConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.audio)
}

// string userId = 2 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
}
inline std::string* CreateEnrollmentConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_userid() const {
  return userid_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.userId)
}

// string deviceId = 3 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::deviceid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
}
inline std::string* CreateEnrollmentConfig::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_deviceid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.deviceId)
}

// string modelName = 4 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
}
inline std::string* CreateEnrollmentConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.modelName)
}

// string description = 5 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.description)
}
inline std::string* CreateEnrollmentConfig::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.description)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_description() const {
  return description_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.description)
}

// bool isLivenessEnabled = 6;
inline void CreateEnrollmentConfig::clear_islivenessenabled() {
  islivenessenabled_ = false;
}
inline bool CreateEnrollmentConfig::_internal_islivenessenabled() const {
  return islivenessenabled_;
}
inline bool CreateEnrollmentConfig::islivenessenabled() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.isLivenessEnabled)
  return _internal_islivenessenabled();
}
inline void CreateEnrollmentConfig::_internal_set_islivenessenabled(bool value) {
  
  islivenessenabled_ = value;
}
inline void CreateEnrollmentConfig::set_islivenessenabled(bool value) {
  _internal_set_islivenessenabled(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.isLivenessEnabled)
}

// uint32 enrollmentNumUtterances = 7 [(.validate.rules) = {
inline bool CreateEnrollmentConfig::_internal_has_enrollmentnumutterances() const {
  return enrollLength_case() == kEnrollmentNumUtterances;
}
inline bool CreateEnrollmentConfig::has_enrollmentnumutterances() const {
  return _internal_has_enrollmentnumutterances();
}
inline void CreateEnrollmentConfig::set_has_enrollmentnumutterances() {
  _oneof_case_[0] = kEnrollmentNumUtterances;
}
inline void CreateEnrollmentConfig::clear_enrollmentnumutterances() {
  if (_internal_has_enrollmentnumutterances()) {
    enrollLength_.enrollmentnumutterances_ = 0u;
    clear_has_enrollLength();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateEnrollmentConfig::_internal_enrollmentnumutterances() const {
  if (_internal_has_enrollmentnumutterances()) {
    return enrollLength_.enrollmentnumutterances_;
  }
  return 0u;
}
inline void CreateEnrollmentConfig::_internal_set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_enrollmentnumutterances()) {
    clear_enrollLength();
    set_has_enrollmentnumutterances();
  }
  enrollLength_.enrollmentnumutterances_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateEnrollmentConfig::enrollmentnumutterances() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentNumUtterances)
  return _internal_enrollmentnumutterances();
}
inline void CreateEnrollmentConfig::set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_enrollmentnumutterances(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentNumUtterances)
}

// float enrollmentDuration = 8 [(.validate.rules) = {
inline bool CreateEnrollmentConfig::_internal_has_enrollmentduration() const {
  return enrollLength_case() == kEnrollmentDuration;
}
inline bool CreateEnrollmentConfig::has_enrollmentduration() const {
  return _internal_has_enrollmentduration();
}
inline void CreateEnrollmentConfig::set_has_enrollmentduration() {
  _oneof_case_[0] = kEnrollmentDuration;
}
inline void CreateEnrollmentConfig::clear_enrollmentduration() {
  if (_internal_has_enrollmentduration()) {
    enrollLength_.enrollmentduration_ = 0;
    clear_has_enrollLength();
  }
}
inline float CreateEnrollmentConfig::_internal_enrollmentduration() const {
  if (_internal_has_enrollmentduration()) {
    return enrollLength_.enrollmentduration_;
  }
  return 0;
}
inline void CreateEnrollmentConfig::_internal_set_enrollmentduration(float value) {
  if (!_internal_has_enrollmentduration()) {
    clear_enrollLength();
    set_has_enrollmentduration();
  }
  enrollLength_.enrollmentduration_ = value;
}
inline float CreateEnrollmentConfig::enrollmentduration() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentDuration)
  return _internal_enrollmentduration();
}
inline void CreateEnrollmentConfig::set_enrollmentduration(float value) {
  _internal_set_enrollmentduration(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.enrollmentDuration)
}

// string referenceId = 9 [(.validate.rules) = {
inline void CreateEnrollmentConfig::clear_referenceid() {
  referenceid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentConfig::referenceid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.referenceId)
  return _internal_referenceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentConfig::set_referenceid(ArgT0&& arg0, ArgT... args) {
 
 referenceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.referenceId)
}
inline std::string* CreateEnrollmentConfig::mutable_referenceid() {
  std::string* _s = _internal_mutable_referenceid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentConfig.referenceId)
  return _s;
}
inline const std::string& CreateEnrollmentConfig::_internal_referenceid() const {
  return referenceid_.Get();
}
inline void CreateEnrollmentConfig::_internal_set_referenceid(const std::string& value) {
  
  referenceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::_internal_mutable_referenceid() {
  
  return referenceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentConfig::release_referenceid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentConfig.referenceId)
  return referenceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentConfig::set_allocated_referenceid(std::string* referenceid) {
  if (referenceid != nullptr) {
    
  } else {
    
  }
  referenceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referenceid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentConfig.referenceId)
}

// bool disableServerEnrollmentTemplateStorage = 10;
inline void CreateEnrollmentConfig::clear_disableserverenrollmenttemplatestorage() {
  disableserverenrollmenttemplatestorage_ = false;
}
inline bool CreateEnrollmentConfig::_internal_disableserverenrollmenttemplatestorage() const {
  return disableserverenrollmenttemplatestorage_;
}
inline bool CreateEnrollmentConfig::disableserverenrollmenttemplatestorage() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentConfig.disableServerEnrollmentTemplateStorage)
  return _internal_disableserverenrollmenttemplatestorage();
}
inline void CreateEnrollmentConfig::_internal_set_disableserverenrollmenttemplatestorage(bool value) {
  
  disableserverenrollmenttemplatestorage_ = value;
}
inline void CreateEnrollmentConfig::set_disableserverenrollmenttemplatestorage(bool value) {
  _internal_set_disableserverenrollmenttemplatestorage(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentConfig.disableServerEnrollmentTemplateStorage)
}

inline bool CreateEnrollmentConfig::has_enrollLength() const {
  return enrollLength_case() != ENROLLLENGTH_NOT_SET;
}
inline void CreateEnrollmentConfig::clear_has_enrollLength() {
  _oneof_case_[0] = ENROLLLENGTH_NOT_SET;
}
inline CreateEnrollmentConfig::EnrollLengthCase CreateEnrollmentConfig::enrollLength_case() const {
  return CreateEnrollmentConfig::EnrollLengthCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthenticateConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool AuthenticateConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool AuthenticateConfig::has_audio() const {
  return _internal_has_audio();
}
inline void AuthenticateConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& AuthenticateConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& AuthenticateConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.audio)
  return _internal_audio();
}
inline void AuthenticateConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.AuthenticateConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* AuthenticateConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateConfig.audio)
  return _msg;
}
inline void AuthenticateConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateConfig.audio)
}

// string enrollmentId = 2 [(.validate.rules) = {
inline bool AuthenticateConfig::_internal_has_enrollmentid() const {
  return authId_case() == kEnrollmentId;
}
inline bool AuthenticateConfig::has_enrollmentid() const {
  return _internal_has_enrollmentid();
}
inline void AuthenticateConfig::set_has_enrollmentid() {
  _oneof_case_[0] = kEnrollmentId;
}
inline void AuthenticateConfig::clear_enrollmentid() {
  if (_internal_has_enrollmentid()) {
    authId_.enrollmentid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_authId();
  }
}
inline const std::string& AuthenticateConfig::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateConfig::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
}
inline std::string* AuthenticateConfig::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
  return _s;
}
inline const std::string& AuthenticateConfig::_internal_enrollmentid() const {
  if (_internal_has_enrollmentid()) {
    return authId_.enrollmentid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateConfig::_internal_set_enrollmentid(const std::string& value) {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::_internal_mutable_enrollmentid() {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return authId_.enrollmentid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
  if (_internal_has_enrollmentid()) {
    clear_has_authId();
    return authId_.enrollmentid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void AuthenticateConfig::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (has_authId()) {
    clear_authId();
  }
  if (enrollmentid != nullptr) {
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(enrollmentid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(enrollmentid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateConfig.enrollmentId)
}

// string enrollmentGroupId = 3;
inline bool AuthenticateConfig::_internal_has_enrollmentgroupid() const {
  return authId_case() == kEnrollmentGroupId;
}
inline bool AuthenticateConfig::has_enrollmentgroupid() const {
  return _internal_has_enrollmentgroupid();
}
inline void AuthenticateConfig::set_has_enrollmentgroupid() {
  _oneof_case_[0] = kEnrollmentGroupId;
}
inline void AuthenticateConfig::clear_enrollmentgroupid() {
  if (_internal_has_enrollmentgroupid()) {
    authId_.enrollmentgroupid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_authId();
  }
}
inline const std::string& AuthenticateConfig::enrollmentgroupid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
  return _internal_enrollmentgroupid();
}
template <typename ArgT0, typename... ArgT>
inline void AuthenticateConfig::set_enrollmentgroupid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentgroupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
}
inline std::string* AuthenticateConfig::mutable_enrollmentgroupid() {
  std::string* _s = _internal_mutable_enrollmentgroupid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
  return _s;
}
inline const std::string& AuthenticateConfig::_internal_enrollmentgroupid() const {
  if (_internal_has_enrollmentgroupid()) {
    return authId_.enrollmentgroupid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AuthenticateConfig::_internal_set_enrollmentgroupid(const std::string& value) {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentgroupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::_internal_mutable_enrollmentgroupid() {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return authId_.enrollmentgroupid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::release_enrollmentgroupid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
  if (_internal_has_enrollmentgroupid()) {
    clear_has_authId();
    return authId_.enrollmentgroupid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void AuthenticateConfig::set_allocated_enrollmentgroupid(std::string* enrollmentgroupid) {
  if (has_authId()) {
    clear_authId();
  }
  if (enrollmentgroupid != nullptr) {
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(enrollmentgroupid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(enrollmentgroupid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateConfig.enrollmentGroupId)
}

// bool doIncludeToken = 4;
inline void AuthenticateConfig::clear_doincludetoken() {
  doincludetoken_ = false;
}
inline bool AuthenticateConfig::_internal_doincludetoken() const {
  return doincludetoken_;
}
inline bool AuthenticateConfig::doincludetoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.doIncludeToken)
  return _internal_doincludetoken();
}
inline void AuthenticateConfig::_internal_set_doincludetoken(bool value) {
  
  doincludetoken_ = value;
}
inline void AuthenticateConfig::set_doincludetoken(bool value) {
  _internal_set_doincludetoken(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.doIncludeToken)
}

// .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 5 [(.validate.rules) = {
inline void AuthenticateConfig::clear_sensitivity() {
  sensitivity_ = 0;
}
inline ::sensory::api::v1::audio::ThresholdSensitivity AuthenticateConfig::_internal_sensitivity() const {
  return static_cast< ::sensory::api::v1::audio::ThresholdSensitivity >(sensitivity_);
}
inline ::sensory::api::v1::audio::ThresholdSensitivity AuthenticateConfig::sensitivity() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.sensitivity)
  return _internal_sensitivity();
}
inline void AuthenticateConfig::_internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  
  sensitivity_ = value;
}
inline void AuthenticateConfig::set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  _internal_set_sensitivity(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.sensitivity)
}

// .sensory.api.v1.audio.AuthenticateConfig.ThresholdSecurity security = 6 [(.validate.rules) = {
inline void AuthenticateConfig::clear_security() {
  security_ = 0;
}
inline ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity AuthenticateConfig::_internal_security() const {
  return static_cast< ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity >(security_);
}
inline ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity AuthenticateConfig::security() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.security)
  return _internal_security();
}
inline void AuthenticateConfig::_internal_set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value) {
  
  security_ = value;
}
inline void AuthenticateConfig::set_security(::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity value) {
  _internal_set_security(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.security)
}

// bool isLivenessEnabled = 7;
inline void AuthenticateConfig::clear_islivenessenabled() {
  islivenessenabled_ = false;
}
inline bool AuthenticateConfig::_internal_islivenessenabled() const {
  return islivenessenabled_;
}
inline bool AuthenticateConfig::islivenessenabled() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.isLivenessEnabled)
  return _internal_islivenessenabled();
}
inline void AuthenticateConfig::_internal_set_islivenessenabled(bool value) {
  
  islivenessenabled_ = value;
}
inline void AuthenticateConfig::set_islivenessenabled(bool value) {
  _internal_set_islivenessenabled(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.isLivenessEnabled)
}

// bytes enrollmentToken = 8;
inline void AuthenticateConfig::clear_enrollmenttoken() {
  enrollmenttoken_.ClearToEmpty();
}
inline const std::string& AuthenticateConfig::enrollmenttoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AuthenticateConfig.enrollmentToken)
  return _internal_enrollmenttoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateConfig::set_enrollmenttoken(ArgT0&& arg0, ArgT... args) {
 
 enrollmenttoken_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AuthenticateConfig.enrollmentToken)
}
inline std::string* AuthenticateConfig::mutable_enrollmenttoken() {
  std::string* _s = _internal_mutable_enrollmenttoken();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AuthenticateConfig.enrollmentToken)
  return _s;
}
inline const std::string& AuthenticateConfig::_internal_enrollmenttoken() const {
  return enrollmenttoken_.Get();
}
inline void AuthenticateConfig::_internal_set_enrollmenttoken(const std::string& value) {
  
  enrollmenttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::_internal_mutable_enrollmenttoken() {
  
  return enrollmenttoken_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateConfig::release_enrollmenttoken() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AuthenticateConfig.enrollmentToken)
  return enrollmenttoken_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthenticateConfig::set_allocated_enrollmenttoken(std::string* enrollmenttoken) {
  if (enrollmenttoken != nullptr) {
    
  } else {
    
  }
  enrollmenttoken_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmenttoken,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AuthenticateConfig.enrollmentToken)
}

inline bool AuthenticateConfig::has_authId() const {
  return authId_case() != AUTHID_NOT_SET;
}
inline void AuthenticateConfig::clear_has_authId() {
  _oneof_case_[0] = AUTHID_NOT_SET;
}
inline AuthenticateConfig::AuthIdCase AuthenticateConfig::authId_case() const {
  return AuthenticateConfig::AuthIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidateEventConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool ValidateEventConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool ValidateEventConfig::has_audio() const {
  return _internal_has_audio();
}
inline void ValidateEventConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& ValidateEventConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& ValidateEventConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.audio)
  return _internal_audio();
}
inline void ValidateEventConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEventConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEventConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventConfig.audio)
  return _msg;
}
inline void ValidateEventConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventConfig.audio)
}

// string modelName = 2 [(.validate.rules) = {
inline void ValidateEventConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& ValidateEventConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEventConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventConfig.modelName)
}
inline std::string* ValidateEventConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventConfig.modelName)
  return _s;
}
inline const std::string& ValidateEventConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void ValidateEventConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEventConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventConfig.modelName)
}

// string userId = 3 [(.validate.rules) = {
inline void ValidateEventConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& ValidateEventConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEventConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventConfig.userId)
}
inline std::string* ValidateEventConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEventConfig.userId)
  return _s;
}
inline const std::string& ValidateEventConfig::_internal_userid() const {
  return userid_.Get();
}
inline void ValidateEventConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEventConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEventConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEventConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEventConfig.userId)
}

// .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 4 [(.validate.rules) = {
inline void ValidateEventConfig::clear_sensitivity() {
  sensitivity_ = 0;
}
inline ::sensory::api::v1::audio::ThresholdSensitivity ValidateEventConfig::_internal_sensitivity() const {
  return static_cast< ::sensory::api::v1::audio::ThresholdSensitivity >(sensitivity_);
}
inline ::sensory::api::v1::audio::ThresholdSensitivity ValidateEventConfig::sensitivity() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEventConfig.sensitivity)
  return _internal_sensitivity();
}
inline void ValidateEventConfig::_internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  
  sensitivity_ = value;
}
inline void ValidateEventConfig::set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  _internal_set_sensitivity(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEventConfig.sensitivity)
}

// -------------------------------------------------------------------

// CreateEnrollmentEventConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool CreateEnrollmentEventConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool CreateEnrollmentEventConfig::has_audio() const {
  return _internal_has_audio();
}
inline void CreateEnrollmentEventConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& CreateEnrollmentEventConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& CreateEnrollmentEventConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentEventConfig.audio)
  return _internal_audio();
}
inline void CreateEnrollmentEventConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.CreateEnrollmentEventConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentEventConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentEventConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentEventConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentEventConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* CreateEnrollmentEventConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentEventConfig.audio)
  return _msg;
}
inline void CreateEnrollmentEventConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentEventConfig.audio)
}

// string userId = 2 [(.validate.rules) = {
inline void CreateEnrollmentEventConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentEventConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentEventConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentEventConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentEventConfig.userId)
}
inline std::string* CreateEnrollmentEventConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentEventConfig.userId)
  return _s;
}
inline const std::string& CreateEnrollmentEventConfig::_internal_userid() const {
  return userid_.Get();
}
inline void CreateEnrollmentEventConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentEventConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentEventConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentEventConfig.userId)
}

// string modelName = 3 [(.validate.rules) = {
inline void CreateEnrollmentEventConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentEventConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentEventConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentEventConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentEventConfig.modelName)
}
inline std::string* CreateEnrollmentEventConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentEventConfig.modelName)
  return _s;
}
inline const std::string& CreateEnrollmentEventConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void CreateEnrollmentEventConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentEventConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentEventConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentEventConfig.modelName)
}

// string description = 4 [(.validate.rules) = {
inline void CreateEnrollmentEventConfig::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentEventConfig::description() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentEventConfig.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentEventConfig::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentEventConfig.description)
}
inline std::string* CreateEnrollmentEventConfig::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentEventConfig.description)
  return _s;
}
inline const std::string& CreateEnrollmentEventConfig::_internal_description() const {
  return description_.Get();
}
inline void CreateEnrollmentEventConfig::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::release_description() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentEventConfig.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentEventConfig::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentEventConfig.description)
}

// uint32 enrollmentNumUtterances = 5 [(.validate.rules) = {
inline bool CreateEnrollmentEventConfig::_internal_has_enrollmentnumutterances() const {
  return enrollLength_case() == kEnrollmentNumUtterances;
}
inline bool CreateEnrollmentEventConfig::has_enrollmentnumutterances() const {
  return _internal_has_enrollmentnumutterances();
}
inline void CreateEnrollmentEventConfig::set_has_enrollmentnumutterances() {
  _oneof_case_[0] = kEnrollmentNumUtterances;
}
inline void CreateEnrollmentEventConfig::clear_enrollmentnumutterances() {
  if (_internal_has_enrollmentnumutterances()) {
    enrollLength_.enrollmentnumutterances_ = 0u;
    clear_has_enrollLength();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateEnrollmentEventConfig::_internal_enrollmentnumutterances() const {
  if (_internal_has_enrollmentnumutterances()) {
    return enrollLength_.enrollmentnumutterances_;
  }
  return 0u;
}
inline void CreateEnrollmentEventConfig::_internal_set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_enrollmentnumutterances()) {
    clear_enrollLength();
    set_has_enrollmentnumutterances();
  }
  enrollLength_.enrollmentnumutterances_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateEnrollmentEventConfig::enrollmentnumutterances() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentEventConfig.enrollmentNumUtterances)
  return _internal_enrollmentnumutterances();
}
inline void CreateEnrollmentEventConfig::set_enrollmentnumutterances(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_enrollmentnumutterances(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentEventConfig.enrollmentNumUtterances)
}

// float enrollmentDuration = 6 [(.validate.rules) = {
inline bool CreateEnrollmentEventConfig::_internal_has_enrollmentduration() const {
  return enrollLength_case() == kEnrollmentDuration;
}
inline bool CreateEnrollmentEventConfig::has_enrollmentduration() const {
  return _internal_has_enrollmentduration();
}
inline void CreateEnrollmentEventConfig::set_has_enrollmentduration() {
  _oneof_case_[0] = kEnrollmentDuration;
}
inline void CreateEnrollmentEventConfig::clear_enrollmentduration() {
  if (_internal_has_enrollmentduration()) {
    enrollLength_.enrollmentduration_ = 0;
    clear_has_enrollLength();
  }
}
inline float CreateEnrollmentEventConfig::_internal_enrollmentduration() const {
  if (_internal_has_enrollmentduration()) {
    return enrollLength_.enrollmentduration_;
  }
  return 0;
}
inline void CreateEnrollmentEventConfig::_internal_set_enrollmentduration(float value) {
  if (!_internal_has_enrollmentduration()) {
    clear_enrollLength();
    set_has_enrollmentduration();
  }
  enrollLength_.enrollmentduration_ = value;
}
inline float CreateEnrollmentEventConfig::enrollmentduration() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentEventConfig.enrollmentDuration)
  return _internal_enrollmentduration();
}
inline void CreateEnrollmentEventConfig::set_enrollmentduration(float value) {
  _internal_set_enrollmentduration(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentEventConfig.enrollmentDuration)
}

// string referenceId = 7 [(.validate.rules) = {
inline void CreateEnrollmentEventConfig::clear_referenceid() {
  referenceid_.ClearToEmpty();
}
inline const std::string& CreateEnrollmentEventConfig::referenceid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.CreateEnrollmentEventConfig.referenceId)
  return _internal_referenceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateEnrollmentEventConfig::set_referenceid(ArgT0&& arg0, ArgT... args) {
 
 referenceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.CreateEnrollmentEventConfig.referenceId)
}
inline std::string* CreateEnrollmentEventConfig::mutable_referenceid() {
  std::string* _s = _internal_mutable_referenceid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.CreateEnrollmentEventConfig.referenceId)
  return _s;
}
inline const std::string& CreateEnrollmentEventConfig::_internal_referenceid() const {
  return referenceid_.Get();
}
inline void CreateEnrollmentEventConfig::_internal_set_referenceid(const std::string& value) {
  
  referenceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::_internal_mutable_referenceid() {
  
  return referenceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateEnrollmentEventConfig::release_referenceid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.CreateEnrollmentEventConfig.referenceId)
  return referenceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateEnrollmentEventConfig::set_allocated_referenceid(std::string* referenceid) {
  if (referenceid != nullptr) {
    
  } else {
    
  }
  referenceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referenceid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.CreateEnrollmentEventConfig.referenceId)
}

inline bool CreateEnrollmentEventConfig::has_enrollLength() const {
  return enrollLength_case() != ENROLLLENGTH_NOT_SET;
}
inline void CreateEnrollmentEventConfig::clear_has_enrollLength() {
  _oneof_case_[0] = ENROLLLENGTH_NOT_SET;
}
inline CreateEnrollmentEventConfig::EnrollLengthCase CreateEnrollmentEventConfig::enrollLength_case() const {
  return CreateEnrollmentEventConfig::EnrollLengthCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValidateEnrolledEventConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool ValidateEnrolledEventConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool ValidateEnrolledEventConfig::has_audio() const {
  return _internal_has_audio();
}
inline void ValidateEnrolledEventConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& ValidateEnrolledEventConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& ValidateEnrolledEventConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventConfig.audio)
  return _internal_audio();
}
inline void ValidateEnrolledEventConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEnrolledEventConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEnrolledEventConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEnrolledEventConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* ValidateEnrolledEventConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventConfig.audio)
  return _msg;
}
inline void ValidateEnrolledEventConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventConfig.audio)
}

// string enrollmentId = 2 [(.validate.rules) = {
inline bool ValidateEnrolledEventConfig::_internal_has_enrollmentid() const {
  return authId_case() == kEnrollmentId;
}
inline bool ValidateEnrolledEventConfig::has_enrollmentid() const {
  return _internal_has_enrollmentid();
}
inline void ValidateEnrolledEventConfig::set_has_enrollmentid() {
  _oneof_case_[0] = kEnrollmentId;
}
inline void ValidateEnrolledEventConfig::clear_enrollmentid() {
  if (_internal_has_enrollmentid()) {
    authId_.enrollmentid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_authId();
  }
}
inline const std::string& ValidateEnrolledEventConfig::enrollmentid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentId)
  return _internal_enrollmentid();
}
template <typename ArgT0, typename... ArgT>
inline void ValidateEnrolledEventConfig::set_enrollmentid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentId)
}
inline std::string* ValidateEnrolledEventConfig::mutable_enrollmentid() {
  std::string* _s = _internal_mutable_enrollmentid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentId)
  return _s;
}
inline const std::string& ValidateEnrolledEventConfig::_internal_enrollmentid() const {
  if (_internal_has_enrollmentid()) {
    return authId_.enrollmentid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValidateEnrolledEventConfig::_internal_set_enrollmentid(const std::string& value) {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventConfig::_internal_mutable_enrollmentid() {
  if (!_internal_has_enrollmentid()) {
    clear_authId();
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return authId_.enrollmentid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventConfig::release_enrollmentid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentId)
  if (_internal_has_enrollmentid()) {
    clear_has_authId();
    return authId_.enrollmentid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ValidateEnrolledEventConfig::set_allocated_enrollmentid(std::string* enrollmentid) {
  if (has_authId()) {
    clear_authId();
  }
  if (enrollmentid != nullptr) {
    set_has_enrollmentid();
    authId_.enrollmentid_.UnsafeSetDefault(enrollmentid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(enrollmentid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentId)
}

// string enrollmentGroupId = 3;
inline bool ValidateEnrolledEventConfig::_internal_has_enrollmentgroupid() const {
  return authId_case() == kEnrollmentGroupId;
}
inline bool ValidateEnrolledEventConfig::has_enrollmentgroupid() const {
  return _internal_has_enrollmentgroupid();
}
inline void ValidateEnrolledEventConfig::set_has_enrollmentgroupid() {
  _oneof_case_[0] = kEnrollmentGroupId;
}
inline void ValidateEnrolledEventConfig::clear_enrollmentgroupid() {
  if (_internal_has_enrollmentgroupid()) {
    authId_.enrollmentgroupid_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_authId();
  }
}
inline const std::string& ValidateEnrolledEventConfig::enrollmentgroupid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentGroupId)
  return _internal_enrollmentgroupid();
}
template <typename ArgT0, typename... ArgT>
inline void ValidateEnrolledEventConfig::set_enrollmentgroupid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentgroupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentGroupId)
}
inline std::string* ValidateEnrolledEventConfig::mutable_enrollmentgroupid() {
  std::string* _s = _internal_mutable_enrollmentgroupid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentGroupId)
  return _s;
}
inline const std::string& ValidateEnrolledEventConfig::_internal_enrollmentgroupid() const {
  if (_internal_has_enrollmentgroupid()) {
    return authId_.enrollmentgroupid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValidateEnrolledEventConfig::_internal_set_enrollmentgroupid(const std::string& value) {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  authId_.enrollmentgroupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventConfig::_internal_mutable_enrollmentgroupid() {
  if (!_internal_has_enrollmentgroupid()) {
    clear_authId();
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return authId_.enrollmentgroupid_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventConfig::release_enrollmentgroupid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentGroupId)
  if (_internal_has_enrollmentgroupid()) {
    clear_has_authId();
    return authId_.enrollmentgroupid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ValidateEnrolledEventConfig::set_allocated_enrollmentgroupid(std::string* enrollmentgroupid) {
  if (has_authId()) {
    clear_authId();
  }
  if (enrollmentgroupid != nullptr) {
    set_has_enrollmentgroupid();
    authId_.enrollmentgroupid_.UnsafeSetDefault(enrollmentgroupid);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(enrollmentgroupid);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentGroupId)
}

// .sensory.api.v1.audio.ThresholdSensitivity sensitivity = 4 [(.validate.rules) = {
inline void ValidateEnrolledEventConfig::clear_sensitivity() {
  sensitivity_ = 0;
}
inline ::sensory::api::v1::audio::ThresholdSensitivity ValidateEnrolledEventConfig::_internal_sensitivity() const {
  return static_cast< ::sensory::api::v1::audio::ThresholdSensitivity >(sensitivity_);
}
inline ::sensory::api::v1::audio::ThresholdSensitivity ValidateEnrolledEventConfig::sensitivity() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventConfig.sensitivity)
  return _internal_sensitivity();
}
inline void ValidateEnrolledEventConfig::_internal_set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  
  sensitivity_ = value;
}
inline void ValidateEnrolledEventConfig::set_sensitivity(::sensory::api::v1::audio::ThresholdSensitivity value) {
  _internal_set_sensitivity(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventConfig.sensitivity)
}

// bytes enrollmentToken = 5;
inline void ValidateEnrolledEventConfig::clear_enrollmenttoken() {
  enrollmenttoken_.ClearToEmpty();
}
inline const std::string& ValidateEnrolledEventConfig::enrollmenttoken() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentToken)
  return _internal_enrollmenttoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateEnrolledEventConfig::set_enrollmenttoken(ArgT0&& arg0, ArgT... args) {
 
 enrollmenttoken_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentToken)
}
inline std::string* ValidateEnrolledEventConfig::mutable_enrollmenttoken() {
  std::string* _s = _internal_mutable_enrollmenttoken();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentToken)
  return _s;
}
inline const std::string& ValidateEnrolledEventConfig::_internal_enrollmenttoken() const {
  return enrollmenttoken_.Get();
}
inline void ValidateEnrolledEventConfig::_internal_set_enrollmenttoken(const std::string& value) {
  
  enrollmenttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventConfig::_internal_mutable_enrollmenttoken() {
  
  return enrollmenttoken_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ValidateEnrolledEventConfig::release_enrollmenttoken() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentToken)
  return enrollmenttoken_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ValidateEnrolledEventConfig::set_allocated_enrollmenttoken(std::string* enrollmenttoken) {
  if (enrollmenttoken != nullptr) {
    
  } else {
    
  }
  enrollmenttoken_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enrollmenttoken,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.ValidateEnrolledEventConfig.enrollmentToken)
}

inline bool ValidateEnrolledEventConfig::has_authId() const {
  return authId_case() != AUTHID_NOT_SET;
}
inline void ValidateEnrolledEventConfig::clear_has_authId() {
  _oneof_case_[0] = AUTHID_NOT_SET;
}
inline ValidateEnrolledEventConfig::AuthIdCase ValidateEnrolledEventConfig::authId_case() const {
  return ValidateEnrolledEventConfig::AuthIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TranscribeConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool TranscribeConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool TranscribeConfig::has_audio() const {
  return _internal_has_audio();
}
inline void TranscribeConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& TranscribeConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& TranscribeConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeConfig.audio)
  return _internal_audio();
}
inline void TranscribeConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.TranscribeConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* TranscribeConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeConfig.audio)
  return _msg;
}
inline void TranscribeConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeConfig.audio)
}

// string modelName = 2 [(.validate.rules) = {
inline void TranscribeConfig::clear_modelname() {
  modelname_.ClearToEmpty();
}
inline const std::string& TranscribeConfig::modelname() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeConfig.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscribeConfig::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeConfig.modelName)
}
inline std::string* TranscribeConfig::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeConfig.modelName)
  return _s;
}
inline const std::string& TranscribeConfig::_internal_modelname() const {
  return modelname_.Get();
}
inline void TranscribeConfig::_internal_set_modelname(const std::string& value) {
  
  modelname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::_internal_mutable_modelname() {
  
  return modelname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::release_modelname() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeConfig.modelName)
  return modelname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranscribeConfig::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeConfig.modelName)
}

// string userId = 3 [(.validate.rules) = {
inline void TranscribeConfig::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& TranscribeConfig::userid() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.TranscribeConfig.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscribeConfig::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.TranscribeConfig.userId)
}
inline std::string* TranscribeConfig::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.TranscribeConfig.userId)
  return _s;
}
inline const std::string& TranscribeConfig::_internal_userid() const {
  return userid_.Get();
}
inline void TranscribeConfig::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TranscribeConfig::release_userid() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.TranscribeConfig.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TranscribeConfig::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.TranscribeConfig.userId)
}

// -------------------------------------------------------------------

// AudioConfig

// .sensory.api.v1.audio.AudioConfig.AudioEncoding encoding = 1 [(.validate.rules) = {
inline void AudioConfig::clear_encoding() {
  encoding_ = 0;
}
inline ::sensory::api::v1::audio::AudioConfig_AudioEncoding AudioConfig::_internal_encoding() const {
  return static_cast< ::sensory::api::v1::audio::AudioConfig_AudioEncoding >(encoding_);
}
inline ::sensory::api::v1::audio::AudioConfig_AudioEncoding AudioConfig::encoding() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.encoding)
  return _internal_encoding();
}
inline void AudioConfig::_internal_set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value) {
  
  encoding_ = value;
}
inline void AudioConfig::set_encoding(::sensory::api::v1::audio::AudioConfig_AudioEncoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.encoding)
}

// int32 sampleRateHertz = 2 [(.validate.rules) = {
inline void AudioConfig::clear_sampleratehertz() {
  sampleratehertz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::_internal_sampleratehertz() const {
  return sampleratehertz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::sampleratehertz() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.sampleRateHertz)
  return _internal_sampleratehertz();
}
inline void AudioConfig::_internal_set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sampleratehertz_ = value;
}
inline void AudioConfig::set_sampleratehertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sampleratehertz(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.sampleRateHertz)
}

// int32 audioChannelCount = 3 [(.validate.rules) = {
inline void AudioConfig::clear_audiochannelcount() {
  audiochannelcount_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::_internal_audiochannelcount() const {
  return audiochannelcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::audiochannelcount() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.audioChannelCount)
  return _internal_audiochannelcount();
}
inline void AudioConfig::_internal_set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  audiochannelcount_ = value;
}
inline void AudioConfig::set_audiochannelcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_audiochannelcount(value);
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.audioChannelCount)
}

// string languageCode = 4;
inline void AudioConfig::clear_languagecode() {
  languagecode_.ClearToEmpty();
}
inline const std::string& AudioConfig::languagecode() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.AudioConfig.languageCode)
  return _internal_languagecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioConfig::set_languagecode(ArgT0&& arg0, ArgT... args) {
 
 languagecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.AudioConfig.languageCode)
}
inline std::string* AudioConfig::mutable_languagecode() {
  std::string* _s = _internal_mutable_languagecode();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.AudioConfig.languageCode)
  return _s;
}
inline const std::string& AudioConfig::_internal_languagecode() const {
  return languagecode_.Get();
}
inline void AudioConfig::_internal_set_languagecode(const std::string& value) {
  
  languagecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AudioConfig::_internal_mutable_languagecode() {
  
  return languagecode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AudioConfig::release_languagecode() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.AudioConfig.languageCode)
  return languagecode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AudioConfig::set_allocated_languagecode(std::string* languagecode) {
  if (languagecode != nullptr) {
    
  } else {
    
  }
  languagecode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), languagecode,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.AudioConfig.languageCode)
}

// -------------------------------------------------------------------

// VoiceSynthesisConfig

// .sensory.api.v1.audio.AudioConfig audio = 1 [(.validate.rules) = {
inline bool VoiceSynthesisConfig::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool VoiceSynthesisConfig::has_audio() const {
  return _internal_has_audio();
}
inline void VoiceSynthesisConfig::clear_audio() {
  if (GetArenaForAllocation() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::sensory::api::v1::audio::AudioConfig& VoiceSynthesisConfig::_internal_audio() const {
  const ::sensory::api::v1::audio::AudioConfig* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensory::api::v1::audio::AudioConfig&>(
      ::sensory::api::v1::audio::_AudioConfig_default_instance_);
}
inline const ::sensory::api::v1::audio::AudioConfig& VoiceSynthesisConfig::audio() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.VoiceSynthesisConfig.audio)
  return _internal_audio();
}
inline void VoiceSynthesisConfig::unsafe_arena_set_allocated_audio(
    ::sensory::api::v1::audio::AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensory.api.v1.audio.VoiceSynthesisConfig.audio)
}
inline ::sensory::api::v1::audio::AudioConfig* VoiceSynthesisConfig::release_audio() {
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* VoiceSynthesisConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.VoiceSynthesisConfig.audio)
  
  ::sensory::api::v1::audio::AudioConfig* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::sensory::api::v1::audio::AudioConfig* VoiceSynthesisConfig::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensory::api::v1::audio::AudioConfig>(GetArenaForAllocation());
    audio_ = p;
  }
  return audio_;
}
inline ::sensory::api::v1::audio::AudioConfig* VoiceSynthesisConfig::mutable_audio() {
  ::sensory::api::v1::audio::AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.VoiceSynthesisConfig.audio)
  return _msg;
}
inline void VoiceSynthesisConfig::set_allocated_audio(::sensory::api::v1::audio::AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sensory::api::v1::audio::AudioConfig>::GetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.VoiceSynthesisConfig.audio)
}

// string voice = 2 [(.validate.rules) = {
inline void VoiceSynthesisConfig::clear_voice() {
  voice_.ClearToEmpty();
}
inline const std::string& VoiceSynthesisConfig::voice() const {
  // @@protoc_insertion_point(field_get:sensory.api.v1.audio.VoiceSynthesisConfig.voice)
  return _internal_voice();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceSynthesisConfig::set_voice(ArgT0&& arg0, ArgT... args) {
 
 voice_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sensory.api.v1.audio.VoiceSynthesisConfig.voice)
}
inline std::string* VoiceSynthesisConfig::mutable_voice() {
  std::string* _s = _internal_mutable_voice();
  // @@protoc_insertion_point(field_mutable:sensory.api.v1.audio.VoiceSynthesisConfig.voice)
  return _s;
}
inline const std::string& VoiceSynthesisConfig::_internal_voice() const {
  return voice_.Get();
}
inline void VoiceSynthesisConfig::_internal_set_voice(const std::string& value) {
  
  voice_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoiceSynthesisConfig::_internal_mutable_voice() {
  
  return voice_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoiceSynthesisConfig::release_voice() {
  // @@protoc_insertion_point(field_release:sensory.api.v1.audio.VoiceSynthesisConfig.voice)
  return voice_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoiceSynthesisConfig::set_allocated_voice(std::string* voice) {
  if (voice != nullptr) {
    
  } else {
    
  }
  voice_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), voice,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:sensory.api.v1.audio.VoiceSynthesisConfig.voice)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace audio
}  // namespace v1
}  // namespace api
}  // namespace sensory

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity>() {
  return ::sensory::api::v1::audio::AuthenticateConfig_ThresholdSecurity_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::v1::audio::AudioConfig_AudioEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::AudioConfig_AudioEncoding>() {
  return ::sensory::api::v1::audio::AudioConfig_AudioEncoding_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::v1::audio::AudioPostProcessingAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::AudioPostProcessingAction>() {
  return ::sensory::api::v1::audio::AudioPostProcessingAction_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::v1::audio::WordState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::WordState>() {
  return ::sensory::api::v1::audio::WordState_descriptor();
}
template <> struct is_proto_enum< ::sensory::api::v1::audio::ThresholdSensitivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensory::api::v1::audio::ThresholdSensitivity>() {
  return ::sensory::api::v1::audio::ThresholdSensitivity_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_v1_2faudio_2faudio_2eproto
